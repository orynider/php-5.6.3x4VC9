; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\inftrees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_copyright
_inflate_copyright DB ' inflate 1.2.11 Copyright 1995-2017 Mark Adler ', 00H
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	04dH
	DW	0caH
	ORG $+6
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
PUBLIC	_inflate_table
; Function compile flags: /Odtp
; File c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\inftrees.c
;	COMDAT _inflate_table
_TEXT	SEGMENT
tv187 = -144						; size = 4
_max$ = -140						; size = 4
_used$ = -136						; size = 4
_low$ = -132						; size = 4
_sym$ = -128						; size = 4
_match$ = -124						; size = 4
_fill$ = -120						; size = 4
_offs$ = -116						; size = 32
_incr$ = -84						; size = 4
_len$ = -80						; size = 4
_left$ = -76						; size = 4
_next$ = -72						; size = 4
_root$ = -68						; size = 4
_curr$ = -64						; size = 4
_drop$ = -60						; size = 4
_mask$ = -56						; size = 4
_min$ = -52						; size = 4
_huff$ = -48						; size = 4
_base$ = -44						; size = 4
_extra$ = -40						; size = 4
_here$ = -36						; size = 4
_count$ = -32						; size = 32
_type$ = 8						; size = 4
_lens$ = 12						; size = 4
_codes$ = 16						; size = 4
_table$ = 20						; size = 4
_bits$ = 24						; size = 4
_work$ = 28						; size = 4
_inflate_table PROC					; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     unsigned match;             /* use base and extra for symbol >= match */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  00009	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN62@inflate_ta
$LN61@inflate_ta:
  00012	8b 45 b0	 mov	 eax, DWORD PTR _len$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 b0	 mov	 DWORD PTR _len$[ebp], eax
$LN62@inflate_ta:
  0001b	83 7d b0 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  0001f	77 0c		 ja	 SHORT $LN60@inflate_ta

; 108  :         count[len] = 0;

  00021	33 c9		 xor	 ecx, ecx
  00023	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  00026	66 89 4c 55 e0	 mov	 WORD PTR _count$[ebp+edx*2], cx
  0002b	eb e5		 jmp	 SHORT $LN61@inflate_ta
$LN60@inflate_ta:

; 109  :     for (sym = 0; sym < codes; sym++)

  0002d	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN59@inflate_ta
$LN58@inflate_ta:
  00036	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 80	 mov	 DWORD PTR _sym$[ebp], eax
$LN59@inflate_ta:
  0003f	8b 4d 80	 mov	 ecx, DWORD PTR _sym$[ebp]
  00042	3b 4d 10	 cmp	 ecx, DWORD PTR _codes$[ebp]
  00045	73 24		 jae	 SHORT $LN57@inflate_ta

; 110  :         count[lens[sym]]++;

  00047	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  0004d	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00051	66 8b 54 4d e0	 mov	 dx, WORD PTR _count$[ebp+ecx*2]
  00056	66 83 c2 01	 add	 dx, 1
  0005a	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _lens$[ebp]
  00060	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00064	66 89 54 45 e0	 mov	 WORD PTR _count$[ebp+eax*2], dx
  00069	eb cb		 jmp	 SHORT $LN58@inflate_ta
$LN57@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  0006b	8b 4d 18	 mov	 ecx, DWORD PTR _bits$[ebp]
  0006e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00070	89 55 bc	 mov	 DWORD PTR _root$[ebp], edx

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00073	c7 85 74 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _max$[ebp], 15 ; 0000000fH
  0007d	eb 0f		 jmp	 SHORT $LN56@inflate_ta
$LN55@inflate_ta:
  0007f	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _max$[ebp]
  00085	83 e8 01	 sub	 eax, 1
  00088	89 85 74 ff ff
	ff		 mov	 DWORD PTR _max$[ebp], eax
$LN56@inflate_ta:
  0008e	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR _max$[ebp], 1
  00095	72 13		 jb	 SHORT $LN54@inflate_ta

; 115  :         if (count[max] != 0) break;

  00097	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _max$[ebp]
  0009d	0f b7 54 4d e0	 movzx	 edx, WORD PTR _count$[ebp+ecx*2]
  000a2	85 d2		 test	 edx, edx
  000a4	74 02		 je	 SHORT $LN53@inflate_ta
  000a6	eb 02		 jmp	 SHORT $LN54@inflate_ta
$LN53@inflate_ta:

; 116  :     if (root > max) root = max;

  000a8	eb d5		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:
  000aa	8b 45 bc	 mov	 eax, DWORD PTR _root$[ebp]
  000ad	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _max$[ebp]
  000b3	76 09		 jbe	 SHORT $LN52@inflate_ta
  000b5	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _max$[ebp]
  000bb	89 4d bc	 mov	 DWORD PTR _root$[ebp], ecx
$LN52@inflate_ta:

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  000be	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _max$[ebp], 0
  000c5	75 4c		 jne	 SHORT $LN51@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */

  000c7	c6 45 dc 40	 mov	 BYTE PTR _here$[ebp], 64 ; 00000040H

; 119  :         here.bits = (unsigned char)1;

  000cb	c6 45 dd 01	 mov	 BYTE PTR _here$[ebp+1], 1

; 120  :         here.val = (unsigned short)0;

  000cf	33 d2		 xor	 edx, edx
  000d1	66 89 55 de	 mov	 WORD PTR _here$[ebp+2], dx

; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000d5	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	8b 55 dc	 mov	 edx, DWORD PTR _here$[ebp]
  000dd	89 11		 mov	 DWORD PTR [ecx], edx
  000df	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e4	83 c1 04	 add	 ecx, 4
  000e7	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  000ea	89 0a		 mov	 DWORD PTR [edx], ecx

; 122  :         *(*table)++ = here;

  000ec	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f1	8b 55 dc	 mov	 edx, DWORD PTR _here$[ebp]
  000f4	89 11		 mov	 DWORD PTR [ecx], edx
  000f6	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	83 c1 04	 add	 ecx, 4
  000fe	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00101	89 0a		 mov	 DWORD PTR [edx], ecx

; 123  :         *bits = 1;

  00103	8b 45 18	 mov	 eax, DWORD PTR _bits$[ebp]
  00106	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  0010c	33 c0		 xor	 eax, eax
  0010e	e9 c4 04 00 00	 jmp	 $LN63@inflate_ta
$LN51@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00113	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _min$[ebp], 1
  0011a	eb 09		 jmp	 SHORT $LN50@inflate_ta
$LN49@inflate_ta:
  0011c	8b 4d cc	 mov	 ecx, DWORD PTR _min$[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d cc	 mov	 DWORD PTR _min$[ebp], ecx
$LN50@inflate_ta:
  00125	8b 55 cc	 mov	 edx, DWORD PTR _min$[ebp]
  00128	3b 95 74 ff ff
	ff		 cmp	 edx, DWORD PTR _max$[ebp]
  0012e	73 10		 jae	 SHORT $LN48@inflate_ta

; 127  :         if (count[min] != 0) break;

  00130	8b 45 cc	 mov	 eax, DWORD PTR _min$[ebp]
  00133	0f b7 4c 45 e0	 movzx	 ecx, WORD PTR _count$[ebp+eax*2]
  00138	85 c9		 test	 ecx, ecx
  0013a	74 02		 je	 SHORT $LN47@inflate_ta
  0013c	eb 02		 jmp	 SHORT $LN48@inflate_ta
$LN47@inflate_ta:

; 128  :     if (root < min) root = min;

  0013e	eb dc		 jmp	 SHORT $LN49@inflate_ta
$LN48@inflate_ta:
  00140	8b 55 bc	 mov	 edx, DWORD PTR _root$[ebp]
  00143	3b 55 cc	 cmp	 edx, DWORD PTR _min$[ebp]
  00146	73 06		 jae	 SHORT $LN46@inflate_ta
  00148	8b 45 cc	 mov	 eax, DWORD PTR _min$[ebp]
  0014b	89 45 bc	 mov	 DWORD PTR _root$[ebp], eax
$LN46@inflate_ta:

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  0014e	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _left$[ebp], 1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00155	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  0015c	eb 09		 jmp	 SHORT $LN45@inflate_ta
$LN44@inflate_ta:
  0015e	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  00161	83 c1 01	 add	 ecx, 1
  00164	89 4d b0	 mov	 DWORD PTR _len$[ebp], ecx
$LN45@inflate_ta:
  00167	83 7d b0 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  0016b	77 24		 ja	 SHORT $LN43@inflate_ta

; 133  :         left <<= 1;

  0016d	8b 55 b4	 mov	 edx, DWORD PTR _left$[ebp]
  00170	d1 e2		 shl	 edx, 1
  00172	89 55 b4	 mov	 DWORD PTR _left$[ebp], edx

; 134  :         left -= count[len];

  00175	8b 45 b0	 mov	 eax, DWORD PTR _len$[ebp]
  00178	0f b7 4c 45 e0	 movzx	 ecx, WORD PTR _count$[ebp+eax*2]
  0017d	8b 55 b4	 mov	 edx, DWORD PTR _left$[ebp]
  00180	2b d1		 sub	 edx, ecx
  00182	89 55 b4	 mov	 DWORD PTR _left$[ebp], edx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  00185	79 08		 jns	 SHORT $LN42@inflate_ta
  00187	83 c8 ff	 or	 eax, -1
  0018a	e9 48 04 00 00	 jmp	 $LN63@inflate_ta
$LN42@inflate_ta:

; 136  :     }

  0018f	eb cd		 jmp	 SHORT $LN44@inflate_ta
$LN43@inflate_ta:

; 137  :     if (left > 0 && (type == CODES || max != 1))

  00191	83 7d b4 00	 cmp	 DWORD PTR _left$[ebp], 0
  00195	7e 17		 jle	 SHORT $LN41@inflate_ta
  00197	83 7d 08 00	 cmp	 DWORD PTR _type$[ebp], 0
  0019b	74 09		 je	 SHORT $LN40@inflate_ta
  0019d	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR _max$[ebp], 1
  001a4	74 08		 je	 SHORT $LN41@inflate_ta
$LN40@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  001a6	83 c8 ff	 or	 eax, -1
  001a9	e9 29 04 00 00	 jmp	 $LN63@inflate_ta
$LN41@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  001ae	33 c0		 xor	 eax, eax
  001b0	66 89 45 8e	 mov	 WORD PTR _offs$[ebp+2], ax

; 142  :     for (len = 1; len < MAXBITS; len++)

  001b4	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  001bb	eb 09		 jmp	 SHORT $LN39@inflate_ta
$LN38@inflate_ta:
  001bd	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  001c0	83 c1 01	 add	 ecx, 1
  001c3	89 4d b0	 mov	 DWORD PTR _len$[ebp], ecx
$LN39@inflate_ta:
  001c6	83 7d b0 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  001ca	73 1c		 jae	 SHORT $LN37@inflate_ta

; 143  :         offs[len + 1] = offs[len] + count[len];

  001cc	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  001cf	0f b7 44 55 8c	 movzx	 eax, WORD PTR _offs$[ebp+edx*2]
  001d4	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  001d7	0f b7 54 4d e0	 movzx	 edx, WORD PTR _count$[ebp+ecx*2]
  001dc	03 c2		 add	 eax, edx
  001de	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  001e1	66 89 44 4d 8e	 mov	 WORD PTR _offs$[ebp+ecx*2+2], ax
  001e6	eb d5		 jmp	 SHORT $LN38@inflate_ta
$LN37@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001e8	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  001ef	eb 09		 jmp	 SHORT $LN36@inflate_ta
$LN35@inflate_ta:
  001f1	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  001f4	83 c2 01	 add	 edx, 1
  001f7	89 55 80	 mov	 DWORD PTR _sym$[ebp], edx
$LN36@inflate_ta:
  001fa	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  001fd	3b 45 10	 cmp	 eax, DWORD PTR _codes$[ebp]
  00200	73 4c		 jae	 SHORT $LN34@inflate_ta

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00202	8b 4d 80	 mov	 ecx, DWORD PTR _sym$[ebp]
  00205	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  00208	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0020c	85 c0		 test	 eax, eax
  0020e	74 3c		 je	 SHORT $LN33@inflate_ta
  00210	8b 4d 80	 mov	 ecx, DWORD PTR _sym$[ebp]
  00213	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  00216	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0021a	0f b7 4c 45 8c	 movzx	 ecx, WORD PTR _offs$[ebp+eax*2]
  0021f	8b 55 1c	 mov	 edx, DWORD PTR _work$[ebp]
  00222	66 8b 45 80	 mov	 ax, WORD PTR _sym$[ebp]
  00226	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0022a	8b 4d 80	 mov	 ecx, DWORD PTR _sym$[ebp]
  0022d	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  00230	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00234	66 8b 4c 45 8c	 mov	 cx, WORD PTR _offs$[ebp+eax*2]
  00239	66 83 c1 01	 add	 cx, 1
  0023d	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  00240	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00243	0f b7 14 50	 movzx	 edx, WORD PTR [eax+edx*2]
  00247	66 89 4c 55 8c	 mov	 WORD PTR _offs$[ebp+edx*2], cx
$LN33@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  0024c	eb a3		 jmp	 SHORT $LN35@inflate_ta
$LN34@inflate_ta:
  0024e	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00251	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv187[ebp], eax
  00257	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv187[ebp], 0
  0025e	74 0b		 je	 SHORT $LN30@inflate_ta
  00260	83 bd 70 ff ff
	ff 01		 cmp	 DWORD PTR tv187[ebp], 1
  00267	74 17		 je	 SHORT $LN29@inflate_ta
  00269	eb 2c		 jmp	 SHORT $LN28@inflate_ta
$LN30@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  0026b	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  0026e	89 4d d8	 mov	 DWORD PTR _extra$[ebp], ecx
  00271	8b 55 d8	 mov	 edx, DWORD PTR _extra$[ebp]
  00274	89 55 d4	 mov	 DWORD PTR _base$[ebp], edx

; 184  :         match = 20;

  00277	c7 45 84 14 00
	00 00		 mov	 DWORD PTR _match$[ebp], 20 ; 00000014H

; 185  :         break;

  0027e	eb 2c		 jmp	 SHORT $LN31@inflate_ta
$LN29@inflate_ta:

; 186  :     case LENS:
; 187  :         base = lbase;

  00280	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _base$[ebp], OFFSET ?lbase@?1??inflate_table@@9@9

; 188  :         extra = lext;

  00287	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _extra$[ebp], OFFSET ?lext@?1??inflate_table@@9@9

; 189  :         match = 257;

  0028e	c7 45 84 01 01
	00 00		 mov	 DWORD PTR _match$[ebp], 257 ; 00000101H

; 190  :         break;

  00295	eb 15		 jmp	 SHORT $LN31@inflate_ta
$LN28@inflate_ta:

; 191  :     default:    /* DISTS */
; 192  :         base = dbase;

  00297	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _base$[ebp], OFFSET ?dbase@?1??inflate_table@@9@9

; 193  :         extra = dext;

  0029e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _extra$[ebp], OFFSET ?dext@?1??inflate_table@@9@9

; 194  :         match = 0;

  002a5	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _match$[ebp], 0
$LN31@inflate_ta:

; 195  :     }
; 196  : 
; 197  :     /* initialize state for loop */
; 198  :     huff = 0;                   /* starting code */

  002ac	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _huff$[ebp], 0

; 199  :     sym = 0;                    /* starting code symbol */

  002b3	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0

; 200  :     len = min;                  /* starting code length */

  002ba	8b 45 cc	 mov	 eax, DWORD PTR _min$[ebp]
  002bd	89 45 b0	 mov	 DWORD PTR _len$[ebp], eax

; 201  :     next = *table;              /* current table to fill in */

  002c0	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  002c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c5	89 55 b8	 mov	 DWORD PTR _next$[ebp], edx

; 202  :     curr = root;                /* current table index bits */

  002c8	8b 45 bc	 mov	 eax, DWORD PTR _root$[ebp]
  002cb	89 45 c0	 mov	 DWORD PTR _curr$[ebp], eax

; 203  :     drop = 0;                   /* current bits to drop from code for index */

  002ce	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _drop$[ebp], 0

; 204  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */

  002d5	c7 85 7c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _low$[ebp], -1

; 205  :     used = 1U << root;          /* use root table entries */

  002df	ba 01 00 00 00	 mov	 edx, 1
  002e4	8b 4d bc	 mov	 ecx, DWORD PTR _root$[ebp]
  002e7	d3 e2		 shl	 edx, cl
  002e9	89 95 78 ff ff
	ff		 mov	 DWORD PTR _used$[ebp], edx

; 206  :     mask = used - 1;            /* mask for comparing low */

  002ef	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _used$[ebp]
  002f5	83 e8 01	 sub	 eax, 1
  002f8	89 45 c8	 mov	 DWORD PTR _mask$[ebp], eax

; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||
; 210  :         (type == DISTS && used > ENOUGH_DISTS))

  002fb	83 7d 08 01	 cmp	 DWORD PTR _type$[ebp], 1
  002ff	75 0c		 jne	 SHORT $LN25@inflate_ta
  00301	81 bd 78 ff ff
	ff 54 03 00 00	 cmp	 DWORD PTR _used$[ebp], 852 ; 00000354H
  0030b	77 12		 ja	 SHORT $LN26@inflate_ta
$LN25@inflate_ta:
  0030d	83 7d 08 02	 cmp	 DWORD PTR _type$[ebp], 2
  00311	75 16		 jne	 SHORT $LN24@inflate_ta
  00313	81 bd 78 ff ff
	ff 50 02 00 00	 cmp	 DWORD PTR _used$[ebp], 592 ; 00000250H
  0031d	76 0a		 jbe	 SHORT $LN24@inflate_ta
$LN26@inflate_ta:

; 211  :         return 1;

  0031f	b8 01 00 00 00	 mov	 eax, 1
  00324	e9 ae 02 00 00	 jmp	 $LN63@inflate_ta
$LN24@inflate_ta:

; 212  : 
; 213  :     /* process all codes and make table entries */
; 214  :     for (;;) {
; 215  :         /* create table entry */
; 216  :         here.bits = (unsigned char)(len - drop);

  00329	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  0032c	2b 4d c4	 sub	 ecx, DWORD PTR _drop$[ebp]
  0032f	88 4d dd	 mov	 BYTE PTR _here$[ebp+1], cl

; 217  :         if (work[sym] + 1U < match) {

  00332	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  00335	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  00338	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0033c	83 c1 01	 add	 ecx, 1
  0033f	3b 4d 84	 cmp	 ecx, DWORD PTR _match$[ebp]
  00342	73 14		 jae	 SHORT $LN22@inflate_ta

; 218  :             here.op = (unsigned char)0;

  00344	c6 45 dc 00	 mov	 BYTE PTR _here$[ebp], 0

; 219  :             here.val = work[sym];

  00348	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  0034b	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  0034e	66 8b 0c 50	 mov	 cx, WORD PTR [eax+edx*2]
  00352	66 89 4d de	 mov	 WORD PTR _here$[ebp+2], cx
  00356	eb 49		 jmp	 SHORT $LN21@inflate_ta
$LN22@inflate_ta:

; 220  :         }
; 221  :         else if (work[sym] >= match) {

  00358	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  0035b	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  0035e	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00362	3b 4d 84	 cmp	 ecx, DWORD PTR _match$[ebp]
  00365	72 30		 jb	 SHORT $LN20@inflate_ta

; 222  :             here.op = (unsigned char)(extra[work[sym] - match]);

  00367	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  0036a	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  0036d	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00371	2b 4d 84	 sub	 ecx, DWORD PTR _match$[ebp]
  00374	8b 55 d8	 mov	 edx, DWORD PTR _extra$[ebp]
  00377	8a 04 4a	 mov	 al, BYTE PTR [edx+ecx*2]
  0037a	88 45 dc	 mov	 BYTE PTR _here$[ebp], al

; 223  :             here.val = base[work[sym] - match];

  0037d	8b 4d 80	 mov	 ecx, DWORD PTR _sym$[ebp]
  00380	8b 55 1c	 mov	 edx, DWORD PTR _work$[ebp]
  00383	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00387	2b 45 84	 sub	 eax, DWORD PTR _match$[ebp]
  0038a	8b 4d d4	 mov	 ecx, DWORD PTR _base$[ebp]
  0038d	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00391	66 89 55 de	 mov	 WORD PTR _here$[ebp+2], dx

; 224  :         }
; 225  :         else {

  00395	eb 0a		 jmp	 SHORT $LN21@inflate_ta
$LN20@inflate_ta:

; 226  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  00397	c6 45 dc 60	 mov	 BYTE PTR _here$[ebp], 96 ; 00000060H

; 227  :             here.val = 0;

  0039b	33 c0		 xor	 eax, eax
  0039d	66 89 45 de	 mov	 WORD PTR _here$[ebp+2], ax
$LN21@inflate_ta:

; 228  :         }
; 229  : 
; 230  :         /* replicate for those indices with low len bits equal to huff */
; 231  :         incr = 1U << (len - drop);

  003a1	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  003a4	2b 4d c4	 sub	 ecx, DWORD PTR _drop$[ebp]
  003a7	ba 01 00 00 00	 mov	 edx, 1
  003ac	d3 e2		 shl	 edx, cl
  003ae	89 55 ac	 mov	 DWORD PTR _incr$[ebp], edx

; 232  :         fill = 1U << curr;

  003b1	b8 01 00 00 00	 mov	 eax, 1
  003b6	8b 4d c0	 mov	 ecx, DWORD PTR _curr$[ebp]
  003b9	d3 e0		 shl	 eax, cl
  003bb	89 45 88	 mov	 DWORD PTR _fill$[ebp], eax

; 233  :         min = fill;                 /* save offset to next table */

  003be	8b 4d 88	 mov	 ecx, DWORD PTR _fill$[ebp]
  003c1	89 4d cc	 mov	 DWORD PTR _min$[ebp], ecx
$LN18@inflate_ta:

; 234  :         do {
; 235  :             fill -= incr;

  003c4	8b 55 88	 mov	 edx, DWORD PTR _fill$[ebp]
  003c7	2b 55 ac	 sub	 edx, DWORD PTR _incr$[ebp]
  003ca	89 55 88	 mov	 DWORD PTR _fill$[ebp], edx

; 236  :             next[(huff >> drop) + fill] = here;

  003cd	8b 45 d0	 mov	 eax, DWORD PTR _huff$[ebp]
  003d0	8b 4d c4	 mov	 ecx, DWORD PTR _drop$[ebp]
  003d3	d3 e8		 shr	 eax, cl
  003d5	03 45 88	 add	 eax, DWORD PTR _fill$[ebp]
  003d8	8b 4d b8	 mov	 ecx, DWORD PTR _next$[ebp]
  003db	8b 55 dc	 mov	 edx, DWORD PTR _here$[ebp]
  003de	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 237  :         } while (fill != 0);

  003e1	83 7d 88 00	 cmp	 DWORD PTR _fill$[ebp], 0
  003e5	75 dd		 jne	 SHORT $LN18@inflate_ta

; 238  : 
; 239  :         /* backwards increment the len-bit code huff */
; 240  :         incr = 1U << (len - 1);

  003e7	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  003ea	83 e9 01	 sub	 ecx, 1
  003ed	b8 01 00 00 00	 mov	 eax, 1
  003f2	d3 e0		 shl	 eax, cl
  003f4	89 45 ac	 mov	 DWORD PTR _incr$[ebp], eax
$LN15@inflate_ta:

; 241  :         while (huff & incr)

  003f7	8b 4d d0	 mov	 ecx, DWORD PTR _huff$[ebp]
  003fa	23 4d ac	 and	 ecx, DWORD PTR _incr$[ebp]
  003fd	74 0a		 je	 SHORT $LN14@inflate_ta

; 242  :             incr >>= 1;

  003ff	8b 55 ac	 mov	 edx, DWORD PTR _incr$[ebp]
  00402	d1 ea		 shr	 edx, 1
  00404	89 55 ac	 mov	 DWORD PTR _incr$[ebp], edx
  00407	eb ee		 jmp	 SHORT $LN15@inflate_ta
$LN14@inflate_ta:

; 243  :         if (incr != 0) {

  00409	83 7d ac 00	 cmp	 DWORD PTR _incr$[ebp], 0
  0040d	74 17		 je	 SHORT $LN13@inflate_ta

; 244  :             huff &= incr - 1;

  0040f	8b 45 ac	 mov	 eax, DWORD PTR _incr$[ebp]
  00412	83 e8 01	 sub	 eax, 1
  00415	23 45 d0	 and	 eax, DWORD PTR _huff$[ebp]
  00418	89 45 d0	 mov	 DWORD PTR _huff$[ebp], eax

; 245  :             huff += incr;

  0041b	8b 4d d0	 mov	 ecx, DWORD PTR _huff$[ebp]
  0041e	03 4d ac	 add	 ecx, DWORD PTR _incr$[ebp]
  00421	89 4d d0	 mov	 DWORD PTR _huff$[ebp], ecx

; 246  :         }
; 247  :         else

  00424	eb 07		 jmp	 SHORT $LN12@inflate_ta
$LN13@inflate_ta:

; 248  :             huff = 0;

  00426	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _huff$[ebp], 0
$LN12@inflate_ta:

; 249  : 
; 250  :         /* go to next symbol, update count, len */
; 251  :         sym++;

  0042d	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  00430	83 c2 01	 add	 edx, 1
  00433	89 55 80	 mov	 DWORD PTR _sym$[ebp], edx

; 252  :         if (--(count[len]) == 0) {

  00436	8b 45 b0	 mov	 eax, DWORD PTR _len$[ebp]
  00439	66 8b 4c 45 e0	 mov	 cx, WORD PTR _count$[ebp+eax*2]
  0043e	66 83 e9 01	 sub	 cx, 1
  00442	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  00445	66 89 4c 55 e0	 mov	 WORD PTR _count$[ebp+edx*2], cx
  0044a	8b 45 b0	 mov	 eax, DWORD PTR _len$[ebp]
  0044d	0f b7 4c 45 e0	 movzx	 ecx, WORD PTR _count$[ebp+eax*2]
  00452	85 c9		 test	 ecx, ecx
  00454	75 24		 jne	 SHORT $LN11@inflate_ta

; 253  :             if (len == max) break;

  00456	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  00459	3b 95 74 ff ff
	ff		 cmp	 edx, DWORD PTR _max$[ebp]
  0045f	75 05		 jne	 SHORT $LN10@inflate_ta
  00461	e9 2f 01 00 00	 jmp	 $LN23@inflate_ta
$LN10@inflate_ta:

; 254  :             len = lens[work[sym]];

  00466	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  00469	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  0046c	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00470	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00473	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00477	89 4d b0	 mov	 DWORD PTR _len$[ebp], ecx
$LN11@inflate_ta:

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  0047a	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  0047d	3b 55 bc	 cmp	 edx, DWORD PTR _root$[ebp]
  00480	0f 86 0a 01 00
	00		 jbe	 $LN9@inflate_ta
  00486	8b 45 d0	 mov	 eax, DWORD PTR _huff$[ebp]
  00489	23 45 c8	 and	 eax, DWORD PTR _mask$[ebp]
  0048c	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _low$[ebp]
  00492	0f 84 f8 00 00
	00		 je	 $LN9@inflate_ta

; 259  :             /* if first time, transition to sub-tables */
; 260  :             if (drop == 0)

  00498	83 7d c4 00	 cmp	 DWORD PTR _drop$[ebp], 0
  0049c	75 06		 jne	 SHORT $LN8@inflate_ta

; 261  :                 drop = root;

  0049e	8b 4d bc	 mov	 ecx, DWORD PTR _root$[ebp]
  004a1	89 4d c4	 mov	 DWORD PTR _drop$[ebp], ecx
$LN8@inflate_ta:

; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  004a4	8b 55 cc	 mov	 edx, DWORD PTR _min$[ebp]
  004a7	8b 45 b8	 mov	 eax, DWORD PTR _next$[ebp]
  004aa	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  004ad	89 4d b8	 mov	 DWORD PTR _next$[ebp], ecx

; 265  : 
; 266  :             /* determine length of next table */
; 267  :             curr = len - drop;

  004b0	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  004b3	2b 55 c4	 sub	 edx, DWORD PTR _drop$[ebp]
  004b6	89 55 c0	 mov	 DWORD PTR _curr$[ebp], edx

; 268  :             left = (int)(1 << curr);

  004b9	b8 01 00 00 00	 mov	 eax, 1
  004be	8b 4d c0	 mov	 ecx, DWORD PTR _curr$[ebp]
  004c1	d3 e0		 shl	 eax, cl
  004c3	89 45 b4	 mov	 DWORD PTR _left$[ebp], eax
$LN7@inflate_ta:

; 269  :             while (curr + drop < max) {

  004c6	8b 4d c0	 mov	 ecx, DWORD PTR _curr$[ebp]
  004c9	03 4d c4	 add	 ecx, DWORD PTR _drop$[ebp]
  004cc	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _max$[ebp]
  004d2	73 2e		 jae	 SHORT $LN6@inflate_ta

; 270  :                 left -= count[curr + drop];

  004d4	8b 55 c0	 mov	 edx, DWORD PTR _curr$[ebp]
  004d7	03 55 c4	 add	 edx, DWORD PTR _drop$[ebp]
  004da	0f b7 44 55 e0	 movzx	 eax, WORD PTR _count$[ebp+edx*2]
  004df	8b 4d b4	 mov	 ecx, DWORD PTR _left$[ebp]
  004e2	2b c8		 sub	 ecx, eax
  004e4	89 4d b4	 mov	 DWORD PTR _left$[ebp], ecx

; 271  :                 if (left <= 0) break;

  004e7	83 7d b4 00	 cmp	 DWORD PTR _left$[ebp], 0
  004eb	7f 02		 jg	 SHORT $LN5@inflate_ta
  004ed	eb 13		 jmp	 SHORT $LN6@inflate_ta
$LN5@inflate_ta:

; 272  :                 curr++;

  004ef	8b 55 c0	 mov	 edx, DWORD PTR _curr$[ebp]
  004f2	83 c2 01	 add	 edx, 1
  004f5	89 55 c0	 mov	 DWORD PTR _curr$[ebp], edx

; 273  :                 left <<= 1;

  004f8	8b 45 b4	 mov	 eax, DWORD PTR _left$[ebp]
  004fb	d1 e0		 shl	 eax, 1
  004fd	89 45 b4	 mov	 DWORD PTR _left$[ebp], eax

; 274  :             }

  00500	eb c4		 jmp	 SHORT $LN7@inflate_ta
$LN6@inflate_ta:

; 275  : 
; 276  :             /* check for enough space */
; 277  :             used += 1U << curr;

  00502	ba 01 00 00 00	 mov	 edx, 1
  00507	8b 4d c0	 mov	 ecx, DWORD PTR _curr$[ebp]
  0050a	d3 e2		 shl	 edx, cl
  0050c	03 95 78 ff ff
	ff		 add	 edx, DWORD PTR _used$[ebp]
  00512	89 95 78 ff ff
	ff		 mov	 DWORD PTR _used$[ebp], edx

; 278  :             if ((type == LENS && used > ENOUGH_LENS) ||
; 279  :                 (type == DISTS && used > ENOUGH_DISTS))

  00518	83 7d 08 01	 cmp	 DWORD PTR _type$[ebp], 1
  0051c	75 0c		 jne	 SHORT $LN2@inflate_ta
  0051e	81 bd 78 ff ff
	ff 54 03 00 00	 cmp	 DWORD PTR _used$[ebp], 852 ; 00000354H
  00528	77 12		 ja	 SHORT $LN3@inflate_ta
$LN2@inflate_ta:
  0052a	83 7d 08 02	 cmp	 DWORD PTR _type$[ebp], 2
  0052e	75 16		 jne	 SHORT $LN4@inflate_ta
  00530	81 bd 78 ff ff
	ff 50 02 00 00	 cmp	 DWORD PTR _used$[ebp], 592 ; 00000250H
  0053a	76 0a		 jbe	 SHORT $LN4@inflate_ta
$LN3@inflate_ta:

; 280  :                 return 1;

  0053c	b8 01 00 00 00	 mov	 eax, 1
  00541	e9 91 00 00 00	 jmp	 $LN63@inflate_ta
$LN4@inflate_ta:

; 281  : 
; 282  :             /* point entry in root table to sub-table */
; 283  :             low = huff & mask;

  00546	8b 45 d0	 mov	 eax, DWORD PTR _huff$[ebp]
  00549	23 45 c8	 and	 eax, DWORD PTR _mask$[ebp]
  0054c	89 85 7c ff ff
	ff		 mov	 DWORD PTR _low$[ebp], eax

; 284  :             (*table)[low].op = (unsigned char)curr;

  00552	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  00555	8b 11		 mov	 edx, DWORD PTR [ecx]
  00557	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _low$[ebp]
  0055d	8a 4d c0	 mov	 cl, BYTE PTR _curr$[ebp]
  00560	88 0c 82	 mov	 BYTE PTR [edx+eax*4], cl

; 285  :             (*table)[low].bits = (unsigned char)root;

  00563	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00566	8b 02		 mov	 eax, DWORD PTR [edx]
  00568	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _low$[ebp]
  0056e	8a 55 bc	 mov	 dl, BYTE PTR _root$[ebp]
  00571	88 54 88 01	 mov	 BYTE PTR [eax+ecx*4+1], dl

; 286  :             (*table)[low].val = (unsigned short)(next - *table);

  00575	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  00578	8b 4d b8	 mov	 ecx, DWORD PTR _next$[ebp]
  0057b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0057d	c1 f9 02	 sar	 ecx, 2
  00580	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00583	8b 02		 mov	 eax, DWORD PTR [edx]
  00585	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _low$[ebp]
  0058b	66 89 4c 90 02	 mov	 WORD PTR [eax+edx*4+2], cx
$LN9@inflate_ta:

; 287  :         }
; 288  :     }

  00590	e9 94 fd ff ff	 jmp	 $LN24@inflate_ta
$LN23@inflate_ta:

; 289  : 
; 290  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 291  :        at most one remaining entry, since if the code is incomplete, the
; 292  :        maximum code length that was allowed to get this far is one bit) */
; 293  :     if (huff != 0) {

  00595	83 7d d0 00	 cmp	 DWORD PTR _huff$[ebp], 0
  00599	74 1f		 je	 SHORT $LN1@inflate_ta

; 294  :         here.op = (unsigned char)64;            /* invalid code marker */

  0059b	c6 45 dc 40	 mov	 BYTE PTR _here$[ebp], 64 ; 00000040H

; 295  :         here.bits = (unsigned char)(len - drop);

  0059f	8b 45 b0	 mov	 eax, DWORD PTR _len$[ebp]
  005a2	2b 45 c4	 sub	 eax, DWORD PTR _drop$[ebp]
  005a5	88 45 dd	 mov	 BYTE PTR _here$[ebp+1], al

; 296  :         here.val = (unsigned short)0;

  005a8	33 c9		 xor	 ecx, ecx
  005aa	66 89 4d de	 mov	 WORD PTR _here$[ebp+2], cx

; 297  :         next[huff] = here;

  005ae	8b 55 d0	 mov	 edx, DWORD PTR _huff$[ebp]
  005b1	8b 45 b8	 mov	 eax, DWORD PTR _next$[ebp]
  005b4	8b 4d dc	 mov	 ecx, DWORD PTR _here$[ebp]
  005b7	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
$LN1@inflate_ta:

; 298  :     }
; 299  : 
; 300  :     /* set return parameters */
; 301  :     *table += used;

  005ba	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  005bd	8b 02		 mov	 eax, DWORD PTR [edx]
  005bf	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _used$[ebp]
  005c5	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  005c8	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  005cb	89 10		 mov	 DWORD PTR [eax], edx

; 302  :     *bits = root;

  005cd	8b 4d 18	 mov	 ecx, DWORD PTR _bits$[ebp]
  005d0	8b 55 bc	 mov	 edx, DWORD PTR _root$[ebp]
  005d3	89 11		 mov	 DWORD PTR [ecx], edx

; 303  :     return 0;

  005d5	33 c0		 xor	 eax, eax
$LN63@inflate_ta:

; 304  : }

  005d7	8b e5		 mov	 esp, ebp
  005d9	5d		 pop	 ebp
  005da	c3		 ret	 0
_inflate_table ENDP
END
