; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\uncompr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_uncompress2@16
; Function compile flags: /Odtp
; File c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\uncompr.c
;	COMDAT _uncompress2@16
_TEXT	SEGMENT
tv93 = -96						; size = 4
tv94 = -92						; size = 4
tv95 = -88						; size = 4
tv76 = -84						; size = 4
tv72 = -80						; size = 4
_max$ = -76						; size = 4
_err$ = -72						; size = 4
_buf$ = -65						; size = 1
_len$ = -64						; size = 4
_left$ = -60						; size = 4
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress2@16 PROC					; COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H

; 33   :     z_stream stream;
; 34   :     int err;
; 35   :     const uInt max = (uInt)-1;

  00006	c7 45 b4 ff ff
	ff ff		 mov	 DWORD PTR _max$[ebp], -1

; 36   :     uLong len, left;
; 37   :     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
; 38   : 
; 39   :     len = *sourceLen;

  0000d	8b 45 14	 mov	 eax, DWORD PTR _sourceLen$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	89 4d c0	 mov	 DWORD PTR _len$[ebp], ecx

; 40   :     if (*destLen) {

  00015	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  00018	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0001b	74 13		 je	 SHORT $LN11@uncompress

; 41   :         left = *destLen;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _destLen$[ebp]
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	89 4d c4	 mov	 DWORD PTR _left$[ebp], ecx

; 42   :         *destLen = 0;

  00025	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  00028	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 43   :     }
; 44   :     else {

  0002e	eb 0d		 jmp	 SHORT $LN10@uncompress
$LN11@uncompress:

; 45   :         left = 1;

  00030	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _left$[ebp], 1

; 46   :         dest = buf;

  00037	8d 45 bf	 lea	 eax, DWORD PTR _buf$[ebp]
  0003a	89 45 08	 mov	 DWORD PTR _dest$[ebp], eax
$LN10@uncompress:

; 47   :     }
; 48   : 
; 49   :     stream.next_in = (z_const Bytef *)source;

  0003d	8b 4d 10	 mov	 ecx, DWORD PTR _source$[ebp]
  00040	89 4d c8	 mov	 DWORD PTR _stream$[ebp], ecx

; 50   :     stream.avail_in = 0;

  00043	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+4], 0

; 51   :     stream.zalloc = (alloc_func)0;

  0004a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+32], 0

; 52   :     stream.zfree = (free_func)0;

  00051	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+36], 0

; 53   :     stream.opaque = (voidpf)0;

  00058	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+40], 0

; 54   : 
; 55   :     err = inflateInit(&stream);

  0005f	6a 38		 push	 56			; 00000038H
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411?$AA@
  00066	8d 55 c8	 lea	 edx, DWORD PTR _stream$[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 _inflateInit_@12
  0006f	89 45 b8	 mov	 DWORD PTR _err$[ebp], eax

; 56   :     if (err != Z_OK) return err;

  00072	83 7d b8 00	 cmp	 DWORD PTR _err$[ebp], 0
  00076	74 08		 je	 SHORT $LN9@uncompress
  00078	8b 45 b8	 mov	 eax, DWORD PTR _err$[ebp]
  0007b	e9 03 01 00 00	 jmp	 $LN12@uncompress
$LN9@uncompress:

; 57   : 
; 58   :     stream.next_out = dest;

  00080	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00083	89 45 d4	 mov	 DWORD PTR _stream$[ebp+12], eax

; 59   :     stream.avail_out = 0;

  00086	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+16], 0
$LN8@uncompress:

; 60   : 
; 61   :     do {
; 62   :         if (stream.avail_out == 0) {

  0008d	83 7d d8 00	 cmp	 DWORD PTR _stream$[ebp+16], 0
  00091	75 25		 jne	 SHORT $LN5@uncompress

; 63   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00093	8b 4d c4	 mov	 ecx, DWORD PTR _left$[ebp]
  00096	3b 4d b4	 cmp	 ecx, DWORD PTR _max$[ebp]
  00099	76 08		 jbe	 SHORT $LN14@uncompress
  0009b	8b 55 b4	 mov	 edx, DWORD PTR _max$[ebp]
  0009e	89 55 b0	 mov	 DWORD PTR tv72[ebp], edx
  000a1	eb 06		 jmp	 SHORT $LN15@uncompress
$LN14@uncompress:
  000a3	8b 45 c4	 mov	 eax, DWORD PTR _left$[ebp]
  000a6	89 45 b0	 mov	 DWORD PTR tv72[ebp], eax
$LN15@uncompress:
  000a9	8b 4d b0	 mov	 ecx, DWORD PTR tv72[ebp]
  000ac	89 4d d8	 mov	 DWORD PTR _stream$[ebp+16], ecx

; 64   :             left -= stream.avail_out;

  000af	8b 55 c4	 mov	 edx, DWORD PTR _left$[ebp]
  000b2	2b 55 d8	 sub	 edx, DWORD PTR _stream$[ebp+16]
  000b5	89 55 c4	 mov	 DWORD PTR _left$[ebp], edx
$LN5@uncompress:

; 65   :         }
; 66   :         if (stream.avail_in == 0) {

  000b8	83 7d cc 00	 cmp	 DWORD PTR _stream$[ebp+4], 0
  000bc	75 25		 jne	 SHORT $LN4@uncompress

; 67   :             stream.avail_in = len > (uLong)max ? max : (uInt)len;

  000be	8b 45 c0	 mov	 eax, DWORD PTR _len$[ebp]
  000c1	3b 45 b4	 cmp	 eax, DWORD PTR _max$[ebp]
  000c4	76 08		 jbe	 SHORT $LN16@uncompress
  000c6	8b 4d b4	 mov	 ecx, DWORD PTR _max$[ebp]
  000c9	89 4d ac	 mov	 DWORD PTR tv76[ebp], ecx
  000cc	eb 06		 jmp	 SHORT $LN17@uncompress
$LN16@uncompress:
  000ce	8b 55 c0	 mov	 edx, DWORD PTR _len$[ebp]
  000d1	89 55 ac	 mov	 DWORD PTR tv76[ebp], edx
$LN17@uncompress:
  000d4	8b 45 ac	 mov	 eax, DWORD PTR tv76[ebp]
  000d7	89 45 cc	 mov	 DWORD PTR _stream$[ebp+4], eax

; 68   :             len -= stream.avail_in;

  000da	8b 4d c0	 mov	 ecx, DWORD PTR _len$[ebp]
  000dd	2b 4d cc	 sub	 ecx, DWORD PTR _stream$[ebp+4]
  000e0	89 4d c0	 mov	 DWORD PTR _len$[ebp], ecx
$LN4@uncompress:

; 69   :         }
; 70   :         err = inflate(&stream, Z_NO_FLUSH);

  000e3	6a 00		 push	 0
  000e5	8d 55 c8	 lea	 edx, DWORD PTR _stream$[ebp]
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 _inflate@8
  000ee	89 45 b8	 mov	 DWORD PTR _err$[ebp], eax

; 71   :     } while (err == Z_OK);

  000f1	83 7d b8 00	 cmp	 DWORD PTR _err$[ebp], 0
  000f5	74 96		 je	 SHORT $LN8@uncompress

; 72   : 
; 73   :     *sourceLen -= len + stream.avail_in;

  000f7	8b 45 c0	 mov	 eax, DWORD PTR _len$[ebp]
  000fa	03 45 cc	 add	 eax, DWORD PTR _stream$[ebp+4]
  000fd	8b 4d 14	 mov	 ecx, DWORD PTR _sourceLen$[ebp]
  00100	8b 11		 mov	 edx, DWORD PTR [ecx]
  00102	2b d0		 sub	 edx, eax
  00104	8b 45 14	 mov	 eax, DWORD PTR _sourceLen$[ebp]
  00107	89 10		 mov	 DWORD PTR [eax], edx

; 74   :     if (dest != buf)

  00109	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  0010c	8d 55 bf	 lea	 edx, DWORD PTR _buf$[ebp]
  0010f	3b ca		 cmp	 ecx, edx
  00111	74 0a		 je	 SHORT $LN3@uncompress

; 75   :         *destLen = stream.total_out;

  00113	8b 45 0c	 mov	 eax, DWORD PTR _destLen$[ebp]
  00116	8b 4d dc	 mov	 ecx, DWORD PTR _stream$[ebp+20]
  00119	89 08		 mov	 DWORD PTR [eax], ecx
  0011b	eb 13		 jmp	 SHORT $LN2@uncompress
$LN3@uncompress:

; 76   :     else if (stream.total_out && err == Z_BUF_ERROR)

  0011d	83 7d dc 00	 cmp	 DWORD PTR _stream$[ebp+20], 0
  00121	74 0d		 je	 SHORT $LN2@uncompress
  00123	83 7d b8 fb	 cmp	 DWORD PTR _err$[ebp], -5 ; fffffffbH
  00127	75 07		 jne	 SHORT $LN2@uncompress

; 77   :         left = 1;

  00129	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _left$[ebp], 1
$LN2@uncompress:

; 78   : 
; 79   :     inflateEnd(&stream);

  00130	8d 55 c8	 lea	 edx, DWORD PTR _stream$[ebp]
  00133	52		 push	 edx
  00134	e8 00 00 00 00	 call	 _inflateEnd@4

; 80   :     return err == Z_STREAM_END ? Z_OK :
; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;

  00139	83 7d b8 01	 cmp	 DWORD PTR _err$[ebp], 1
  0013d	75 09		 jne	 SHORT $LN22@uncompress
  0013f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  00146	eb 38		 jmp	 SHORT $LN23@uncompress
$LN22@uncompress:
  00148	83 7d b8 02	 cmp	 DWORD PTR _err$[ebp], 2
  0014c	75 09		 jne	 SHORT $LN20@uncompress
  0014e	c7 45 a4 fd ff
	ff ff		 mov	 DWORD PTR tv94[ebp], -3	; fffffffdH
  00155	eb 23		 jmp	 SHORT $LN21@uncompress
$LN20@uncompress:
  00157	83 7d b8 fb	 cmp	 DWORD PTR _err$[ebp], -5 ; fffffffbH
  0015b	75 11		 jne	 SHORT $LN18@uncompress
  0015d	8b 45 c4	 mov	 eax, DWORD PTR _left$[ebp]
  00160	03 45 d8	 add	 eax, DWORD PTR _stream$[ebp+16]
  00163	74 09		 je	 SHORT $LN18@uncompress
  00165	c7 45 a0 fd ff
	ff ff		 mov	 DWORD PTR tv93[ebp], -3	; fffffffdH
  0016c	eb 06		 jmp	 SHORT $LN19@uncompress
$LN18@uncompress:
  0016e	8b 4d b8	 mov	 ecx, DWORD PTR _err$[ebp]
  00171	89 4d a0	 mov	 DWORD PTR tv93[ebp], ecx
$LN19@uncompress:
  00174	8b 55 a0	 mov	 edx, DWORD PTR tv93[ebp]
  00177	89 55 a4	 mov	 DWORD PTR tv94[ebp], edx
$LN21@uncompress:
  0017a	8b 45 a4	 mov	 eax, DWORD PTR tv94[ebp]
  0017d	89 45 a8	 mov	 DWORD PTR tv95[ebp], eax
$LN23@uncompress:
  00180	8b 45 a8	 mov	 eax, DWORD PTR tv95[ebp]
$LN12@uncompress:

; 84   : }

  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c2 10 00	 ret	 16			; 00000010H
_uncompress2@16 ENDP
PUBLIC	_uncompress@16
; Function compile flags: /Odtp
;	COMDAT _uncompress@16
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress@16 PROC					; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   :     return uncompress2(dest, destLen, source, &sourceLen);

  00003	8d 45 14	 lea	 eax, DWORD PTR _sourceLen$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR _source$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _uncompress2@16

; 93   : }

  00018	5d		 pop	 ebp
  00019	c2 10 00	 ret	 16			; 00000010H
_uncompress@16 ENDP
END
