; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
; Function compile flags: /Odtp
; File c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_got$ = -8						; size = 4
_next$ = -4						; size = 4
_have$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_syncsearch PROC					; COMDAT

; 1381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00006	8b 45 08	 mov	 eax, DWORD PTR _have$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f8	 mov	 DWORD PTR _got$[ebp], ecx

; 1386 :     next = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
$LN6@syncsearch:

; 1387 :     while (next < len && got < 4) {

  00015	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  00018	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  0001b	73 5c		 jae	 SHORT $LN5@syncsearch
  0001d	83 7d f8 04	 cmp	 DWORD PTR _got$[ebp], 4
  00021	73 56		 jae	 SHORT $LN5@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00023	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00026	03 45 fc	 add	 eax, DWORD PTR _next$[ebp]
  00029	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0002c	83 7d f8 02	 cmp	 DWORD PTR _got$[ebp], 2
  00030	1b d2		 sbb	 edx, edx
  00032	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00038	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003e	3b ca		 cmp	 ecx, edx
  00040	75 0b		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _got$[ebp]
  00045	83 c0 01	 add	 eax, 1
  00048	89 45 f8	 mov	 DWORD PTR _got$[ebp], eax
  0004b	eb 21		 jmp	 SHORT $LN3@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00050	03 4d fc	 add	 ecx, DWORD PTR _next$[ebp]
  00053	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00056	85 d2		 test	 edx, edx
  00058	74 09		 je	 SHORT $LN2@syncsearch

; 1391 :             got = 0;

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _got$[ebp], 0

; 1392 :         else

  00061	eb 0b		 jmp	 SHORT $LN3@syncsearch
$LN2@syncsearch:

; 1393 :             got = 4 - got;

  00063	b8 04 00 00 00	 mov	 eax, 4
  00068	2b 45 f8	 sub	 eax, DWORD PTR _got$[ebp]
  0006b	89 45 f8	 mov	 DWORD PTR _got$[ebp], eax
$LN3@syncsearch:

; 1394 :         next++;

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  00071	83 c1 01	 add	 ecx, 1
  00074	89 4d fc	 mov	 DWORD PTR _next$[ebp], ecx

; 1395 :     }

  00077	eb 9c		 jmp	 SHORT $LN6@syncsearch
$LN5@syncsearch:

; 1396 :     *have = got;

  00079	8b 55 08	 mov	 edx, DWORD PTR _have$[ebp]
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _got$[ebp]
  0007f	89 02		 mov	 DWORD PTR [edx], eax

; 1397 :     return next;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]

; 1398 : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_syncsearch ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _updatewindow
_TEXT	SEGMENT
_state$ = -8						; size = 4
_dist$ = -4						; size = 4
_strm$ = 8						; size = 4
_end$ = 12						; size = 4
_copy$ = 16						; size = 4
_updatewindow PROC					; COMDAT

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000c	89 4d f8	 mov	 DWORD PTR _state$[ebp], ecx

; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  0000f	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00012	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00016	75 3b		 jne	 SHORT $LN10@updatewind

; 408  :         state->window = (unsigned char FAR *)
; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));

  00018	6a 01		 push	 1
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0001d	ba 01 00 00 00	 mov	 edx, 1
  00022	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00025	d3 e2		 shl	 edx, cl
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00032	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00035	ff d0		 call	 eax
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0003d	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 411  :         if (state->window == Z_NULL) return 1;

  00040	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00043	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00047	75 0a		 jne	 SHORT $LN10@updatewind
  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	e9 35 01 00 00	 jmp	 $LN11@updatewind
$LN10@updatewind:

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  00053	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00056	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0005a	75 27		 jne	 SHORT $LN8@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0005f	ba 01 00 00 00	 mov	 edx, 1
  00064	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00067	d3 e2		 shl	 edx, cl
  00069	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0006c	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 417  :         state->wnext = 0;

  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00072	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 418  :         state->whave = 0;

  00079	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0007c	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0
$LN8@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  00083	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00086	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  00089	3b 48 2c	 cmp	 ecx, DWORD PTR [eax+44]
  0008c	72 3b		 jb	 SHORT $LN7@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  0008e	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00091	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00094	50		 push	 eax
  00095	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00098	8b 55 0c	 mov	 edx, DWORD PTR _end$[ebp]
  0009b	2b 51 2c	 sub	 edx, DWORD PTR [ecx+44]
  0009e	52		 push	 edx
  0009f	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a2	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 _memcpy
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 424  :         state->wnext = 0;

  000ae	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000b1	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 425  :         state->whave = state->wsize;

  000b8	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000be	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000c1	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 426  :     }
; 427  :     else {

  000c4	e9 bd 00 00 00	 jmp	 $LN6@updatewind
$LN7@updatewind:

; 428  :         dist = state->wsize - state->wnext;

  000c9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000cf	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  000d2	2b 51 34	 sub	 edx, DWORD PTR [ecx+52]
  000d5	89 55 fc	 mov	 DWORD PTR _dist$[ebp], edx

; 429  :         if (dist > copy) dist = copy;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _dist$[ebp]
  000db	3b 45 10	 cmp	 eax, DWORD PTR _copy$[ebp]
  000de	76 06		 jbe	 SHORT $LN5@updatewind
  000e0	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  000e3	89 4d fc	 mov	 DWORD PTR _dist$[ebp], ecx
$LN5@updatewind:

; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  000e6	8b 55 fc	 mov	 edx, DWORD PTR _dist$[ebp]
  000e9	52		 push	 edx
  000ea	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
  000ed	2b 45 10	 sub	 eax, DWORD PTR _copy$[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000f4	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000f7	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000fa	03 50 34	 add	 edx, DWORD PTR [eax+52]
  000fd	52		 push	 edx
  000fe	e8 00 00 00 00	 call	 _memcpy
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  :         copy -= dist;

  00106	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  00109	2b 4d fc	 sub	 ecx, DWORD PTR _dist$[ebp]
  0010c	89 4d 10	 mov	 DWORD PTR _copy$[ebp], ecx

; 432  :         if (copy) {

  0010f	74 31		 je	 SHORT $LN4@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  00111	8b 55 10	 mov	 edx, DWORD PTR _copy$[ebp]
  00114	52		 push	 edx
  00115	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
  00118	2b 45 10	 sub	 eax, DWORD PTR _copy$[ebp]
  0011b	50		 push	 eax
  0011c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0011f	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 _memcpy
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH

; 434  :             state->wnext = copy;

  0012b	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0012e	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  00131	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 435  :             state->whave = state->wsize;

  00134	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00137	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0013a	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0013d	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 436  :         }
; 437  :         else {

  00140	eb 44		 jmp	 SHORT $LN6@updatewind
$LN4@updatewind:

; 438  :             state->wnext += dist;

  00142	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00145	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00148	03 45 fc	 add	 eax, DWORD PTR _dist$[ebp]
  0014b	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0014e	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  00151	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00154	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00157	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  0015a	3b 48 2c	 cmp	 ecx, DWORD PTR [eax+44]
  0015d	75 0a		 jne	 SHORT $LN2@updatewind
  0015f	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00162	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0
$LN2@updatewind:

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  00169	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0016c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0016f	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00172	3b 51 2c	 cmp	 edx, DWORD PTR [ecx+44]
  00175	73 0f		 jae	 SHORT $LN6@updatewind
  00177	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0017a	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0017d	03 4d fc	 add	 ecx, DWORD PTR _dist$[ebp]
  00180	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00183	89 4a 30	 mov	 DWORD PTR [edx+48], ecx
$LN6@updatewind:

; 441  :         }
; 442  :     }
; 443  :     return 0;

  00186	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 444  : }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
_updatewindow ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 317  :     state->distcode = distfix;

  00017	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001a	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 318  :     state->distbits = 5;

  00021	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00024	c7 40 5c 05 00
	00 00		 mov	 DWORD PTR [eax+92], 5

; 319  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_fixedtables ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateStateCheck PROC					; COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 12		 je	 SHORT $LN3@inflateSta
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00011	74 09		 je	 SHORT $LN3@inflateSta
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00016	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0001a	75 07		 jne	 SHORT $LN4@inflateSta
$LN3@inflateSta:

; 111  :         return 1;

  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	eb 3a		 jmp	 SHORT $LN5@inflateSta
$LN4@inflateSta:

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00023	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00026	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00029	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  0002c	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  00030	74 22		 je	 SHORT $LN1@inflateSta
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	3b 55 08	 cmp	 edx, DWORD PTR _strm$[ebp]
  0003a	75 18		 jne	 SHORT $LN1@inflateSta
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003f	81 78 04 34 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16180 ; 00003f34H
  00046	7c 0c		 jl	 SHORT $LN1@inflateSta
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0004b	81 79 04 53 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16211 ; 00003f53H
  00052	7e 07		 jle	 SHORT $LN2@inflateSta
$LN1@inflateSta:

; 115  :         return 1;

  00054	b8 01 00 00 00	 mov	 eax, 1
  00059	eb 02		 jmp	 SHORT $LN5@inflateSta
$LN2@inflateSta:

; 116  :     return 0;

  0005b	33 c0		 xor	 eax, eax
$LN5@inflateSta:

; 117  : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_inflateStateCheck ENDP
PUBLIC	_inflateCodesUsed@4
; Function compile flags: /Odtp
;	COMDAT _inflateCodesUsed@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateCodesUsed@4 PROC				; COMDAT

; 1556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00004	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 05		 je	 SHORT $LN1@inflateCod
  00014	83 c8 ff	 or	 eax, -1
  00017	eb 1e		 jmp	 SHORT $LN2@inflateCod
$LN1@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0001f	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1560 :     return (unsigned long)(state->next - state->codes);

  00022	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00025	05 34 05 00 00	 add	 eax, 1332		; 00000534H
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0002d	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00030	2b d0		 sub	 edx, eax
  00032	c1 fa 02	 sar	 edx, 2
  00035	8b c2		 mov	 eax, edx
$LN2@inflateCod:

; 1561 : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
_inflateCodesUsed@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateMark@4
; Function compile flags: /Odtp
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv79 = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	83 c4 04	 add	 esp, 4
  00012	85 c0		 test	 eax, eax
  00014	74 07		 je	 SHORT $LN1@inflateMar

; 1547 :         return -(1L << 16);

  00016	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H
  0001b	eb 5c		 jmp	 SHORT $LN2@inflateMar
$LN1@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00020	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00023	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +
; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));

  00026	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00029	81 78 04 43 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16195 ; 00003f43H
  00030	75 0b		 jne	 SHORT $LN6@inflateMar
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00038	89 55 f8	 mov	 DWORD PTR tv79[ebp], edx
  0003b	eb 2d		 jmp	 SHORT $LN7@inflateMar
$LN6@inflateMar:
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00040	81 78 04 4c 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16204 ; 00003f4cH
  00047	75 14		 jne	 SHORT $LN4@inflateMar
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0004f	8b 81 cc 1b 00
	00		 mov	 eax, DWORD PTR [ecx+7116]
  00055	2b 42 44	 sub	 eax, DWORD PTR [edx+68]
  00058	89 45 f4	 mov	 DWORD PTR tv78[ebp], eax
  0005b	eb 07		 jmp	 SHORT $LN5@inflateMar
$LN4@inflateMar:
  0005d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN5@inflateMar:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR tv78[ebp]
  00067	89 4d f8	 mov	 DWORD PTR tv79[ebp], ecx
$LN7@inflateMar:
  0006a	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0006d	8b 82 c8 1b 00
	00		 mov	 eax, DWORD PTR [edx+7112]
  00073	c1 e0 10	 shl	 eax, 16			; 00000010H
  00076	03 45 f8	 add	 eax, DWORD PTR tv79[ebp]
$LN2@inflateMar:

; 1552 : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateValidate@8
; Function compile flags: /Odtp
;	COMDAT _inflateValidate@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate@8 PROC					; COMDAT

; 1529 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 07		 je	 SHORT $LN3@inflateVal
  00014	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00019	eb 31		 jmp	 SHORT $LN4@inflateVal
$LN3@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00021	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1534 :     if (check)

  00024	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  00028	74 11		 je	 SHORT $LN2@inflateVal

; 1535 :         state->wrap |= 4;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00030	83 c9 04	 or	 ecx, 4
  00033	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00036	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1536 :     else

  00039	eb 0f		 jmp	 SHORT $LN1@inflateVal
$LN2@inflateVal:

; 1537 :         state->wrap &= ~4;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00041	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00044	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00047	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$LN1@inflateVal:

; 1538 :     return Z_OK;

  0004a	33 c0		 xor	 eax, eax
$LN4@inflateVal:

; 1539 : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
_inflateValidate@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateUndermine@8
; Function compile flags: /Odtp
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 07		 je	 SHORT $LN1@inflateUnd
  00014	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00019	eb 1b		 jmp	 SHORT $LN2@inflateUnd
$LN1@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00021	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00027	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1522 :     return Z_DATA_ERROR;

  00031	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
$LN2@inflateUnd:

; 1523 : #endif
; 1524 : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateCopy@8
; Function compile flags: /Odtp
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_state$ = -16						; size = 4
_copy$ = -12						; size = 4
_wsize$ = -8						; size = 4
_window$ = -4						; size = 4
_dest$ = 8						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1464 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00006	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	83 c4 04	 add	 esp, 4
  00012	85 c0		 test	 eax, eax
  00014	75 06		 jne	 SHORT $LN6@inflateCop
  00016	83 7d 08 00	 cmp	 DWORD PTR _dest$[ebp], 0
  0001a	75 0a		 jne	 SHORT $LN7@inflateCop
$LN6@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  0001c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00021	e9 8d 01 00 00	 jmp	 $LN8@inflateCop
$LN7@inflateCop:

; 1473 :     state = (struct inflate_state FAR *)source->state;

  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  00029	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0002c	89 55 f0	 mov	 DWORD PTR _state$[ebp], edx

; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)
; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  0002f	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00034	6a 01		 push	 1
  00036	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00039	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0003c	51		 push	 ecx
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00040	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00043	ff d0		 call	 eax
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0004b	83 7d f4 00	 cmp	 DWORD PTR _copy$[ebp], 0
  0004f	75 0a		 jne	 SHORT $LN5@inflateCop
  00051	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00056	e9 58 01 00 00	 jmp	 $LN8@inflateCop
$LN5@inflateCop:

; 1479 :     window = Z_NULL;

  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _window$[ebp], 0

; 1480 :     if (state->window != Z_NULL) {

  00062	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00065	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00069	74 4b		 je	 SHORT $LN4@inflateCop

; 1481 :         window = (unsigned char FAR *)
; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  0006b	6a 01		 push	 1
  0006d	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  00078	d3 e0		 shl	 eax, cl
  0007a	50		 push	 eax
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  0007e	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00081	52		 push	 edx
  00082	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00085	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00088	ff d1		 call	 ecx
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	89 45 fc	 mov	 DWORD PTR _window$[ebp], eax

; 1483 :         if (window == Z_NULL) {

  00090	83 7d fc 00	 cmp	 DWORD PTR _window$[ebp], 0
  00094	75 20		 jne	 SHORT $LN4@inflateCop

; 1484 :             ZFREE(source, copy);

  00096	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  00099	52		 push	 edx
  0009a	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  0009d	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000a0	51		 push	 ecx
  000a1	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  000a4	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000a7	ff d0		 call	 eax
  000a9	83 c4 08	 add	 esp, 8

; 1485 :             return Z_MEM_ERROR;

  000ac	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000b1	e9 fd 00 00 00	 jmp	 $LN8@inflateCop
$LN4@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000b6	6a 38		 push	 56			; 00000038H
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _memcpy
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000c8	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  000cd	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _memcpy
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1492 :     copy->strm = dest;

  000dd	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  000e0	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  000e3	89 02		 mov	 DWORD PTR [edx], eax

; 1493 :     if (state->lencode >= state->codes &&
; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {

  000e5	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000e8	81 c1 34 05 00
	00		 add	 ecx, 1332		; 00000534H
  000ee	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000f1	39 4a 50	 cmp	 DWORD PTR [edx+80], ecx
  000f4	72 58		 jb	 SHORT $LN2@inflateCop
  000f6	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000f9	05 c0 1b 00 00	 add	 eax, 7104		; 00001bc0H
  000fe	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00101	39 41 50	 cmp	 DWORD PTR [ecx+80], eax
  00104	77 48		 ja	 SHORT $LN2@inflateCop

; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  00106	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00109	81 c2 34 05 00
	00		 add	 edx, 1332		; 00000534H
  0010f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00112	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00115	2b ca		 sub	 ecx, edx
  00117	c1 f9 02	 sar	 ecx, 2
  0011a	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  0011d	8d 84 8a 34 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1332]
  00124	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00127	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  0012a	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0012d	81 c2 34 05 00
	00		 add	 edx, 1332		; 00000534H
  00133	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00136	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00139	2b ca		 sub	 ecx, edx
  0013b	c1 f9 02	 sar	 ecx, 2
  0013e	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  00141	8d 84 8a 34 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1332]
  00148	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  0014b	89 41 54	 mov	 DWORD PTR [ecx+84], eax
$LN2@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  0014e	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00151	81 c2 34 05 00
	00		 add	 edx, 1332		; 00000534H
  00157	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0015a	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0015d	2b ca		 sub	 ecx, edx
  0015f	c1 f9 02	 sar	 ecx, 2
  00162	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  00165	8d 84 8a 34 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1332]
  0016c	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  0016f	89 41 70	 mov	 DWORD PTR [ecx+112], eax

; 1499 :     if (window != Z_NULL) {

  00172	83 7d fc 00	 cmp	 DWORD PTR _window$[ebp], 0
  00176	74 27		 je	 SHORT $LN1@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  00178	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0017b	b8 01 00 00 00	 mov	 eax, 1
  00180	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  00183	d3 e0		 shl	 eax, cl
  00185	89 45 f8	 mov	 DWORD PTR _wsize$[ebp], eax

; 1501 :         zmemcpy(window, state->window, wsize);

  00188	8b 4d f8	 mov	 ecx, DWORD PTR _wsize$[ebp]
  0018b	51		 push	 ecx
  0018c	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0018f	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00192	50		 push	 eax
  00193	8b 4d fc	 mov	 ecx, DWORD PTR _window$[ebp]
  00196	51		 push	 ecx
  00197	e8 00 00 00 00	 call	 _memcpy
  0019c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  0019f	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  001a2	8b 45 fc	 mov	 eax, DWORD PTR _window$[ebp]
  001a5	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 1504 :     dest->state = (struct internal_state FAR *)copy;

  001a8	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  001ab	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  001ae	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 1505 :     return Z_OK;

  001b1	33 c0		 xor	 eax, eax
$LN8@inflateCop:

; 1506 : }

  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateSyncPoint@4
; Function compile flags: /Odtp
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
tv72 = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	83 c4 04	 add	 esp, 4
  00012	85 c0		 test	 eax, eax
  00014	74 07		 je	 SHORT $LN1@inflateSyn
  00016	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001b	eb 31		 jmp	 SHORT $LN2@inflateSyn
$LN1@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00020	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00023	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1458 :     return state->mode == STORED && state->bits == 0;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00029	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00030	75 12		 jne	 SHORT $LN4@inflateSyn
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  00039	75 09		 jne	 SHORT $LN4@inflateSyn
  0003b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00042	eb 07		 jmp	 SHORT $LN5@inflateSyn
$LN4@inflateSyn:
  00044	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN5@inflateSyn:
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
$LN2@inflateSyn:

; 1459 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateGetHeader@8
; Function compile flags: /Odtp
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 07		 je	 SHORT $LN2@inflateGet
  00014	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00019	eb 30		 jmp	 SHORT $LN3@inflateGet
$LN2@inflateGet:

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00021	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00027	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002a	83 e1 02	 and	 ecx, 2
  0002d	75 07		 jne	 SHORT $LN1@inflateGet
  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00034	eb 15		 jmp	 SHORT $LN3@inflateGet
$LN1@inflateGet:

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00036	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00039	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0003c	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 1362 :     head->done = 0;

  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _head$[ebp]
  00042	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 1363 :     return Z_OK;

  00049	33 c0		 xor	 eax, eax
$LN3@inflateGet:

; 1364 : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateGetDictionary@12
; Function compile flags: /Odtp
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 07		 je	 SHORT $LN3@inflateGet@2
  00014	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00019	eb 77		 jmp	 SHORT $LN4@inflateGet@2
$LN3@inflateGet@2:

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00021	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  00024	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  0002b	74 52		 je	 SHORT $LN2@inflateGet@2
  0002d	83 7d 0c 00	 cmp	 DWORD PTR _dictionary$[ebp], 0
  00031	74 4c		 je	 SHORT $LN2@inflateGet@2

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,
; 1305 :                 state->whave - state->wnext);

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00036	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00039	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0003c	2b 42 34	 sub	 eax, DWORD PTR [edx+52]
  0003f	50		 push	 eax
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00043	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00046	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00049	03 50 34	 add	 edx, DWORD PTR [eax+52]
  0004c	52		 push	 edx
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _memcpy
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,
; 1307 :                 state->window, state->wnext);

  00059	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005c	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0005f	50		 push	 eax
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00063	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00066	52		 push	 edx
  00067	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  0006d	03 48 30	 add	 ecx, DWORD PTR [eax+48]
  00070	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00073	2b 4a 34	 sub	 ecx, DWORD PTR [edx+52]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@inflateGet@2:

; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  0007f	83 7d 10 00	 cmp	 DWORD PTR _dictLength$[ebp], 0
  00083	74 0b		 je	 SHORT $LN1@inflateGet@2

; 1310 :         *dictLength = state->whave;

  00085	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0008b	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0008e	89 10		 mov	 DWORD PTR [eax], edx
$LN1@inflateGet@2:

; 1311 :     return Z_OK;

  00090	33 c0		 xor	 eax, eax
$LN4@inflateGet@2:

; 1312 : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
PUBLIC	_inflateEnd@4
; Function compile flags: /Odtp
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00004	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 07		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00014	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00019	eb 50		 jmp	 SHORT $LN3@inflateEnd
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00021	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0002b	74 19		 je	 SHORT $LN1@inflateEnd
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00030	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00037	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0003e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00041	ff d0		 call	 eax
  00043	83 c4 08	 add	 esp, 8
$LN1@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00049	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0004c	52		 push	 edx
  0004d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00050	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00057	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0005a	ff d0		 call	 eax
  0005c	83 c4 08	 add	 esp, 8

; 1286 :     strm->state = Z_NULL;

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00062	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  00069	33 c0		 xor	 eax, eax
$LN3@inflateEnd:

; 1289 : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
PUBLIC	_inflatePrime@12
; Function compile flags: /Odtp
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 07		 je	 SHORT $LN4@inflatePri
  00014	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00019	eb 7d		 jmp	 SHORT $LN5@inflatePri
$LN4@inflatePri:

; 255  :     state = (struct inflate_state FAR *)strm->state;

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00021	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 256  :     if (bits < 0) {

  00024	83 7d 0c 00	 cmp	 DWORD PTR _bits$[ebp], 0
  00028	7d 18		 jge	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002d	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 258  :         state->bits = 0;

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00037	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 259  :         return Z_OK;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 56		 jmp	 SHORT $LN5@inflatePri
$LN3@inflatePri:

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00042	83 7d 0c 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00046	7f 0e		 jg	 SHORT $LN1@inflatePri
  00048	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0004b	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0004e	03 45 0c	 add	 eax, DWORD PTR _bits$[ebp]
  00051	83 f8 20	 cmp	 eax, 32			; 00000020H
  00054	76 07		 jbe	 SHORT $LN2@inflatePri
$LN1@inflatePri:
  00056	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005b	eb 3b		 jmp	 SHORT $LN5@inflatePri
$LN2@inflatePri:

; 262  :     value &= (1L << bits) - 1;

  0005d	ba 01 00 00 00	 mov	 edx, 1
  00062	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00065	d3 e2		 shl	 edx, cl
  00067	83 ea 01	 sub	 edx, 1
  0006a	23 55 10	 and	 edx, DWORD PTR _value$[ebp]
  0006d	89 55 10	 mov	 DWORD PTR _value$[ebp], edx

; 263  :     state->hold += (unsigned)value << state->bits;

  00070	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00073	8b 55 10	 mov	 edx, DWORD PTR _value$[ebp]
  00076	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00079	d3 e2		 shl	 edx, cl
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0007e	03 50 3c	 add	 edx, DWORD PTR [eax+60]
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00084	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 264  :     state->bits += (uInt)bits;

  00087	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0008a	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0008d	03 45 0c	 add	 eax, DWORD PTR _bits$[ebp]
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00093	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 265  :     return Z_OK;

  00096	33 c0		 xor	 eax, eax
$LN5@inflatePri:

; 266  : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
PUBLIC	_inflateResetKeep@4
; Function compile flags: /Odtp
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 0a		 je	 SHORT $LN2@inflateRes
  00014	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00019	e9 d1 00 00 00	 jmp	 $LN3@inflateRes
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00021	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00024	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002a	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00034	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0003b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0003e	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 127  :     strm->msg = Z_NULL;

  00045	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00048	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00052	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00056	74 0f		 je	 SHORT $LN1@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0005e	83 e0 01	 and	 eax, 1
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00064	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN1@inflateRes:

; 130  :     state->mode = HEAD;

  00067	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0006a	c7 42 04 34 3f
	00 00		 mov	 DWORD PTR [edx+4], 16180 ; 00003f34H

; 131  :     state->last = 0;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00074	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 132  :     state->havedict = 0;

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0007e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 133  :     state->dmax = 32768U;

  00085	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00088	c7 42 18 00 80
	00 00		 mov	 DWORD PTR [edx+24], 32768 ; 00008000H

; 134  :     state->head = Z_NULL;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00092	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 135  :     state->hold = 0;

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0009c	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 136  :     state->bits = 0;

  000a3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000a6	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 137  :     state->lencode = state->distcode = state->next = state->codes;

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000b0	05 34 05 00 00	 add	 eax, 1332		; 00000534H
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000b8	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  000bb	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000be	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000c1	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  000c4	89 4a 54	 mov	 DWORD PTR [edx+84], ecx
  000c7	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000ca	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000cd	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000d0	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 138  :     state->sane = 1;

  000d3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000d6	c7 82 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+7108], 1

; 139  :     state->back = -1;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000e3	c7 80 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+7112], -1

; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  000ed	33 c0		 xor	 eax, eax
$LN3@inflateRes:

; 142  : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
PUBLIC	_inflateSetDictionary@12
; Function compile flags: /Odtp
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_state$ = -12						; size = 4
_ret$ = -8						; size = 4
_dictid$ = -4						; size = 4
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1318 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	83 c4 04	 add	 esp, 4
  00012	85 c0		 test	 eax, eax
  00014	74 0a		 je	 SHORT $LN5@inflateSet
  00016	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001b	e9 a2 00 00 00	 jmp	 $LN6@inflateSet
$LN5@inflateSet:

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00023	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00026	89 55 f4	 mov	 DWORD PTR _state$[ebp], edx

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  00029	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0002c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00030	74 13		 je	 SHORT $LN4@inflateSet
  00032	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	81 79 04 3e 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16190 ; 00003f3eH
  0003c	74 07		 je	 SHORT $LN4@inflateSet

; 1327 :         return Z_STREAM_ERROR;

  0003e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00043	eb 7d		 jmp	 SHORT $LN6@inflateSet
$LN4@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  00045	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00048	81 7a 04 3e 3f
	00 00		 cmp	 DWORD PTR [edx+4], 16190 ; 00003f3eH
  0004f	75 34		 jne	 SHORT $LN3@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);

  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	e8 00 00 00 00	 call	 _adler32@12
  0005c	89 45 fc	 mov	 DWORD PTR _dictid$[ebp], eax

; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  0005f	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  00062	50		 push	 eax
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 fc	 mov	 edx, DWORD PTR _dictid$[ebp]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 _adler32@12
  00070	89 45 fc	 mov	 DWORD PTR _dictid$[ebp], eax

; 1333 :         if (dictid != state->check)

  00073	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _dictid$[ebp]
  00079	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  0007c	74 07		 je	 SHORT $LN3@inflateSet

; 1334 :             return Z_DATA_ERROR;

  0007e	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00083	eb 3d		 jmp	 SHORT $LN6@inflateSet
$LN3@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  00085	8b 55 10	 mov	 edx, DWORD PTR _dictLength$[ebp]
  00088	52		 push	 edx
  00089	8b 45 0c	 mov	 eax, DWORD PTR _dictionary$[ebp]
  0008c	03 45 10	 add	 eax, DWORD PTR _dictLength$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _updatewindow
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 1340 :     if (ret) {

  0009f	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000a3	74 11		 je	 SHORT $LN1@inflateSet

; 1341 :         state->mode = MEM;

  000a5	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000a8	c7 42 04 52 3f
	00 00		 mov	 DWORD PTR [edx+4], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  000af	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000b4	eb 0c		 jmp	 SHORT $LN6@inflateSet
$LN1@inflateSet:

; 1343 :     }
; 1344 :     state->havedict = 1;

  000b6	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000b9	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  000c0	33 c0		 xor	 eax, eax
$LN6@inflateSet:

; 1347 : }

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
PUBLIC	_inflate@8
; Function compile flags: /Odtp
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv1430 = -92						; size = 4
tv1415 = -88						; size = 4
tv1327 = -84						; size = 4
tv1310 = -80						; size = 4
tv607 = -76						; size = 4
tv382 = -72						; size = 4
tv83 = -68						; size = 4
_state$ = -64						; size = 4
_out$ = -60						; size = 4
_from$ = -56						; size = 4
_copy$ = -52						; size = 4
_hbuf$ = -48						; size = 4
_hold$ = -44						; size = 4
_ret$ = -40						; size = 4
_next$ = -36						; size = 4
_left$ = -32						; size = 4
_bits$ = -28						; size = 4
_len$ = -24						; size = 4
_in$ = -20						; size = 4
_have$ = -16						; size = 4
_here$ = -12						; size = 4
_last$ = -8						; size = 4
_put$ = -4						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||
; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	83 c4 04	 add	 esp, 4
  00012	85 c0		 test	 eax, eax
  00014	75 1a		 jne	 SHORT $LN499@inflate
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00019	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0001d	74 11		 je	 SHORT $LN499@inflate
  0001f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00022	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00025	75 13		 jne	 SHORT $LN500@inflate
  00027	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002e	74 0a		 je	 SHORT $LN500@inflate
$LN499@inflate:

; 647  :         return Z_STREAM_ERROR;

  00030	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00035	e9 49 20 00 00	 jmp	 $LN501@inflate
$LN500@inflate:

; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00040	89 55 c0	 mov	 DWORD PTR _state$[ebp], edx

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00043	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00046	81 78 04 3f 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16191 ; 00003f3fH
  0004d	75 0a		 jne	 SHORT $LN497@inflate
  0004f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00052	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H
$LN497@inflate:

; 651  :     LOAD();

  00059	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0005c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0005f	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00065	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00068	89 55 e0	 mov	 DWORD PTR _left$[ebp], edx
  0006b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00073	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00076	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00079	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0007c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0007f	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00082	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00085	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00088	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0008b	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0008e	33 d2		 xor	 edx, edx
  00090	75 c7		 jne	 SHORT $LN497@inflate

; 652  :     in = have;

  00092	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00095	89 45 ec	 mov	 DWORD PTR _in$[ebp], eax

; 653  :     out = left;

  00098	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  0009b	89 4d c4	 mov	 DWORD PTR _out$[ebp], ecx

; 654  :     ret = Z_OK;

  0009e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN494@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  000a5	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  000a8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ab	89 45 bc	 mov	 DWORD PTR tv83[ebp], eax
  000ae	8b 4d bc	 mov	 ecx, DWORD PTR tv83[ebp]
  000b1	81 e9 34 3f 00
	00		 sub	 ecx, 16180		; 00003f34H
  000b7	89 4d bc	 mov	 DWORD PTR tv83[ebp], ecx
  000ba	83 7d bc 1e	 cmp	 DWORD PTR tv83[ebp], 30	; 0000001eH
  000be	0f 87 e1 1d 00
	00		 ja	 $LN12@inflate
  000c4	8b 55 bc	 mov	 edx, DWORD PTR tv83[ebp]
  000c7	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN513@inflate[edx*4]
$LN490@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  000ce	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  000d1	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000d5	75 0f		 jne	 SHORT $LN485@inflate

; 659  :                 state->mode = TYPEDO;

  000d7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  000da	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H

; 660  :                 break;

  000e1	e9 c9 1d 00 00	 jmp	 $LN491@inflate
$LN485@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  000e6	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  000ea	73 3d		 jae	 SHORT $LN487@inflate
$LN483@inflate:
  000ec	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  000f0	75 05		 jne	 SHORT $LN480@inflate
  000f2	e9 bd 1d 00 00	 jmp	 $inf_leave$77798
$LN480@inflate:
  000f7	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  000fa	83 ea 01	 sub	 edx, 1
  000fd	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00100	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00103	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00106	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00109	d3 e2		 shl	 edx, cl
  0010b	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  0010e	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00111	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00114	83 c0 01	 add	 eax, 1
  00117	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  0011a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0011d	83 c1 08	 add	 ecx, 8
  00120	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00123	33 d2		 xor	 edx, edx
  00125	75 c5		 jne	 SHORT $LN483@inflate
  00127	eb bd		 jmp	 SHORT $LN485@inflate
$LN487@inflate:
  00129	33 c0		 xor	 eax, eax
  0012b	75 b9		 jne	 SHORT $LN485@inflate

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  0012d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00130	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00133	83 e2 02	 and	 edx, 2
  00136	74 79		 je	 SHORT $LN479@inflate
  00138	81 7d d4 1f 8b
	00 00		 cmp	 DWORD PTR _hold$[ebp], 35615 ; 00008b1fH
  0013f	75 70		 jne	 SHORT $LN479@inflate

; 665  :                 if (state->wbits == 0)

  00141	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00144	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00148	75 0a		 jne	 SHORT $LN478@inflate

; 666  :                     state->wbits = 15;

  0014a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0014d	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH
$LN478@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  00154	6a 00		 push	 0
  00156	6a 00		 push	 0
  00158	6a 00		 push	 0
  0015a	e8 00 00 00 00	 call	 _crc32@12
  0015f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00162	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$LN477@inflate:

; 668  :                 CRC2(state->check, hold);

  00165	8a 45 d4	 mov	 al, BYTE PTR _hold$[ebp]
  00168	88 45 d0	 mov	 BYTE PTR _hbuf$[ebp], al
  0016b	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  0016e	c1 e9 08	 shr	 ecx, 8
  00171	88 4d d1	 mov	 BYTE PTR _hbuf$[ebp+1], cl
  00174	6a 02		 push	 2
  00176	8d 55 d0	 lea	 edx, DWORD PTR _hbuf$[ebp]
  00179	52		 push	 edx
  0017a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0017d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00180	51		 push	 ecx
  00181	e8 00 00 00 00	 call	 _crc32@12
  00186	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00189	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  0018c	33 c0		 xor	 eax, eax
  0018e	75 d5		 jne	 SHORT $LN477@inflate
$LN474@inflate:

; 669  :                 INITBITS();

  00190	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00197	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  0019e	33 c9		 xor	 ecx, ecx
  001a0	75 ee		 jne	 SHORT $LN474@inflate

; 670  :                 state->mode = FLAGS;

  001a2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  001a5	c7 42 04 35 3f
	00 00		 mov	 DWORD PTR [edx+4], 16181 ; 00003f35H

; 671  :                 break;

  001ac	e9 fe 1c 00 00	 jmp	 $LN491@inflate
$LN479@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */

  001b1	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  001b4	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 674  :             if (state->head != Z_NULL)

  001bb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  001be	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  001c2	74 0d		 je	 SHORT $LN471@inflate

; 675  :                 state->head->done = -1;

  001c4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  001c7	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  001ca	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN471@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  001d1	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  001d4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001d7	83 e2 01	 and	 edx, 1
  001da	74 20		 je	 SHORT $LN469@inflate
  001dc	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  001df	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001e4	c1 e0 08	 shl	 eax, 8
  001e7	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  001ea	c1 e9 08	 shr	 ecx, 8
  001ed	03 c1		 add	 eax, ecx
  001ef	33 d2		 xor	 edx, edx
  001f1	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  001f6	f7 f1		 div	 ecx
  001f8	85 d2		 test	 edx, edx
  001fa	74 19		 je	 SHORT $LN470@inflate
$LN469@inflate:

; 681  :                 strm->msg = (char *)"incorrect header check";

  001fc	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001ff	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 682  :                 state->mode = BAD;

  00206	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00209	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 683  :                 break;

  00210	e9 9a 1c 00 00	 jmp	 $LN491@inflate
$LN470@inflate:

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  00215	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00218	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0021b	83 f9 08	 cmp	 ecx, 8
  0021e	74 19		 je	 SHORT $LN467@inflate

; 686  :                 strm->msg = (char *)"unknown compression method";

  00220	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00223	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 687  :                 state->mode = BAD;

  0022a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0022d	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 688  :                 break;

  00234	e9 76 1c 00 00	 jmp	 $LN491@inflate
$LN467@inflate:

; 689  :             }
; 690  :             DROPBITS(4);

  00239	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  0023c	c1 e9 04	 shr	 ecx, 4
  0023f	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00242	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00245	83 ea 04	 sub	 edx, 4
  00248	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0024b	33 c0		 xor	 eax, eax
  0024d	75 ea		 jne	 SHORT $LN467@inflate

; 691  :             len = BITS(4) + 8;

  0024f	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00252	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00255	83 c1 08	 add	 ecx, 8
  00258	89 4d e8	 mov	 DWORD PTR _len$[ebp], ecx

; 692  :             if (state->wbits == 0)

  0025b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0025e	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00262	75 09		 jne	 SHORT $LN464@inflate

; 693  :                 state->wbits = len;

  00264	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00267	8b 4d e8	 mov	 ecx, DWORD PTR _len$[ebp]
  0026a	89 48 28	 mov	 DWORD PTR [eax+40], ecx
$LN464@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  0026d	83 7d e8 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  00271	77 0b		 ja	 SHORT $LN462@inflate
  00273	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00276	8b 45 e8	 mov	 eax, DWORD PTR _len$[ebp]
  00279	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  0027c	76 19		 jbe	 SHORT $LN463@inflate
$LN462@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  0027e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00281	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 696  :                 state->mode = BAD;

  00288	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0028b	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 697  :                 break;

  00292	e9 18 1c 00 00	 jmp	 $LN491@inflate
$LN463@inflate:

; 698  :             }
; 699  :             state->dmax = 1U << len;

  00297	b8 01 00 00 00	 mov	 eax, 1
  0029c	8b 4d e8	 mov	 ecx, DWORD PTR _len$[ebp]
  0029f	d3 e0		 shl	 eax, cl
  002a1	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  002a4	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  002a7	6a 00		 push	 0
  002a9	6a 00		 push	 0
  002ab	6a 00		 push	 0
  002ad	e8 00 00 00 00	 call	 _adler32@12
  002b2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  002b5	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  002b8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  002bb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  002be	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  002c1	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  002c4	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  002c7	25 00 02 00 00	 and	 eax, 512		; 00000200H
  002cc	f7 d8		 neg	 eax
  002ce	1b c0		 sbb	 eax, eax
  002d0	83 e0 fe	 and	 eax, -2			; fffffffeH
  002d3	05 3f 3f 00 00	 add	 eax, 16191		; 00003f3fH
  002d8	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  002db	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN461@inflate:

; 703  :             INITBITS();

  002de	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  002e5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  002ec	33 d2		 xor	 edx, edx
  002ee	75 ee		 jne	 SHORT $LN461@inflate

; 704  :             break;

  002f0	e9 ba 1b 00 00	 jmp	 $LN491@inflate
$LN454@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  002f5	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  002f9	73 3d		 jae	 SHORT $LN456@inflate
$LN452@inflate:
  002fb	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  002ff	75 05		 jne	 SHORT $LN449@inflate
  00301	e9 ae 1b 00 00	 jmp	 $inf_leave$77798
$LN449@inflate:
  00306	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00309	83 e8 01	 sub	 eax, 1
  0030c	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0030f	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00312	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00315	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00318	d3 e2		 shl	 edx, cl
  0031a	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  0031d	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00320	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00323	83 c0 01	 add	 eax, 1
  00326	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00329	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0032c	83 c1 08	 add	 ecx, 8
  0032f	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00332	33 d2		 xor	 edx, edx
  00334	75 c5		 jne	 SHORT $LN452@inflate
  00336	eb bd		 jmp	 SHORT $LN454@inflate
$LN456@inflate:
  00338	33 c0		 xor	 eax, eax
  0033a	75 b9		 jne	 SHORT $LN454@inflate

; 708  :             state->flags = (int)(hold);

  0033c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0033f	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00342	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00345	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00348	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0034b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00351	83 f9 08	 cmp	 ecx, 8
  00354	74 19		 je	 SHORT $LN448@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";

  00356	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00359	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 711  :                 state->mode = BAD;

  00360	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00363	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 712  :                 break;

  0036a	e9 40 1b 00 00	 jmp	 $LN491@inflate
$LN448@inflate:

; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  0036f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00372	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00375	81 e2 00 e0 00
	00		 and	 edx, 57344		; 0000e000H
  0037b	74 19		 je	 SHORT $LN447@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  0037d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00380	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@

; 716  :                 state->mode = BAD;

  00387	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0038a	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 717  :                 break;

  00391	e9 19 1b 00 00	 jmp	 $LN491@inflate
$LN447@inflate:

; 718  :             }
; 719  :             if (state->head != Z_NULL)

  00396	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00399	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0039d	74 11		 je	 SHORT $LN446@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  0039f	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  003a2	c1 e8 08	 shr	 eax, 8
  003a5	83 e0 01	 and	 eax, 1
  003a8	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  003ab	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  003ae	89 02		 mov	 DWORD PTR [edx], eax
$LN446@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003b0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  003b3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  003b6	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  003bc	74 36		 je	 SHORT $LN441@inflate
  003be	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  003c1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  003c4	83 e0 04	 and	 eax, 4
  003c7	74 2b		 je	 SHORT $LN441@inflate
$LN444@inflate:

; 722  :                 CRC2(state->check, hold);

  003c9	8a 4d d4	 mov	 cl, BYTE PTR _hold$[ebp]
  003cc	88 4d d0	 mov	 BYTE PTR _hbuf$[ebp], cl
  003cf	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  003d2	c1 ea 08	 shr	 edx, 8
  003d5	88 55 d1	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  003d8	6a 02		 push	 2
  003da	8d 45 d0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003dd	50		 push	 eax
  003de	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  003e1	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  003e4	52		 push	 edx
  003e5	e8 00 00 00 00	 call	 _crc32@12
  003ea	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  003ed	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  003f0	33 d2		 xor	 edx, edx
  003f2	75 d5		 jne	 SHORT $LN444@inflate
$LN441@inflate:

; 723  :             INITBITS();

  003f4	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  003fb	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00402	33 c0		 xor	 eax, eax
  00404	75 ee		 jne	 SHORT $LN441@inflate

; 724  :             state->mode = TIME;

  00406	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00409	c7 41 04 36 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16182 ; 00003f36H
$LN434@inflate:

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  00410	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00414	73 3d		 jae	 SHORT $LN436@inflate
$LN432@inflate:
  00416	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0041a	75 05		 jne	 SHORT $LN429@inflate
  0041c	e9 93 1a 00 00	 jmp	 $inf_leave$77798
$LN429@inflate:
  00421	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00424	83 ea 01	 sub	 edx, 1
  00427	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  0042a	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  0042d	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00430	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00433	d3 e2		 shl	 edx, cl
  00435	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  00438	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0043b	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  0043e	83 c0 01	 add	 eax, 1
  00441	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00444	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00447	83 c1 08	 add	 ecx, 8
  0044a	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0044d	33 d2		 xor	 edx, edx
  0044f	75 c5		 jne	 SHORT $LN432@inflate
  00451	eb bd		 jmp	 SHORT $LN434@inflate
$LN436@inflate:
  00453	33 c0		 xor	 eax, eax
  00455	75 b9		 jne	 SHORT $LN434@inflate

; 727  :             if (state->head != Z_NULL)

  00457	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0045a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0045e	74 0c		 je	 SHORT $LN428@inflate

; 728  :                 state->head->time = hold;

  00460	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00463	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00466	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00469	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN428@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  0046c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0046f	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00472	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00477	74 48		 je	 SHORT $LN423@inflate
  00479	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0047c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0047f	83 e2 04	 and	 edx, 4
  00482	74 3d		 je	 SHORT $LN423@inflate
$LN426@inflate:

; 730  :                 CRC4(state->check, hold);

  00484	8a 45 d4	 mov	 al, BYTE PTR _hold$[ebp]
  00487	88 45 d0	 mov	 BYTE PTR _hbuf$[ebp], al
  0048a	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  0048d	c1 e9 08	 shr	 ecx, 8
  00490	88 4d d1	 mov	 BYTE PTR _hbuf$[ebp+1], cl
  00493	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00496	c1 ea 10	 shr	 edx, 16			; 00000010H
  00499	88 55 d2	 mov	 BYTE PTR _hbuf$[ebp+2], dl
  0049c	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  0049f	c1 e8 18	 shr	 eax, 24			; 00000018H
  004a2	88 45 d3	 mov	 BYTE PTR _hbuf$[ebp+3], al
  004a5	6a 04		 push	 4
  004a7	8d 4d d0	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  004aa	51		 push	 ecx
  004ab	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  004ae	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  004b1	50		 push	 eax
  004b2	e8 00 00 00 00	 call	 _crc32@12
  004b7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  004ba	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  004bd	33 d2		 xor	 edx, edx
  004bf	75 c3		 jne	 SHORT $LN426@inflate
$LN423@inflate:

; 731  :             INITBITS();

  004c1	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  004c8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  004cf	33 c0		 xor	 eax, eax
  004d1	75 ee		 jne	 SHORT $LN423@inflate

; 732  :             state->mode = OS;

  004d3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  004d6	c7 41 04 37 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16183 ; 00003f37H
$LN416@inflate:

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  004dd	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  004e1	73 3d		 jae	 SHORT $LN418@inflate
$LN414@inflate:
  004e3	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  004e7	75 05		 jne	 SHORT $LN411@inflate
  004e9	e9 c6 19 00 00	 jmp	 $inf_leave$77798
$LN411@inflate:
  004ee	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  004f1	83 ea 01	 sub	 edx, 1
  004f4	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  004f7	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  004fa	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  004fd	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00500	d3 e2		 shl	 edx, cl
  00502	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  00505	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00508	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  0050b	83 c0 01	 add	 eax, 1
  0050e	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00511	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00514	83 c1 08	 add	 ecx, 8
  00517	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0051a	33 d2		 xor	 edx, edx
  0051c	75 c5		 jne	 SHORT $LN414@inflate
  0051e	eb bd		 jmp	 SHORT $LN416@inflate
$LN418@inflate:
  00520	33 c0		 xor	 eax, eax
  00522	75 b9		 jne	 SHORT $LN416@inflate

; 735  :             if (state->head != Z_NULL) {

  00524	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00527	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0052b	74 21		 je	 SHORT $LN410@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  0052d	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00530	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00536	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00539	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0053c	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 737  :                 state->head->os = (int)(hold >> 8);

  0053f	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00542	c1 ea 08	 shr	 edx, 8
  00545	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00548	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0054b	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN410@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  0054e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00551	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00554	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00559	74 36		 je	 SHORT $LN405@inflate
  0055b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0055e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00561	83 e2 04	 and	 edx, 4
  00564	74 2b		 je	 SHORT $LN405@inflate
$LN408@inflate:

; 740  :                 CRC2(state->check, hold);

  00566	8a 45 d4	 mov	 al, BYTE PTR _hold$[ebp]
  00569	88 45 d0	 mov	 BYTE PTR _hbuf$[ebp], al
  0056c	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  0056f	c1 e9 08	 shr	 ecx, 8
  00572	88 4d d1	 mov	 BYTE PTR _hbuf$[ebp+1], cl
  00575	6a 02		 push	 2
  00577	8d 55 d0	 lea	 edx, DWORD PTR _hbuf$[ebp]
  0057a	52		 push	 edx
  0057b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0057e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00581	51		 push	 ecx
  00582	e8 00 00 00 00	 call	 _crc32@12
  00587	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0058a	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  0058d	33 c0		 xor	 eax, eax
  0058f	75 d5		 jne	 SHORT $LN408@inflate
$LN405@inflate:

; 741  :             INITBITS();

  00591	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00598	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  0059f	33 c9		 xor	 ecx, ecx
  005a1	75 ee		 jne	 SHORT $LN405@inflate

; 742  :             state->mode = EXLEN;

  005a3	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  005a6	c7 42 04 38 3f
	00 00		 mov	 DWORD PTR [edx+4], 16184 ; 00003f38H
$LN402@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  005ad	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  005b0	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  005b3	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  005b9	0f 84 bd 00 00
	00		 je	 $LN401@inflate
$LN397@inflate:

; 745  :                 NEEDBITS(16);

  005bf	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  005c3	73 3d		 jae	 SHORT $LN399@inflate
$LN395@inflate:
  005c5	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  005c9	75 05		 jne	 SHORT $LN392@inflate
  005cb	e9 e4 18 00 00	 jmp	 $inf_leave$77798
$LN392@inflate:
  005d0	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  005d3	83 ea 01	 sub	 edx, 1
  005d6	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  005d9	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  005dc	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  005df	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  005e2	d3 e2		 shl	 edx, cl
  005e4	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  005e7	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  005ea	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  005ed	83 c0 01	 add	 eax, 1
  005f0	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  005f3	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  005f6	83 c1 08	 add	 ecx, 8
  005f9	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  005fc	33 d2		 xor	 edx, edx
  005fe	75 c5		 jne	 SHORT $LN395@inflate
  00600	eb bd		 jmp	 SHORT $LN397@inflate
$LN399@inflate:
  00602	33 c0		 xor	 eax, eax
  00604	75 b9		 jne	 SHORT $LN397@inflate

; 746  :                 state->length = (unsigned)(hold);

  00606	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00609	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  0060c	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 747  :                 if (state->head != Z_NULL)

  0060f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00612	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00616	74 0c		 je	 SHORT $LN391@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  00618	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0061b	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0061e	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00621	89 42 14	 mov	 DWORD PTR [edx+20], eax
$LN391@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00624	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00627	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0062a	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00630	74 36		 je	 SHORT $LN386@inflate
  00632	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00635	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00638	83 e1 04	 and	 ecx, 4
  0063b	74 2b		 je	 SHORT $LN386@inflate
$LN389@inflate:

; 750  :                     CRC2(state->check, hold);

  0063d	8a 55 d4	 mov	 dl, BYTE PTR _hold$[ebp]
  00640	88 55 d0	 mov	 BYTE PTR _hbuf$[ebp], dl
  00643	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00646	c1 e8 08	 shr	 eax, 8
  00649	88 45 d1	 mov	 BYTE PTR _hbuf$[ebp+1], al
  0064c	6a 02		 push	 2
  0064e	8d 4d d0	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00651	51		 push	 ecx
  00652	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00655	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00658	50		 push	 eax
  00659	e8 00 00 00 00	 call	 _crc32@12
  0065e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00661	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00664	33 d2		 xor	 edx, edx
  00666	75 d5		 jne	 SHORT $LN389@inflate
$LN386@inflate:

; 751  :                 INITBITS();

  00668	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  0066f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00676	33 c0		 xor	 eax, eax
  00678	75 ee		 jne	 SHORT $LN386@inflate

; 752  :             }
; 753  :             else if (state->head != Z_NULL)

  0067a	eb 16		 jmp	 SHORT $LN383@inflate
$LN401@inflate:
  0067c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0067f	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00683	74 0d		 je	 SHORT $LN383@inflate

; 754  :                 state->head->extra = Z_NULL;

  00685	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00688	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0068b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN383@inflate:

; 755  :             state->mode = EXTRA;

  00692	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00695	c7 41 04 39 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16185 ; 00003f39H
$LN381@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  0069c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0069f	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  006a2	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  006a7	0f 84 ef 00 00
	00		 je	 $LN380@inflate

; 758  :                 copy = state->length;

  006ad	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  006b0	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  006b3	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx

; 759  :                 if (copy > have) copy = have;

  006b6	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  006b9	3b 45 f0	 cmp	 eax, DWORD PTR _have$[ebp]
  006bc	76 06		 jbe	 SHORT $LN379@inflate
  006be	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  006c1	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN379@inflate:

; 760  :                 if (copy) {

  006c4	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  006c8	0f 84 c0 00 00
	00		 je	 $LN378@inflate

; 761  :                     if (state->head != Z_NULL &&
; 762  :                         state->head->extra != Z_NULL) {

  006ce	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  006d1	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  006d5	74 63		 je	 SHORT $LN377@inflate
  006d7	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  006da	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  006dd	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  006e1	74 57		 je	 SHORT $LN377@inflate

; 763  :                         len = state->head->extra_len - state->length;

  006e3	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  006e6	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  006e9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  006ec	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  006ef	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  006f2	89 55 e8	 mov	 DWORD PTR _len$[ebp], edx

; 764  :                         zmemcpy(state->head->extra + len, next,
; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);

  006f5	8b 45 e8	 mov	 eax, DWORD PTR _len$[ebp]
  006f8	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  006fb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  006fe	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00701	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  00704	76 11		 jbe	 SHORT $LN503@inflate
  00706	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00709	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0070c	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0070f	2b 55 e8	 sub	 edx, DWORD PTR _len$[ebp]
  00712	89 55 b8	 mov	 DWORD PTR tv382[ebp], edx
  00715	eb 06		 jmp	 SHORT $LN504@inflate
$LN503@inflate:
  00717	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  0071a	89 45 b8	 mov	 DWORD PTR tv382[ebp], eax
$LN504@inflate:
  0071d	8b 4d b8	 mov	 ecx, DWORD PTR tv382[ebp]
  00720	51		 push	 ecx
  00721	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00724	52		 push	 edx
  00725	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00728	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0072b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0072e	03 55 e8	 add	 edx, DWORD PTR _len$[ebp]
  00731	52		 push	 edx
  00732	e8 00 00 00 00	 call	 _memcpy
  00737	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN377@inflate:

; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  0073a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0073d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00740	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00746	74 25		 je	 SHORT $LN376@inflate
  00748	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0074b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0074e	83 e0 04	 and	 eax, 4
  00751	74 1a		 je	 SHORT $LN376@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  00753	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  00756	51		 push	 ecx
  00757	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  0075a	52		 push	 edx
  0075b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0075e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00761	51		 push	 ecx
  00762	e8 00 00 00 00	 call	 _crc32@12
  00767	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0076a	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$LN376@inflate:

; 770  :                     have -= copy;

  0076d	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00770	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  00773	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax

; 771  :                     next += copy;

  00776	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00779	03 4d cc	 add	 ecx, DWORD PTR _copy$[ebp]
  0077c	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx

; 772  :                     state->length -= copy;

  0077f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00782	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00785	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  00788	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0078b	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN378@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  0078e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00791	83 7a 44 00	 cmp	 DWORD PTR [edx+68], 0
  00795	74 05		 je	 SHORT $LN380@inflate
  00797	e9 18 17 00 00	 jmp	 $inf_leave$77798
$LN380@inflate:

; 775  :             }
; 776  :             state->length = 0;

  0079c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0079f	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 777  :             state->mode = NAME;

  007a6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007a9	c7 41 04 3a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16186 ; 00003f3aH
$LN374@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  007b0	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  007b3	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  007b6	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  007bb	0f 84 d1 00 00
	00		 je	 $LN373@inflate

; 780  :                 if (have == 0) goto inf_leave;

  007c1	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  007c5	75 05		 jne	 SHORT $LN372@inflate
  007c7	e9 e8 16 00 00	 jmp	 $inf_leave$77798
$LN372@inflate:

; 781  :                 copy = 0;

  007cc	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0
$LN371@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  007d3	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  007d6	03 4d cc	 add	 ecx, DWORD PTR _copy$[ebp]
  007d9	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  007dc	89 55 e8	 mov	 DWORD PTR _len$[ebp], edx
  007df	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  007e2	83 c0 01	 add	 eax, 1
  007e5	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&
; 786  :                             state->length < state->head->name_max)

  007e8	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007eb	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  007ef	74 41		 je	 SHORT $LN370@inflate
  007f1	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  007f4	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  007f7	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  007fb	74 35		 je	 SHORT $LN370@inflate
  007fd	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00800	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00803	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00806	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00809	3b 4a 20	 cmp	 ecx, DWORD PTR [edx+32]
  0080c	73 24		 jae	 SHORT $LN370@inflate

; 787  :                         state->head->name[state->length++] = (Bytef)len;

  0080e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00811	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00814	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00817	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0081a	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0081d	8a 55 e8	 mov	 dl, BYTE PTR _len$[ebp]
  00820	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00823	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00826	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00829	83 c1 01	 add	 ecx, 1
  0082c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0082f	89 4a 44	 mov	 DWORD PTR [edx+68], ecx
$LN370@inflate:

; 788  :                 } while (len && copy < have);

  00832	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  00836	74 08		 je	 SHORT $LN369@inflate
  00838	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  0083b	3b 45 f0	 cmp	 eax, DWORD PTR _have$[ebp]
  0083e	72 93		 jb	 SHORT $LN371@inflate
$LN369@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00840	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00843	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00846	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  0084c	74 25		 je	 SHORT $LN366@inflate
  0084e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00851	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00854	83 e1 04	 and	 ecx, 4
  00857	74 1a		 je	 SHORT $LN366@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  00859	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  0085c	52		 push	 edx
  0085d	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00860	50		 push	 eax
  00861	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00864	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00867	52		 push	 edx
  00868	e8 00 00 00 00	 call	 _crc32@12
  0086d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00870	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN366@inflate:

; 791  :                 have -= copy;

  00873	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00876	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  00879	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 792  :                 next += copy;

  0087c	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  0087f	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00882	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax

; 793  :                 if (len) goto inf_leave;

  00885	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  00889	74 05		 je	 SHORT $LN365@inflate
  0088b	e9 24 16 00 00	 jmp	 $inf_leave$77798
$LN365@inflate:

; 794  :             }
; 795  :             else if (state->head != Z_NULL)

  00890	eb 16		 jmp	 SHORT $LN364@inflate
$LN373@inflate:
  00892	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00895	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00899	74 0d		 je	 SHORT $LN364@inflate

; 796  :                 state->head->name = Z_NULL;

  0089b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0089e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  008a1	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN364@inflate:

; 797  :             state->length = 0;

  008a8	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  008ab	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 798  :             state->mode = COMMENT;

  008b2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  008b5	c7 42 04 3b 3f
	00 00		 mov	 DWORD PTR [edx+4], 16187 ; 00003f3bH
$LN362@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  008bc	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008bf	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  008c2	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  008c8	0f 84 d0 00 00
	00		 je	 $LN361@inflate

; 801  :                 if (have == 0) goto inf_leave;

  008ce	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  008d2	75 05		 jne	 SHORT $LN360@inflate
  008d4	e9 db 15 00 00	 jmp	 $inf_leave$77798
$LN360@inflate:

; 802  :                 copy = 0;

  008d9	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0
$LN359@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  008e0	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  008e3	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  008e6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  008e9	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax
  008ec	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  008ef	83 c1 01	 add	 ecx, 1
  008f2	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&
; 807  :                             state->length < state->head->comm_max)

  008f5	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  008f8	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  008fc	74 41		 je	 SHORT $LN358@inflate
  008fe	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00901	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00904	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00908	74 35		 je	 SHORT $LN358@inflate
  0090a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0090d	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00910	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00913	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00916	3b 50 28	 cmp	 edx, DWORD PTR [eax+40]
  00919	73 24		 jae	 SHORT $LN358@inflate

; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  0091b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0091e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00921	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00924	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00927	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0092a	8a 45 e8	 mov	 al, BYTE PTR _len$[ebp]
  0092d	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00930	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00933	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00936	83 c2 01	 add	 edx, 1
  00939	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0093c	89 50 44	 mov	 DWORD PTR [eax+68], edx
$LN358@inflate:

; 809  :                 } while (len && copy < have);

  0093f	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  00943	74 08		 je	 SHORT $LN357@inflate
  00945	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  00948	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  0094b	72 93		 jb	 SHORT $LN359@inflate
$LN357@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  0094d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00950	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00953	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00958	74 25		 je	 SHORT $LN354@inflate
  0095a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0095d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00960	83 e2 04	 and	 edx, 4
  00963	74 1a		 je	 SHORT $LN354@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  00965	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  00968	50		 push	 eax
  00969	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  0096c	51		 push	 ecx
  0096d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00970	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00973	50		 push	 eax
  00974	e8 00 00 00 00	 call	 _crc32@12
  00979	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0097c	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN354@inflate:

; 812  :                 have -= copy;

  0097f	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00982	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  00985	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 813  :                 next += copy;

  00988	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  0098b	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  0098e	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax

; 814  :                 if (len) goto inf_leave;

  00991	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  00995	74 05		 je	 SHORT $LN353@inflate
  00997	e9 18 15 00 00	 jmp	 $inf_leave$77798
$LN353@inflate:

; 815  :             }
; 816  :             else if (state->head != Z_NULL)

  0099c	eb 16		 jmp	 SHORT $LN352@inflate
$LN361@inflate:
  0099e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  009a1	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  009a5	74 0d		 je	 SHORT $LN352@inflate

; 817  :                 state->head->comment = Z_NULL;

  009a7	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  009aa	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  009ad	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN352@inflate:

; 818  :             state->mode = HCRC;

  009b4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  009b7	c7 41 04 3c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16188 ; 00003f3cH
$LN350@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  009be	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  009c1	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  009c4	25 00 02 00 00	 and	 eax, 512		; 00000200H
  009c9	0f 84 8e 00 00
	00		 je	 $LN349@inflate
$LN345@inflate:

; 821  :                 NEEDBITS(16);

  009cf	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  009d3	73 3d		 jae	 SHORT $LN347@inflate
$LN343@inflate:
  009d5	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  009d9	75 05		 jne	 SHORT $LN340@inflate
  009db	e9 d4 14 00 00	 jmp	 $inf_leave$77798
$LN340@inflate:
  009e0	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  009e3	83 e9 01	 sub	 ecx, 1
  009e6	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  009e9	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  009ec	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  009ef	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  009f2	d3 e0		 shl	 eax, cl
  009f4	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  009f7	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  009fa	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  009fd	83 c1 01	 add	 ecx, 1
  00a00	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00a03	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00a06	83 c2 08	 add	 edx, 8
  00a09	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00a0c	33 c0		 xor	 eax, eax
  00a0e	75 c5		 jne	 SHORT $LN343@inflate
  00a10	eb bd		 jmp	 SHORT $LN345@inflate
$LN347@inflate:
  00a12	33 c9		 xor	 ecx, ecx
  00a14	75 b9		 jne	 SHORT $LN345@inflate

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  00a16	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00a19	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00a1c	83 e0 04	 and	 eax, 4
  00a1f	74 2a		 je	 SHORT $LN338@inflate
  00a21	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00a24	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00a27	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00a2d	39 55 d4	 cmp	 DWORD PTR _hold$[ebp], edx
  00a30	74 19		 je	 SHORT $LN338@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  00a32	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00a35	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@

; 824  :                     state->mode = BAD;

  00a3c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00a3f	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 825  :                     break;

  00a46	e9 64 14 00 00	 jmp	 $LN491@inflate
$LN338@inflate:

; 826  :                 }
; 827  :                 INITBITS();

  00a4b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00a52	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00a59	33 d2		 xor	 edx, edx
  00a5b	75 ee		 jne	 SHORT $LN338@inflate
$LN349@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  00a5d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00a60	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00a64	74 22		 je	 SHORT $LN335@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00a66	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00a69	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00a6c	c1 fa 09	 sar	 edx, 9
  00a6f	83 e2 01	 and	 edx, 1
  00a72	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00a75	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00a78	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 831  :                 state->head->done = 1;

  00a7b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00a7e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00a81	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN335@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00a88	6a 00		 push	 0
  00a8a	6a 00		 push	 0
  00a8c	6a 00		 push	 0
  00a8e	e8 00 00 00 00	 call	 _crc32@12
  00a93	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00a96	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00a99	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00a9c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00a9f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00aa2	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 834  :             state->mode = TYPE;

  00aa5	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00aa8	c7 42 04 3f 3f
	00 00		 mov	 DWORD PTR [edx+4], 16191 ; 00003f3fH

; 835  :             break;

  00aaf	e9 fb 13 00 00	 jmp	 $LN491@inflate
$LN330@inflate:

; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  00ab4	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00ab8	73 3d		 jae	 SHORT $LN332@inflate
$LN328@inflate:
  00aba	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00abe	75 05		 jne	 SHORT $LN325@inflate
  00ac0	e9 ef 13 00 00	 jmp	 $inf_leave$77798
$LN325@inflate:
  00ac5	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00ac8	83 e8 01	 sub	 eax, 1
  00acb	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00ace	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00ad1	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00ad4	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00ad7	d3 e2		 shl	 edx, cl
  00ad9	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  00adc	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00adf	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00ae2	83 c0 01	 add	 eax, 1
  00ae5	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00ae8	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00aeb	83 c1 08	 add	 ecx, 8
  00aee	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00af1	33 d2		 xor	 edx, edx
  00af3	75 c5		 jne	 SHORT $LN328@inflate
  00af5	eb bd		 jmp	 SHORT $LN330@inflate
$LN332@inflate:
  00af7	33 c0		 xor	 eax, eax
  00af9	75 b9		 jne	 SHORT $LN330@inflate

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  00afb	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00afe	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00b01	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00b07	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00b0a	c1 ea 08	 shr	 edx, 8
  00b0d	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  00b13	03 ca		 add	 ecx, edx
  00b15	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00b18	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00b1d	c1 e0 08	 shl	 eax, 8
  00b20	03 c8		 add	 ecx, eax
  00b22	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00b25	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00b2b	c1 e2 18	 shl	 edx, 24			; 00000018H
  00b2e	03 ca		 add	 ecx, edx
  00b30	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00b33	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00b36	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00b39	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00b3c	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00b3f	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN324@inflate:

; 840  :             INITBITS();

  00b42	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00b49	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00b50	33 c9		 xor	 ecx, ecx
  00b52	75 ee		 jne	 SHORT $LN324@inflate

; 841  :             state->mode = DICT;

  00b54	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00b57	c7 42 04 3e 3f
	00 00		 mov	 DWORD PTR [edx+4], 16190 ; 00003f3eH
$LN321@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  00b5e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00b61	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00b65	75 43		 jne	 SHORT $LN320@inflate
$LN319@inflate:

; 844  :                 RESTORE();

  00b67	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00b6a	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00b6d	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00b70	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b73	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00b76	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00b79	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00b7c	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00b7f	89 02		 mov	 DWORD PTR [edx], eax
  00b81	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00b84	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00b87	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00b8a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00b8d	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00b90	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  00b93	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00b96	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00b99	89 42 40	 mov	 DWORD PTR [edx+64], eax
  00b9c	33 c9		 xor	 ecx, ecx
  00b9e	75 c7		 jne	 SHORT $LN319@inflate

; 845  :                 return Z_NEED_DICT;

  00ba0	b8 02 00 00 00	 mov	 eax, 2
  00ba5	e9 d9 14 00 00	 jmp	 $LN501@inflate
$LN320@inflate:

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00baa	6a 00		 push	 0
  00bac	6a 00		 push	 0
  00bae	6a 00		 push	 0
  00bb0	e8 00 00 00 00	 call	 _adler32@12
  00bb5	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00bb8	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  00bbb	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00bbe	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00bc1	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00bc4	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 848  :             state->mode = TYPE;

  00bc7	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00bca	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH
$LN316@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00bd1	83 7d 0c 05	 cmp	 DWORD PTR _flush$[ebp], 5
  00bd5	74 06		 je	 SHORT $LN314@inflate
  00bd7	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00bdb	75 05		 jne	 SHORT $LN313@inflate
$LN314@inflate:
  00bdd	e9 d2 12 00 00	 jmp	 $inf_leave$77798
$LN313@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  00be2	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00be5	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00be9	74 2f		 je	 SHORT $LN305@inflate
$LN311@inflate:

; 853  :                 BYTEBITS();

  00beb	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00bee	83 e1 07	 and	 ecx, 7
  00bf1	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00bf4	d3 ea		 shr	 edx, cl
  00bf6	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00bf9	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00bfc	83 e0 07	 and	 eax, 7
  00bff	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c02	2b c8		 sub	 ecx, eax
  00c04	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00c07	33 d2		 xor	 edx, edx
  00c09	75 e0		 jne	 SHORT $LN311@inflate

; 854  :                 state->mode = CHECK;

  00c0b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00c0e	c7 40 04 4e 3f
	00 00		 mov	 DWORD PTR [eax+4], 16206 ; 00003f4eH

; 855  :                 break;

  00c15	e9 95 12 00 00	 jmp	 $LN491@inflate
$LN305@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  00c1a	83 7d e4 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00c1e	73 3d		 jae	 SHORT $LN307@inflate
$LN303@inflate:
  00c20	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00c24	75 05		 jne	 SHORT $LN300@inflate
  00c26	e9 89 12 00 00	 jmp	 $inf_leave$77798
$LN300@inflate:
  00c2b	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00c2e	83 e9 01	 sub	 ecx, 1
  00c31	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00c34	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00c37	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00c3a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c3d	d3 e0		 shl	 eax, cl
  00c3f	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  00c42	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00c45	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00c48	83 c1 01	 add	 ecx, 1
  00c4b	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00c4e	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00c51	83 c2 08	 add	 edx, 8
  00c54	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00c57	33 c0		 xor	 eax, eax
  00c59	75 c5		 jne	 SHORT $LN303@inflate
  00c5b	eb bd		 jmp	 SHORT $LN305@inflate
$LN307@inflate:
  00c5d	33 c9		 xor	 ecx, ecx
  00c5f	75 b9		 jne	 SHORT $LN305@inflate

; 858  :             state->last = BITS(1);

  00c61	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00c64	83 e2 01	 and	 edx, 1
  00c67	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00c6a	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN299@inflate:

; 859  :             DROPBITS(1);

  00c6d	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00c70	d1 e9		 shr	 ecx, 1
  00c72	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00c75	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00c78	83 ea 01	 sub	 edx, 1
  00c7b	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00c7e	33 c0		 xor	 eax, eax
  00c80	75 eb		 jne	 SHORT $LN299@inflate

; 860  :             switch (BITS(2)) {

  00c82	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00c85	83 e1 03	 and	 ecx, 3
  00c88	89 4d b4	 mov	 DWORD PTR tv607[ebp], ecx
  00c8b	83 7d b4 03	 cmp	 DWORD PTR tv607[ebp], 3
  00c8f	77 6f		 ja	 SHORT $LN286@inflate
  00c91	8b 55 b4	 mov	 edx, DWORD PTR tv607[ebp]
  00c94	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN514@inflate[edx*4]
$LN294@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;

  00c9b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00c9e	c7 40 04 41 3f
	00 00		 mov	 DWORD PTR [eax+4], 16193 ; 00003f41H

; 865  :                 break;

  00ca5	eb 59		 jmp	 SHORT $LN286@inflate
$LN293@inflate:

; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  00ca7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00caa	51		 push	 ecx
  00cab	e8 00 00 00 00	 call	 _fixedtables
  00cb0	83 c4 04	 add	 esp, 4

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */

  00cb3	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00cb6	c7 42 04 47 3f
	00 00		 mov	 DWORD PTR [edx+4], 16199 ; 00003f47H

; 871  :                 if (flush == Z_TREES) {

  00cbd	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00cc1	75 1b		 jne	 SHORT $LN292@inflate
$LN291@inflate:

; 872  :                     DROPBITS(2);

  00cc3	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00cc6	c1 e8 02	 shr	 eax, 2
  00cc9	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00ccc	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00ccf	83 e9 02	 sub	 ecx, 2
  00cd2	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00cd5	33 d2		 xor	 edx, edx
  00cd7	75 ea		 jne	 SHORT $LN291@inflate

; 873  :                     goto inf_leave;

  00cd9	e9 d6 11 00 00	 jmp	 $inf_leave$77798
$LN292@inflate:

; 874  :                 }
; 875  :                 break;

  00cde	eb 20		 jmp	 SHORT $LN286@inflate
$LN288@inflate:

; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;

  00ce0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00ce3	c7 40 04 44 3f
	00 00		 mov	 DWORD PTR [eax+4], 16196 ; 00003f44H

; 880  :                 break;

  00cea	eb 14		 jmp	 SHORT $LN286@inflate
$LN287@inflate:

; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  00cec	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00cef	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 883  :                 state->mode = BAD;

  00cf6	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00cf9	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H
$LN286@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  00d00	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00d03	c1 e8 02	 shr	 eax, 2
  00d06	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00d09	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d0c	83 e9 02	 sub	 ecx, 2
  00d0f	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00d12	33 d2		 xor	 edx, edx
  00d14	75 ea		 jne	 SHORT $LN286@inflate

; 886  :             break;

  00d16	e9 94 11 00 00	 jmp	 $LN491@inflate
$LN282@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  00d1b	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d1e	83 e1 07	 and	 ecx, 7
  00d21	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00d24	d3 e8		 shr	 eax, cl
  00d26	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00d29	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d2c	83 e1 07	 and	 ecx, 7
  00d2f	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00d32	2b d1		 sub	 edx, ecx
  00d34	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00d37	33 c0		 xor	 eax, eax
  00d39	75 e0		 jne	 SHORT $LN282@inflate
$LN276@inflate:

; 889  :             NEEDBITS(32);

  00d3b	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00d3f	73 3d		 jae	 SHORT $LN278@inflate
$LN274@inflate:
  00d41	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d45	75 05		 jne	 SHORT $LN271@inflate
  00d47	e9 68 11 00 00	 jmp	 $inf_leave$77798
$LN271@inflate:
  00d4c	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00d4f	83 e9 01	 sub	 ecx, 1
  00d52	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00d55	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00d58	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00d5b	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d5e	d3 e0		 shl	 eax, cl
  00d60	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  00d63	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00d66	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00d69	83 c1 01	 add	 ecx, 1
  00d6c	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00d6f	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00d72	83 c2 08	 add	 edx, 8
  00d75	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00d78	33 c0		 xor	 eax, eax
  00d7a	75 c5		 jne	 SHORT $LN274@inflate
  00d7c	eb bd		 jmp	 SHORT $LN276@inflate
$LN278@inflate:
  00d7e	33 c9		 xor	 ecx, ecx
  00d80	75 b9		 jne	 SHORT $LN276@inflate

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00d82	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00d85	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00d8b	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00d8e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00d91	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  00d96	3b d0		 cmp	 edx, eax
  00d98	74 19		 je	 SHORT $LN270@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  00d9a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00d9d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 892  :                 state->mode = BAD;

  00da4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00da7	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 893  :                 break;

  00dae	e9 fc 10 00 00	 jmp	 $LN491@inflate
$LN270@inflate:

; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  00db3	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00db6	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00dbb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00dbe	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN269@inflate:

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  00dc1	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00dc8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00dcf	33 d2		 xor	 edx, edx
  00dd1	75 ee		 jne	 SHORT $LN269@inflate

; 899  :             state->mode = COPY_;

  00dd3	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00dd6	c7 40 04 42 3f
	00 00		 mov	 DWORD PTR [eax+4], 16194 ; 00003f42H

; 900  :             if (flush == Z_TREES) goto inf_leave;

  00ddd	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00de1	75 05		 jne	 SHORT $LN265@inflate
  00de3	e9 cc 10 00 00	 jmp	 $inf_leave$77798
$LN265@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  00de8	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00deb	c7 41 04 43 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16195 ; 00003f43H
$LN264@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  00df2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00df5	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00df8	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax

; 905  :             if (copy) {

  00dfb	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00dff	74 73		 je	 SHORT $LN263@inflate

; 906  :                 if (copy > have) copy = have;

  00e01	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  00e04	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  00e07	76 06		 jbe	 SHORT $LN262@inflate
  00e09	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00e0c	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
$LN262@inflate:

; 907  :                 if (copy > left) copy = left;

  00e0f	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  00e12	3b 45 e0	 cmp	 eax, DWORD PTR _left$[ebp]
  00e15	76 06		 jbe	 SHORT $LN261@inflate
  00e17	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00e1a	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN261@inflate:

; 908  :                 if (copy == 0) goto inf_leave;

  00e1d	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00e21	75 05		 jne	 SHORT $LN260@inflate
  00e23	e9 8c 10 00 00	 jmp	 $inf_leave$77798
$LN260@inflate:

; 909  :                 zmemcpy(put, next, copy);

  00e28	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  00e2b	52		 push	 edx
  00e2c	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00e2f	50		 push	 eax
  00e30	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  00e33	51		 push	 ecx
  00e34	e8 00 00 00 00	 call	 _memcpy
  00e39	83 c4 0c	 add	 esp, 12			; 0000000cH

; 910  :                 have -= copy;

  00e3c	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00e3f	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  00e42	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 911  :                 next += copy;

  00e45	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00e48	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00e4b	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax

; 912  :                 left -= copy;

  00e4e	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00e51	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  00e54	89 4d e0	 mov	 DWORD PTR _left$[ebp], ecx

; 913  :                 put += copy;

  00e57	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e5a	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  00e5d	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 914  :                 state->length -= copy;

  00e60	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00e63	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00e66	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  00e69	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00e6c	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 915  :                 break;

  00e6f	e9 3b 10 00 00	 jmp	 $LN491@inflate
$LN263@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;

  00e74	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00e77	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 919  :             break;

  00e7e	e9 2c 10 00 00	 jmp	 $LN491@inflate
$LN255@inflate:

; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  00e83	83 7d e4 0e	 cmp	 DWORD PTR _bits$[ebp], 14 ; 0000000eH
  00e87	73 3d		 jae	 SHORT $LN257@inflate
$LN253@inflate:
  00e89	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00e8d	75 05		 jne	 SHORT $LN250@inflate
  00e8f	e9 20 10 00 00	 jmp	 $inf_leave$77798
$LN250@inflate:
  00e94	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00e97	83 e9 01	 sub	 ecx, 1
  00e9a	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00e9d	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00ea0	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00ea3	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00ea6	d3 e0		 shl	 eax, cl
  00ea8	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  00eab	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00eae	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00eb1	83 c1 01	 add	 ecx, 1
  00eb4	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00eb7	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00eba	83 c2 08	 add	 edx, 8
  00ebd	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00ec0	33 c0		 xor	 eax, eax
  00ec2	75 c5		 jne	 SHORT $LN253@inflate
  00ec4	eb bd		 jmp	 SHORT $LN255@inflate
$LN257@inflate:
  00ec6	33 c9		 xor	 ecx, ecx
  00ec8	75 b9		 jne	 SHORT $LN255@inflate

; 922  :             state->nlen = BITS(5) + 257;

  00eca	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00ecd	83 e2 1f	 and	 edx, 31			; 0000001fH
  00ed0	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  00ed6	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00ed9	89 50 64	 mov	 DWORD PTR [eax+100], edx
$LN249@inflate:

; 923  :             DROPBITS(5);

  00edc	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00edf	c1 e9 05	 shr	 ecx, 5
  00ee2	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00ee5	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00ee8	83 ea 05	 sub	 edx, 5
  00eeb	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00eee	33 c0		 xor	 eax, eax
  00ef0	75 ea		 jne	 SHORT $LN249@inflate

; 924  :             state->ndist = BITS(5) + 1;

  00ef2	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00ef5	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00ef8	83 c1 01	 add	 ecx, 1
  00efb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00efe	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
$LN246@inflate:

; 925  :             DROPBITS(5);

  00f01	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00f04	c1 e8 05	 shr	 eax, 5
  00f07	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00f0a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f0d	83 e9 05	 sub	 ecx, 5
  00f10	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00f13	33 d2		 xor	 edx, edx
  00f15	75 ea		 jne	 SHORT $LN246@inflate

; 926  :             state->ncode = BITS(4) + 4;

  00f17	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00f1a	83 e0 0f	 and	 eax, 15			; 0000000fH
  00f1d	83 c0 04	 add	 eax, 4
  00f20	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f23	89 41 60	 mov	 DWORD PTR [ecx+96], eax
$LN243@inflate:

; 927  :             DROPBITS(4);

  00f26	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00f29	c1 ea 04	 shr	 edx, 4
  00f2c	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00f2f	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00f32	83 e8 04	 sub	 eax, 4
  00f35	89 45 e4	 mov	 DWORD PTR _bits$[ebp], eax
  00f38	33 c9		 xor	 ecx, ecx
  00f3a	75 ea		 jne	 SHORT $LN243@inflate

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  00f3c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f3f	81 7a 64 1e 01
	00 00		 cmp	 DWORD PTR [edx+100], 286 ; 0000011eH
  00f46	77 09		 ja	 SHORT $LN239@inflate
  00f48	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f4b	83 78 68 1e	 cmp	 DWORD PTR [eax+104], 30	; 0000001eH
  00f4f	76 19		 jbe	 SHORT $LN240@inflate
$LN239@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  00f51	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00f54	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 931  :                 state->mode = BAD;

  00f5b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f5e	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 932  :                 break;

  00f65	e9 45 0f 00 00	 jmp	 $LN491@inflate
$LN240@inflate:

; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  00f6a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f6d	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0

; 937  :             state->mode = LENLENS;

  00f74	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f77	c7 41 04 45 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16197 ; 00003f45H
$LN237@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  00f7e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f81	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f84	8b 4a 6c	 mov	 ecx, DWORD PTR [edx+108]
  00f87	3b 48 60	 cmp	 ecx, DWORD PTR [eax+96]
  00f8a	0f 83 8d 00 00
	00		 jae	 $LN223@inflate
$LN232@inflate:

; 940  :                 NEEDBITS(3);

  00f90	83 7d e4 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00f94	73 3d		 jae	 SHORT $LN234@inflate
$LN230@inflate:
  00f96	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f9a	75 05		 jne	 SHORT $LN227@inflate
  00f9c	e9 13 0f 00 00	 jmp	 $inf_leave$77798
$LN227@inflate:
  00fa1	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00fa4	83 ea 01	 sub	 edx, 1
  00fa7	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00faa	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00fad	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00fb0	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00fb3	d3 e2		 shl	 edx, cl
  00fb5	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  00fb8	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00fbb	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00fbe	83 c0 01	 add	 eax, 1
  00fc1	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00fc4	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00fc7	83 c1 08	 add	 ecx, 8
  00fca	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00fcd	33 d2		 xor	 edx, edx
  00fcf	75 c5		 jne	 SHORT $LN230@inflate
  00fd1	eb bd		 jmp	 SHORT $LN232@inflate
$LN234@inflate:
  00fd3	33 c0		 xor	 eax, eax
  00fd5	75 b9		 jne	 SHORT $LN232@inflate

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00fd7	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00fda	83 e1 07	 and	 ecx, 7
  00fdd	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00fe0	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00fe3	0f b7 14 45 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00feb	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fee	66 89 4c 50 74	 mov	 WORD PTR [eax+edx*2+116], cx
  00ff3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00ff6	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00ff9	83 c2 01	 add	 edx, 1
  00ffc	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fff	89 50 6c	 mov	 DWORD PTR [eax+108], edx
$LN226@inflate:

; 942  :                 DROPBITS(3);

  01002	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  01005	c1 e9 03	 shr	 ecx, 3
  01008	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  0100b	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  0100e	83 ea 03	 sub	 edx, 3
  01011	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01014	33 c0		 xor	 eax, eax
  01016	75 ea		 jne	 SHORT $LN226@inflate

; 943  :             }

  01018	e9 61 ff ff ff	 jmp	 $LN237@inflate
$LN223@inflate:

; 944  :             while (state->have < 19)

  0101d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01020	83 79 6c 13	 cmp	 DWORD PTR [ecx+108], 19	; 00000013H
  01024	73 29		 jae	 SHORT $LN222@inflate

; 945  :                 state->lens[order[state->have++]] = 0;

  01026	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01029	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0102c	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  01034	33 d2		 xor	 edx, edx
  01036	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01039	66 89 54 48 74	 mov	 WORD PTR [eax+ecx*2+116], dx
  0103e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01041	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  01044	83 c2 01	 add	 edx, 1
  01047	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0104a	89 50 6c	 mov	 DWORD PTR [eax+108], edx
  0104d	eb ce		 jmp	 SHORT $LN223@inflate
$LN222@inflate:

; 946  :             state->next = state->codes;

  0104f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01052	81 c1 34 05 00
	00		 add	 ecx, 1332		; 00000534H
  01058	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0105b	89 4a 70	 mov	 DWORD PTR [edx+112], ecx

; 947  :             state->lencode = (const code FAR *)(state->next);

  0105e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01061	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01064	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  01067	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 948  :             state->lenbits = 7;

  0106a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0106d	c7 40 58 07 00
	00 00		 mov	 DWORD PTR [eax+88], 7

; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 950  :                                 &(state->lenbits), state->work);

  01074	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01077	81 c1 f4 02 00
	00		 add	 ecx, 756		; 000002f4H
  0107d	51		 push	 ecx
  0107e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01081	83 c2 58	 add	 edx, 88			; 00000058H
  01084	52		 push	 edx
  01085	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01088	83 c0 70	 add	 eax, 112		; 00000070H
  0108b	50		 push	 eax
  0108c	6a 13		 push	 19			; 00000013H
  0108e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01091	83 c1 74	 add	 ecx, 116		; 00000074H
  01094	51		 push	 ecx
  01095	6a 00		 push	 0
  01097	e8 00 00 00 00	 call	 _inflate_table
  0109c	83 c4 18	 add	 esp, 24			; 00000018H
  0109f	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 951  :             if (ret) {

  010a2	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  010a6	74 19		 je	 SHORT $LN221@inflate

; 952  :                 strm->msg = (char *)"invalid code lengths set";

  010a8	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  010ab	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 953  :                 state->mode = BAD;

  010b2	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  010b5	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 954  :                 break;

  010bc	e9 ee 0d 00 00	 jmp	 $LN491@inflate
$LN221@inflate:

; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  010c1	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  010c4	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 958  :             state->mode = CODELENS;

  010cb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  010ce	c7 42 04 46 3f
	00 00		 mov	 DWORD PTR [edx+4], 16198 ; 00003f46H
$LN219@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  010d5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  010d8	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  010db	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  010de	03 4a 68	 add	 ecx, DWORD PTR [edx+104]
  010e1	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  010e4	39 48 6c	 cmp	 DWORD PTR [eax+108], ecx
  010e7	0f 83 1f 03 00
	00		 jae	 $LN218@inflate
$LN217@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  010ed	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  010f0	ba 01 00 00 00	 mov	 edx, 1
  010f5	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  010f8	d3 e2		 shl	 edx, cl
  010fa	83 ea 01	 sub	 edx, 1
  010fd	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  01100	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01103	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  01106	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  01109	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  0110c	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01110	3b 45 e4	 cmp	 eax, DWORD PTR _bits$[ebp]
  01113	77 02		 ja	 SHORT $LN214@inflate
  01115	eb 3d		 jmp	 SHORT $LN216@inflate
$LN214@inflate:

; 964  :                     PULLBYTE();

  01117	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0111b	75 05		 jne	 SHORT $LN211@inflate
  0111d	e9 92 0d 00 00	 jmp	 $inf_leave$77798
$LN211@inflate:
  01122	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01125	83 e9 01	 sub	 ecx, 1
  01128	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  0112b	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  0112e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01131	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01134	d3 e0		 shl	 eax, cl
  01136	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01139	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  0113c	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  0113f	83 c1 01	 add	 ecx, 1
  01142	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  01145	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01148	83 c2 08	 add	 edx, 8
  0114b	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0114e	33 c0		 xor	 eax, eax
  01150	75 c5		 jne	 SHORT $LN214@inflate

; 965  :                 }

  01152	eb 99		 jmp	 SHORT $LN217@inflate
$LN216@inflate:

; 966  :                 if (here.val < 16) {

  01154	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  01158	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0115b	7d 42		 jge	 SHORT $LN210@inflate
$LN209@inflate:

; 967  :                     DROPBITS(here.bits);

  0115d	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01161	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01164	d3 ea		 shr	 edx, cl
  01166	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01169	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0116d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01170	2b c8		 sub	 ecx, eax
  01172	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01175	33 d2		 xor	 edx, edx
  01177	75 e4		 jne	 SHORT $LN209@inflate

; 968  :                     state->lens[state->have++] = here.val;

  01179	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0117c	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0117f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01182	66 8b 45 f6	 mov	 ax, WORD PTR _here$[ebp+2]
  01186	66 89 44 4a 74	 mov	 WORD PTR [edx+ecx*2+116], ax
  0118b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0118e	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  01191	83 c2 01	 add	 edx, 1
  01194	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01197	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 969  :                 }
; 970  :                 else {

  0119a	e9 68 02 00 00	 jmp	 $LN206@inflate
$LN210@inflate:

; 971  :                     if (here.val == 16) {

  0119f	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  011a3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  011a6	0f 85 c3 00 00
	00		 jne	 $LN205@inflate
$LN201@inflate:

; 972  :                         NEEDBITS(here.bits + 2);

  011ac	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  011b0	83 c2 02	 add	 edx, 2
  011b3	39 55 e4	 cmp	 DWORD PTR _bits$[ebp], edx
  011b6	73 3d		 jae	 SHORT $LN203@inflate
$LN199@inflate:
  011b8	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  011bc	75 05		 jne	 SHORT $LN196@inflate
  011be	e9 f1 0c 00 00	 jmp	 $inf_leave$77798
$LN196@inflate:
  011c3	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  011c6	83 e8 01	 sub	 eax, 1
  011c9	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  011cc	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  011cf	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  011d2	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  011d5	d3 e2		 shl	 edx, cl
  011d7	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  011da	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  011dd	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  011e0	83 c0 01	 add	 eax, 1
  011e3	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  011e6	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  011e9	83 c1 08	 add	 ecx, 8
  011ec	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  011ef	33 d2		 xor	 edx, edx
  011f1	75 c5		 jne	 SHORT $LN199@inflate
  011f3	eb b7		 jmp	 SHORT $LN201@inflate
$LN203@inflate:
  011f5	33 c0		 xor	 eax, eax
  011f7	75 b3		 jne	 SHORT $LN201@inflate
$LN195@inflate:

; 973  :                         DROPBITS(here.bits);

  011f9	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  011fd	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01200	d3 ea		 shr	 edx, cl
  01202	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01205	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01209	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0120c	2b c8		 sub	 ecx, eax
  0120e	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01211	33 d2		 xor	 edx, edx
  01213	75 e4		 jne	 SHORT $LN195@inflate

; 974  :                         if (state->have == 0) {

  01215	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01218	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  0121c	75 19		 jne	 SHORT $LN192@inflate

; 975  :                             strm->msg = (char *)"invalid bit length repeat";

  0121e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01221	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 976  :                             state->mode = BAD;

  01228	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0122b	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 977  :                             break;

  01232	e9 d5 01 00 00	 jmp	 $LN218@inflate
$LN192@inflate:

; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];

  01237	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0123a	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0123d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01240	0f b7 44 4a 72	 movzx	 eax, WORD PTR [edx+ecx*2+114]
  01245	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax

; 980  :                         copy = 3 + BITS(2);

  01248	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  0124b	83 e1 03	 and	 ecx, 3
  0124e	83 c1 03	 add	 ecx, 3
  01251	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN191@inflate:

; 981  :                         DROPBITS(2);

  01254	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01257	c1 ea 02	 shr	 edx, 2
  0125a	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0125d	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  01260	83 e8 02	 sub	 eax, 2
  01263	89 45 e4	 mov	 DWORD PTR _bits$[ebp], eax
  01266	33 c9		 xor	 ecx, ecx
  01268	75 ea		 jne	 SHORT $LN191@inflate

; 982  :                     }
; 983  :                     else if (here.val == 17) {

  0126a	e9 36 01 00 00	 jmp	 $LN188@inflate
$LN205@inflate:
  0126f	0f b7 55 f6	 movzx	 edx, WORD PTR _here$[ebp+2]
  01273	83 fa 11	 cmp	 edx, 17			; 00000011H
  01276	0f 85 97 00 00
	00		 jne	 $LN167@inflate
$LN183@inflate:

; 984  :                         NEEDBITS(here.bits + 3);

  0127c	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01280	83 c0 03	 add	 eax, 3
  01283	39 45 e4	 cmp	 DWORD PTR _bits$[ebp], eax
  01286	73 3d		 jae	 SHORT $LN185@inflate
$LN181@inflate:
  01288	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0128c	75 05		 jne	 SHORT $LN178@inflate
  0128e	e9 21 0c 00 00	 jmp	 $inf_leave$77798
$LN178@inflate:
  01293	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01296	83 e9 01	 sub	 ecx, 1
  01299	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  0129c	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  0129f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  012a2	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  012a5	d3 e0		 shl	 eax, cl
  012a7	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  012aa	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  012ad	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  012b0	83 c1 01	 add	 ecx, 1
  012b3	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  012b6	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  012b9	83 c2 08	 add	 edx, 8
  012bc	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  012bf	33 c0		 xor	 eax, eax
  012c1	75 c5		 jne	 SHORT $LN181@inflate
  012c3	eb b7		 jmp	 SHORT $LN183@inflate
$LN185@inflate:
  012c5	33 c9		 xor	 ecx, ecx
  012c7	75 b3		 jne	 SHORT $LN183@inflate
$LN177@inflate:

; 985  :                         DROPBITS(here.bits);

  012c9	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  012cd	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  012d0	d3 ea		 shr	 edx, cl
  012d2	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  012d5	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  012d9	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  012dc	2b c8		 sub	 ecx, eax
  012de	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  012e1	33 d2		 xor	 edx, edx
  012e3	75 e4		 jne	 SHORT $LN177@inflate

; 986  :                         len = 0;

  012e5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 987  :                         copy = 3 + BITS(3);

  012ec	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  012ef	83 e0 07	 and	 eax, 7
  012f2	83 c0 03	 add	 eax, 3
  012f5	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN174@inflate:

; 988  :                         DROPBITS(3);

  012f8	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  012fb	c1 e9 03	 shr	 ecx, 3
  012fe	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  01301	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01304	83 ea 03	 sub	 edx, 3
  01307	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0130a	33 c0		 xor	 eax, eax
  0130c	75 ea		 jne	 SHORT $LN174@inflate

; 989  :                     }
; 990  :                     else {

  0130e	e9 92 00 00 00	 jmp	 $LN188@inflate
$LN167@inflate:

; 991  :                         NEEDBITS(here.bits + 7);

  01313	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01317	83 c1 07	 add	 ecx, 7
  0131a	39 4d e4	 cmp	 DWORD PTR _bits$[ebp], ecx
  0131d	73 3d		 jae	 SHORT $LN169@inflate
$LN165@inflate:
  0131f	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01323	75 05		 jne	 SHORT $LN162@inflate
  01325	e9 8a 0b 00 00	 jmp	 $inf_leave$77798
$LN162@inflate:
  0132a	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  0132d	83 ea 01	 sub	 edx, 1
  01330	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  01333	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01336	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01339	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0133c	d3 e2		 shl	 edx, cl
  0133e	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01341	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01344	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01347	83 c0 01	 add	 eax, 1
  0134a	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  0134d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01350	83 c1 08	 add	 ecx, 8
  01353	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01356	33 d2		 xor	 edx, edx
  01358	75 c5		 jne	 SHORT $LN165@inflate
  0135a	eb b7		 jmp	 SHORT $LN167@inflate
$LN169@inflate:
  0135c	33 c0		 xor	 eax, eax
  0135e	75 b3		 jne	 SHORT $LN167@inflate
$LN161@inflate:

; 992  :                         DROPBITS(here.bits);

  01360	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01364	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01367	d3 ea		 shr	 edx, cl
  01369	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0136c	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01370	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01373	2b c8		 sub	 ecx, eax
  01375	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01378	33 d2		 xor	 edx, edx
  0137a	75 e4		 jne	 SHORT $LN161@inflate

; 993  :                         len = 0;

  0137c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 994  :                         copy = 11 + BITS(7);

  01383	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01386	83 e0 7f	 and	 eax, 127		; 0000007fH
  01389	83 c0 0b	 add	 eax, 11			; 0000000bH
  0138c	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN158@inflate:

; 995  :                         DROPBITS(7);

  0138f	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  01392	c1 e9 07	 shr	 ecx, 7
  01395	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  01398	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  0139b	83 ea 07	 sub	 edx, 7
  0139e	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  013a1	33 c0		 xor	 eax, eax
  013a3	75 ea		 jne	 SHORT $LN158@inflate
$LN188@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  013a5	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013a8	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  013ab	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  013ae	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013b1	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  013b4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013b7	03 48 68	 add	 ecx, DWORD PTR [eax+104]
  013ba	3b d1		 cmp	 edx, ecx
  013bc	76 16		 jbe	 SHORT $LN154@inflate

; 998  :                         strm->msg = (char *)"invalid bit length repeat";

  013be	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  013c1	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 999  :                         state->mode = BAD;

  013c8	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  013cb	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 1000 :                         break;

  013d2	eb 38		 jmp	 SHORT $LN218@inflate
$LN154@inflate:

; 1001 :                     }
; 1002 :                     while (copy--)

  013d4	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  013d7	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  013da	83 e9 01	 sub	 ecx, 1
  013dd	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
  013e0	85 c0		 test	 eax, eax
  013e2	74 23		 je	 SHORT $LN206@inflate

; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  013e4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  013e7	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  013ea	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013ed	66 8b 55 e8	 mov	 dx, WORD PTR _len$[ebp]
  013f1	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  013f6	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013f9	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  013fc	83 c1 01	 add	 ecx, 1
  013ff	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01402	89 4a 6c	 mov	 DWORD PTR [edx+108], ecx
  01405	eb cd		 jmp	 SHORT $LN154@inflate
$LN206@inflate:

; 1004 :                 }
; 1005 :             }

  01407	e9 c9 fc ff ff	 jmp	 $LN219@inflate
$LN218@inflate:

; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  0140c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0140f	81 78 04 51 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16209 ; 00003f51H
  01416	75 05		 jne	 SHORT $LN152@inflate
  01418	e9 92 0a 00 00	 jmp	 $LN491@inflate
$LN152@inflate:

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  0141d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01420	0f b7 91 74 02
	00 00		 movzx	 edx, WORD PTR [ecx+628]
  01427	85 d2		 test	 edx, edx
  01429	75 19		 jne	 SHORT $LN151@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  0142b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0142e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 1013 :                 state->mode = BAD;

  01435	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01438	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 1014 :                 break;

  0143f	e9 6b 0a 00 00	 jmp	 $LN491@inflate
$LN151@inflate:

; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  01444	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01447	81 c2 34 05 00
	00		 add	 edx, 1332		; 00000534H
  0144d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01450	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 1021 :             state->lencode = (const code FAR *)(state->next);

  01453	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01456	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01459	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0145c	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1022 :             state->lenbits = 9;

  0145f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01462	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 1024 :                                 &(state->lenbits), state->work);

  01469	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0146c	81 c2 f4 02 00
	00		 add	 edx, 756		; 000002f4H
  01472	52		 push	 edx
  01473	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01476	83 c0 58	 add	 eax, 88			; 00000058H
  01479	50		 push	 eax
  0147a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0147d	83 c1 70	 add	 ecx, 112		; 00000070H
  01480	51		 push	 ecx
  01481	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01484	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  01487	50		 push	 eax
  01488	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0148b	83 c1 74	 add	 ecx, 116		; 00000074H
  0148e	51		 push	 ecx
  0148f	6a 01		 push	 1
  01491	e8 00 00 00 00	 call	 _inflate_table
  01496	83 c4 18	 add	 esp, 24			; 00000018H
  01499	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 1025 :             if (ret) {

  0149c	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  014a0	74 19		 je	 SHORT $LN150@inflate

; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  014a2	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014a5	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 1027 :                 state->mode = BAD;

  014ac	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  014af	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 1028 :                 break;

  014b6	e9 f4 09 00 00	 jmp	 $LN491@inflate
$LN150@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  014bb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  014be	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  014c1	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  014c4	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 1031 :             state->distbits = 6;

  014c7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  014ca	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6

; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 1033 :                             &(state->next), &(state->distbits), state->work);

  014d1	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  014d4	81 c2 f4 02 00
	00		 add	 edx, 756		; 000002f4H
  014da	52		 push	 edx
  014db	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  014de	83 c0 5c	 add	 eax, 92			; 0000005cH
  014e1	50		 push	 eax
  014e2	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  014e5	83 c1 70	 add	 ecx, 112		; 00000070H
  014e8	51		 push	 ecx
  014e9	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  014ec	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  014ef	50		 push	 eax
  014f0	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  014f3	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  014f6	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  014f9	8d 4c 50 74	 lea	 ecx, DWORD PTR [eax+edx*2+116]
  014fd	51		 push	 ecx
  014fe	6a 02		 push	 2
  01500	e8 00 00 00 00	 call	 _inflate_table
  01505	83 c4 18	 add	 esp, 24			; 00000018H
  01508	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 1034 :             if (ret) {

  0150b	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0150f	74 19		 je	 SHORT $LN149@inflate

; 1035 :                 strm->msg = (char *)"invalid distances set";

  01511	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01514	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 1036 :                 state->mode = BAD;

  0151b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0151e	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 1037 :                 break;

  01525	e9 85 09 00 00	 jmp	 $LN491@inflate
$LN149@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;

  0152a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0152d	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H

; 1041 :             if (flush == Z_TREES) goto inf_leave;

  01534	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  01538	75 05		 jne	 SHORT $LN147@inflate
  0153a	e9 75 09 00 00	 jmp	 $inf_leave$77798
$LN147@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  0153f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01542	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H
$LN146@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  01549	83 7d f0 06	 cmp	 DWORD PTR _have$[ebp], 6
  0154d	0f 82 ad 00 00
	00		 jb	 $LN145@inflate
  01553	81 7d e0 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  0155a	0f 82 a0 00 00
	00		 jb	 $LN145@inflate
$LN144@inflate:

; 1046 :                 RESTORE();

  01560	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01563	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01566	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  01569	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0156c	8b 45 e0	 mov	 eax, DWORD PTR _left$[ebp]
  0156f	89 42 10	 mov	 DWORD PTR [edx+16], eax
  01572	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01575	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  01578	89 11		 mov	 DWORD PTR [ecx], edx
  0157a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0157d	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01580	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  01583	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01586	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01589	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  0158c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0158f	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01592	89 51 40	 mov	 DWORD PTR [ecx+64], edx
  01595	33 c0		 xor	 eax, eax
  01597	75 c7		 jne	 SHORT $LN144@inflate

; 1047 :                 inflate_fast(strm, out);

  01599	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  0159c	51		 push	 ecx
  0159d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  015a0	52		 push	 edx
  015a1	e8 00 00 00 00	 call	 _inflate_fast
  015a6	83 c4 08	 add	 esp, 8
$LN141@inflate:

; 1048 :                 LOAD();

  015a9	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  015ac	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  015af	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  015b2	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  015b5	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  015b8	89 45 e0	 mov	 DWORD PTR _left$[ebp], eax
  015bb	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  015be	8b 11		 mov	 edx, DWORD PTR [ecx]
  015c0	89 55 dc	 mov	 DWORD PTR _next$[ebp], edx
  015c3	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  015c6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  015c9	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  015cc	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  015cf	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  015d2	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  015d5	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  015d8	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  015db	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  015de	33 c0		 xor	 eax, eax
  015e0	75 c7		 jne	 SHORT $LN141@inflate

; 1049 :                 if (state->mode == TYPE)

  015e2	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  015e5	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  015ec	75 0d		 jne	 SHORT $LN138@inflate

; 1050 :                     state->back = -1;

  015ee	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  015f1	c7 82 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+7112], -1
$LN138@inflate:

; 1051 :                 break;

  015fb	e9 af 08 00 00	 jmp	 $LN491@inflate
$LN145@inflate:

; 1052 :             }
; 1053 :             state->back = 0;

  01600	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01603	c7 80 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+7112], 0
$LN137@inflate:

; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  0160d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01610	ba 01 00 00 00	 mov	 edx, 1
  01615	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  01618	d3 e2		 shl	 edx, cl
  0161a	83 ea 01	 sub	 edx, 1
  0161d	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  01620	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01623	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  01626	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  01629	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  0162c	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01630	3b 45 e4	 cmp	 eax, DWORD PTR _bits$[ebp]
  01633	77 02		 ja	 SHORT $LN134@inflate
  01635	eb 3d		 jmp	 SHORT $LN136@inflate
$LN134@inflate:

; 1057 :                 PULLBYTE();

  01637	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0163b	75 05		 jne	 SHORT $LN131@inflate
  0163d	e9 72 08 00 00	 jmp	 $inf_leave$77798
$LN131@inflate:
  01642	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01645	83 e9 01	 sub	 ecx, 1
  01648	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  0164b	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  0164e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01651	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01654	d3 e0		 shl	 eax, cl
  01656	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01659	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  0165c	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  0165f	83 c1 01	 add	 ecx, 1
  01662	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  01665	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01668	83 c2 08	 add	 edx, 8
  0166b	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0166e	33 c0		 xor	 eax, eax
  01670	75 c5		 jne	 SHORT $LN134@inflate

; 1058 :             }

  01672	eb 99		 jmp	 SHORT $LN137@inflate
$LN136@inflate:

; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  01674	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  01678	85 c9		 test	 ecx, ecx
  0167a	0f 84 c5 00 00
	00		 je	 $LN119@inflate
  01680	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  01684	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  0168a	0f 85 b5 00 00
	00		 jne	 $LN119@inflate

; 1060 :                 last = here;

  01690	8b 45 f4	 mov	 eax, DWORD PTR _here$[ebp]
  01693	89 45 f8	 mov	 DWORD PTR _last$[ebp], eax
$LN129@inflate:

; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +
; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];

  01696	0f b7 55 fa	 movzx	 edx, WORD PTR _last$[ebp+2]
  0169a	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0169e	0f b6 45 f8	 movzx	 eax, BYTE PTR _last$[ebp]
  016a2	03 c8		 add	 ecx, eax
  016a4	b8 01 00 00 00	 mov	 eax, 1
  016a9	d3 e0		 shl	 eax, cl
  016ab	83 e8 01	 sub	 eax, 1
  016ae	23 45 d4	 and	 eax, DWORD PTR _hold$[ebp]
  016b1	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  016b5	d3 e8		 shr	 eax, cl
  016b7	03 d0		 add	 edx, eax
  016b9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  016bc	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  016bf	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  016c2	89 4d f4	 mov	 DWORD PTR _here$[ebp], ecx

; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  016c5	0f b6 55 f9	 movzx	 edx, BYTE PTR _last$[ebp+1]
  016c9	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  016cd	03 d0		 add	 edx, eax
  016cf	3b 55 e4	 cmp	 edx, DWORD PTR _bits$[ebp]
  016d2	77 02		 ja	 SHORT $LN126@inflate
  016d4	eb 3d		 jmp	 SHORT $LN122@inflate
$LN126@inflate:

; 1065 :                     PULLBYTE();

  016d6	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  016da	75 05		 jne	 SHORT $LN123@inflate
  016dc	e9 d3 07 00 00	 jmp	 $inf_leave$77798
$LN123@inflate:
  016e1	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  016e4	83 e9 01	 sub	 ecx, 1
  016e7	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  016ea	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  016ed	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  016f0	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  016f3	d3 e0		 shl	 eax, cl
  016f5	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  016f8	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  016fb	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  016fe	83 c1 01	 add	 ecx, 1
  01701	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  01704	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01707	83 c2 08	 add	 edx, 8
  0170a	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0170d	33 c0		 xor	 eax, eax
  0170f	75 c5		 jne	 SHORT $LN126@inflate

; 1066 :                 }

  01711	eb 83		 jmp	 SHORT $LN129@inflate
$LN122@inflate:

; 1067 :                 DROPBITS(last.bits);

  01713	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01717	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  0171a	d3 ea		 shr	 edx, cl
  0171c	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0171f	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  01723	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01726	2b c8		 sub	 ecx, eax
  01728	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0172b	33 d2		 xor	 edx, edx
  0172d	75 e4		 jne	 SHORT $LN122@inflate

; 1068 :                 state->back += last.bits;

  0172f	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  01733	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01736	03 81 c8 1b 00
	00		 add	 eax, DWORD PTR [ecx+7112]
  0173c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0173f	89 82 c8 1b 00
	00		 mov	 DWORD PTR [edx+7112], eax
$LN119@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);

  01745	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01749	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  0174c	d3 e8		 shr	 eax, cl
  0174e	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01751	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01755	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01758	2b d1		 sub	 edx, ecx
  0175a	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0175d	33 c0		 xor	 eax, eax
  0175f	75 e4		 jne	 SHORT $LN119@inflate

; 1071 :             state->back += here.bits;

  01761	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01765	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01768	03 8a c8 1b 00
	00		 add	 ecx, DWORD PTR [edx+7112]
  0176e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01771	89 88 c8 1b 00
	00		 mov	 DWORD PTR [eax+7112], ecx

; 1072 :             state->length = (unsigned)here.val;

  01777	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  0177b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0177e	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 1073 :             if ((int)(here.op) == 0) {

  01781	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  01785	85 c0		 test	 eax, eax
  01787	75 0f		 jne	 SHORT $LN116@inflate

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  01789	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0178c	c7 41 04 4d 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16205 ; 00003f4dH

; 1078 :                 break;

  01793	e9 17 07 00 00	 jmp	 $LN491@inflate
$LN116@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  01798	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  0179c	83 e2 20	 and	 edx, 32			; 00000020H
  0179f	74 1c		 je	 SHORT $LN115@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  017a1	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  017a4	c7 80 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+7112], -1

; 1083 :                 state->mode = TYPE;

  017ae	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  017b1	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 1084 :                 break;

  017b8	e9 f2 06 00 00	 jmp	 $LN491@inflate
$LN115@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  017bd	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  017c1	83 e2 40	 and	 edx, 64			; 00000040H
  017c4	74 19		 je	 SHORT $LN114@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  017c6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  017c9	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 1088 :                 state->mode = BAD;

  017d0	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  017d3	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 1089 :                 break;

  017da	e9 d0 06 00 00	 jmp	 $LN491@inflate
$LN114@inflate:

; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  017df	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  017e3	83 e2 0f	 and	 edx, 15			; 0000000fH
  017e6	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  017e9	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 1092 :             state->mode = LENEXT;

  017ec	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  017ef	c7 41 04 49 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16201 ; 00003f49H
$LN113@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  017f6	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  017f9	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  017fd	0f 84 a1 00 00
	00		 je	 $LN112@inflate
$LN108@inflate:

; 1095 :                 NEEDBITS(state->extra);

  01803	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01806	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01809	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  0180c	73 3d		 jae	 SHORT $LN110@inflate
$LN106@inflate:
  0180e	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01812	75 05		 jne	 SHORT $LN103@inflate
  01814	e9 9b 06 00 00	 jmp	 $inf_leave$77798
$LN103@inflate:
  01819	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  0181c	83 ea 01	 sub	 edx, 1
  0181f	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  01822	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01825	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01828	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0182b	d3 e2		 shl	 edx, cl
  0182d	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01830	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01833	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01836	83 c0 01	 add	 eax, 1
  01839	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  0183c	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0183f	83 c1 08	 add	 ecx, 8
  01842	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01845	33 d2		 xor	 edx, edx
  01847	75 c5		 jne	 SHORT $LN106@inflate
  01849	eb b8		 jmp	 SHORT $LN108@inflate
$LN110@inflate:
  0184b	33 c0		 xor	 eax, eax
  0184d	75 b4		 jne	 SHORT $LN108@inflate

; 1096 :                 state->length += BITS(state->extra);

  0184f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01852	ba 01 00 00 00	 mov	 edx, 1
  01857	8b 49 4c	 mov	 ecx, DWORD PTR [ecx+76]
  0185a	d3 e2		 shl	 edx, cl
  0185c	83 ea 01	 sub	 edx, 1
  0185f	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  01862	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01865	03 50 44	 add	 edx, DWORD PTR [eax+68]
  01868	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0186b	89 51 44	 mov	 DWORD PTR [ecx+68], edx
$LN102@inflate:

; 1097 :                 DROPBITS(state->extra);

  0186e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01871	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01874	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  01877	d3 e8		 shr	 eax, cl
  01879	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  0187c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0187f	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01882	2b 51 4c	 sub	 edx, DWORD PTR [ecx+76]
  01885	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01888	33 c0		 xor	 eax, eax
  0188a	75 e2		 jne	 SHORT $LN102@inflate

; 1098 :                 state->back += state->extra;

  0188c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0188f	8b 91 c8 1b 00
	00		 mov	 edx, DWORD PTR [ecx+7112]
  01895	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01898	03 50 4c	 add	 edx, DWORD PTR [eax+76]
  0189b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0189e	89 91 c8 1b 00
	00		 mov	 DWORD PTR [ecx+7112], edx
$LN112@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  018a4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  018a7	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  018aa	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  018ad	89 8a cc 1b 00
	00		 mov	 DWORD PTR [edx+7116], ecx

; 1102 :             state->mode = DIST;

  018b3	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  018b6	c7 42 04 4a 3f
	00 00		 mov	 DWORD PTR [edx+4], 16202 ; 00003f4aH
$LN98@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  018bd	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  018c0	ba 01 00 00 00	 mov	 edx, 1
  018c5	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  018c8	d3 e2		 shl	 edx, cl
  018ca	83 ea 01	 sub	 edx, 1
  018cd	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  018d0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  018d3	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  018d6	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  018d9	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  018dc	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  018e0	3b 45 e4	 cmp	 eax, DWORD PTR _bits$[ebp]
  018e3	77 02		 ja	 SHORT $LN95@inflate
  018e5	eb 3d		 jmp	 SHORT $LN97@inflate
$LN95@inflate:

; 1107 :                 PULLBYTE();

  018e7	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  018eb	75 05		 jne	 SHORT $LN92@inflate
  018ed	e9 c2 05 00 00	 jmp	 $inf_leave$77798
$LN92@inflate:
  018f2	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  018f5	83 e9 01	 sub	 ecx, 1
  018f8	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  018fb	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  018fe	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01901	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01904	d3 e0		 shl	 eax, cl
  01906	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01909	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  0190c	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  0190f	83 c1 01	 add	 ecx, 1
  01912	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  01915	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01918	83 c2 08	 add	 edx, 8
  0191b	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0191e	33 c0		 xor	 eax, eax
  01920	75 c5		 jne	 SHORT $LN95@inflate

; 1108 :             }

  01922	eb 99		 jmp	 SHORT $LN98@inflate
$LN97@inflate:

; 1109 :             if ((here.op & 0xf0) == 0) {

  01924	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  01928	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  0192e	0f 85 b5 00 00
	00		 jne	 $LN80@inflate

; 1110 :                 last = here;

  01934	8b 55 f4	 mov	 edx, DWORD PTR _here$[ebp]
  01937	89 55 f8	 mov	 DWORD PTR _last$[ebp], edx
$LN90@inflate:

; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +
; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];

  0193a	0f b7 45 fa	 movzx	 eax, WORD PTR _last$[ebp+2]
  0193e	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01942	0f b6 55 f8	 movzx	 edx, BYTE PTR _last$[ebp]
  01946	03 ca		 add	 ecx, edx
  01948	ba 01 00 00 00	 mov	 edx, 1
  0194d	d3 e2		 shl	 edx, cl
  0194f	83 ea 01	 sub	 edx, 1
  01952	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  01955	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01959	d3 ea		 shr	 edx, cl
  0195b	03 c2		 add	 eax, edx
  0195d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01960	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  01963	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  01966	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax

; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01969	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0196d	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  01971	03 ca		 add	 ecx, edx
  01973	3b 4d e4	 cmp	 ecx, DWORD PTR _bits$[ebp]
  01976	77 02		 ja	 SHORT $LN87@inflate
  01978	eb 3d		 jmp	 SHORT $LN83@inflate
$LN87@inflate:

; 1115 :                     PULLBYTE();

  0197a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0197e	75 05		 jne	 SHORT $LN84@inflate
  01980	e9 2f 05 00 00	 jmp	 $inf_leave$77798
$LN84@inflate:
  01985	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  01988	83 e8 01	 sub	 eax, 1
  0198b	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0198e	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  01991	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  01994	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01997	d3 e2		 shl	 edx, cl
  01999	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  0199c	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0199f	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  019a2	83 c0 01	 add	 eax, 1
  019a5	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  019a8	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  019ab	83 c1 08	 add	 ecx, 8
  019ae	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  019b1	33 d2		 xor	 edx, edx
  019b3	75 c5		 jne	 SHORT $LN87@inflate

; 1116 :                 }

  019b5	eb 83		 jmp	 SHORT $LN90@inflate
$LN83@inflate:

; 1117 :                 DROPBITS(last.bits);

  019b7	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  019bb	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  019be	d3 e8		 shr	 eax, cl
  019c0	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  019c3	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  019c7	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  019ca	2b d1		 sub	 edx, ecx
  019cc	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  019cf	33 c0		 xor	 eax, eax
  019d1	75 e4		 jne	 SHORT $LN83@inflate

; 1118 :                 state->back += last.bits;

  019d3	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  019d7	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  019da	03 8a c8 1b 00
	00		 add	 ecx, DWORD PTR [edx+7112]
  019e0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  019e3	89 88 c8 1b 00
	00		 mov	 DWORD PTR [eax+7112], ecx
$LN80@inflate:

; 1119 :             }
; 1120 :             DROPBITS(here.bits);

  019e9	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  019ed	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  019f0	d3 ea		 shr	 edx, cl
  019f2	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  019f5	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  019f9	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  019fc	2b c8		 sub	 ecx, eax
  019fe	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01a01	33 d2		 xor	 edx, edx
  01a03	75 e4		 jne	 SHORT $LN80@inflate

; 1121 :             state->back += here.bits;

  01a05	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01a09	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a0c	03 81 c8 1b 00
	00		 add	 eax, DWORD PTR [ecx+7112]
  01a12	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01a15	89 82 c8 1b 00
	00		 mov	 DWORD PTR [edx+7112], eax

; 1122 :             if (here.op & 64) {

  01a1b	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  01a1f	83 e0 40	 and	 eax, 64			; 00000040H
  01a22	74 19		 je	 SHORT $LN77@inflate

; 1123 :                 strm->msg = (char *)"invalid distance code";

  01a24	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01a27	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 1124 :                 state->mode = BAD;

  01a2e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01a31	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 1125 :                 break;

  01a38	e9 72 04 00 00	 jmp	 $LN491@inflate
$LN77@inflate:

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  01a3d	0f b7 45 f6	 movzx	 eax, WORD PTR _here$[ebp+2]
  01a41	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a44	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  01a47	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  01a4b	83 e2 0f	 and	 edx, 15			; 0000000fH
  01a4e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a51	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 1129 :             state->mode = DISTEXT;

  01a54	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a57	c7 41 04 4b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16203 ; 00003f4bH
$LN76@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  01a5e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01a61	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  01a65	0f 84 a1 00 00
	00		 je	 $LN75@inflate
$LN71@inflate:

; 1132 :                 NEEDBITS(state->extra);

  01a6b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a6e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01a71	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  01a74	73 3d		 jae	 SHORT $LN73@inflate
$LN69@inflate:
  01a76	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01a7a	75 05		 jne	 SHORT $LN66@inflate
  01a7c	e9 33 04 00 00	 jmp	 $inf_leave$77798
$LN66@inflate:
  01a81	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01a84	83 ea 01	 sub	 edx, 1
  01a87	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  01a8a	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01a8d	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01a90	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01a93	d3 e2		 shl	 edx, cl
  01a95	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01a98	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01a9b	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01a9e	83 c0 01	 add	 eax, 1
  01aa1	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  01aa4	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01aa7	83 c1 08	 add	 ecx, 8
  01aaa	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01aad	33 d2		 xor	 edx, edx
  01aaf	75 c5		 jne	 SHORT $LN69@inflate
  01ab1	eb b8		 jmp	 SHORT $LN71@inflate
$LN73@inflate:
  01ab3	33 c0		 xor	 eax, eax
  01ab5	75 b4		 jne	 SHORT $LN71@inflate

; 1133 :                 state->offset += BITS(state->extra);

  01ab7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01aba	ba 01 00 00 00	 mov	 edx, 1
  01abf	8b 49 4c	 mov	 ecx, DWORD PTR [ecx+76]
  01ac2	d3 e2		 shl	 edx, cl
  01ac4	83 ea 01	 sub	 edx, 1
  01ac7	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  01aca	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01acd	03 50 48	 add	 edx, DWORD PTR [eax+72]
  01ad0	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01ad3	89 51 48	 mov	 DWORD PTR [ecx+72], edx
$LN65@inflate:

; 1134 :                 DROPBITS(state->extra);

  01ad6	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01ad9	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01adc	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  01adf	d3 e8		 shr	 eax, cl
  01ae1	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01ae4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01ae7	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01aea	2b 51 4c	 sub	 edx, DWORD PTR [ecx+76]
  01aed	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01af0	33 c0		 xor	 eax, eax
  01af2	75 e2		 jne	 SHORT $LN65@inflate

; 1135 :                 state->back += state->extra;

  01af4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01af7	8b 91 c8 1b 00
	00		 mov	 edx, DWORD PTR [ecx+7112]
  01afd	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01b00	03 50 4c	 add	 edx, DWORD PTR [eax+76]
  01b03	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b06	89 91 c8 1b 00
	00		 mov	 DWORD PTR [ecx+7112], edx
$LN75@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  01b0c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b0f	c7 42 04 4c 3f
	00 00		 mov	 DWORD PTR [edx+4], 16204 ; 00003f4cH
$LN62@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  01b16	83 7d e0 00	 cmp	 DWORD PTR _left$[ebp], 0
  01b1a	75 05		 jne	 SHORT $LN61@inflate
  01b1c	e9 93 03 00 00	 jmp	 $inf_leave$77798
$LN61@inflate:

; 1148 :             copy = out - left;

  01b21	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01b24	2b 45 e0	 sub	 eax, DWORD PTR _left$[ebp]
  01b27	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax

; 1149 :             if (state->offset > copy) {         /* copy from window */

  01b2a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b2d	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  01b30	3b 55 cc	 cmp	 edx, DWORD PTR _copy$[ebp]
  01b33	0f 86 8f 00 00
	00		 jbe	 $LN60@inflate

; 1150 :                 copy = state->offset - copy;

  01b39	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01b3c	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  01b3f	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  01b42	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 1151 :                 if (copy > state->whave) {

  01b45	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b48	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01b4b	3b 42 30	 cmp	 eax, DWORD PTR [edx+48]
  01b4e	76 25		 jbe	 SHORT $LN59@inflate

; 1152 :                     if (state->sane) {

  01b50	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b53	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  01b5a	74 19		 je	 SHORT $LN59@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  01b5c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01b5f	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 1154 :                         state->mode = BAD;

  01b66	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01b69	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 1155 :                         break;

  01b70	e9 3a 03 00 00	 jmp	 $LN491@inflate
$LN59@inflate:

; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  01b75	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b78	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  01b7b	3b 51 34	 cmp	 edx, DWORD PTR [ecx+52]
  01b7e	76 20		 jbe	 SHORT $LN57@inflate

; 1172 :                     copy -= state->wnext;

  01b80	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01b83	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  01b86	2b 48 34	 sub	 ecx, DWORD PTR [eax+52]
  01b89	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 1173 :                     from = state->window + (state->wsize - copy);

  01b8c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b8f	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01b92	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  01b95	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b98	03 41 38	 add	 eax, DWORD PTR [ecx+56]
  01b9b	89 45 c8	 mov	 DWORD PTR _from$[ebp], eax

; 1174 :                 }
; 1175 :                 else

  01b9e	eb 12		 jmp	 SHORT $LN56@inflate
$LN57@inflate:

; 1176 :                     from = state->window + (state->wnext - copy);

  01ba0	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01ba3	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  01ba6	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  01ba9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01bac	03 41 38	 add	 eax, DWORD PTR [ecx+56]
  01baf	89 45 c8	 mov	 DWORD PTR _from$[ebp], eax
$LN56@inflate:

; 1177 :                 if (copy > state->length) copy = state->length;

  01bb2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01bb5	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01bb8	3b 42 44	 cmp	 eax, DWORD PTR [edx+68]
  01bbb	76 09		 jbe	 SHORT $LN55@inflate
  01bbd	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01bc0	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  01bc3	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
$LN55@inflate:

; 1178 :             }
; 1179 :             else {                              /* copy from output */

  01bc6	eb 15		 jmp	 SHORT $LN54@inflate
$LN60@inflate:

; 1180 :                 from = put - state->offset;

  01bc8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01bcb	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01bce	2b 48 48	 sub	 ecx, DWORD PTR [eax+72]
  01bd1	89 4d c8	 mov	 DWORD PTR _from$[ebp], ecx

; 1181 :                 copy = state->length;

  01bd4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01bd7	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  01bda	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN54@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;

  01bdd	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  01be0	3b 4d e0	 cmp	 ecx, DWORD PTR _left$[ebp]
  01be3	76 06		 jbe	 SHORT $LN53@inflate
  01be5	8b 55 e0	 mov	 edx, DWORD PTR _left$[ebp]
  01be8	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
$LN53@inflate:

; 1184 :             left -= copy;

  01beb	8b 45 e0	 mov	 eax, DWORD PTR _left$[ebp]
  01bee	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  01bf1	89 45 e0	 mov	 DWORD PTR _left$[ebp], eax

; 1185 :             state->length -= copy;

  01bf4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01bf7	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  01bfa	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  01bfd	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01c00	89 50 44	 mov	 DWORD PTR [eax+68], edx
$LN52@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  01c03	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01c06	8b 55 c8	 mov	 edx, DWORD PTR _from$[ebp]
  01c09	8a 02		 mov	 al, BYTE PTR [edx]
  01c0b	88 01		 mov	 BYTE PTR [ecx], al
  01c0d	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01c10	83 c1 01	 add	 ecx, 1
  01c13	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  01c16	8b 55 c8	 mov	 edx, DWORD PTR _from$[ebp]
  01c19	83 c2 01	 add	 edx, 1
  01c1c	89 55 c8	 mov	 DWORD PTR _from$[ebp], edx

; 1188 :             } while (--copy);

  01c1f	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01c22	83 e8 01	 sub	 eax, 1
  01c25	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
  01c28	75 d9		 jne	 SHORT $LN52@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  01c2a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01c2d	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  01c31	75 0a		 jne	 SHORT $LN49@inflate
  01c33	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01c36	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H
$LN49@inflate:

; 1190 :             break;

  01c3d	e9 6d 02 00 00	 jmp	 $LN491@inflate
$LN48@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  01c42	83 7d e0 00	 cmp	 DWORD PTR _left$[ebp], 0
  01c46	75 05		 jne	 SHORT $LN47@inflate
  01c48	e9 67 02 00 00	 jmp	 $inf_leave$77798
$LN47@inflate:

; 1193 :             *put++ = (unsigned char)(state->length);

  01c4d	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01c50	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01c53	8a 51 44	 mov	 dl, BYTE PTR [ecx+68]
  01c56	88 10		 mov	 BYTE PTR [eax], dl
  01c58	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01c5b	83 c0 01	 add	 eax, 1
  01c5e	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax

; 1194 :             left--;

  01c61	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  01c64	83 e9 01	 sub	 ecx, 1
  01c67	89 4d e0	 mov	 DWORD PTR _left$[ebp], ecx

; 1195 :             state->mode = LEN;

  01c6a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01c6d	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H

; 1196 :             break;

  01c74	e9 36 02 00 00	 jmp	 $LN491@inflate
$LN46@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  01c79	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01c7c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  01c80	0f 84 5f 01 00
	00		 je	 $LN45@inflate
$LN41@inflate:

; 1199 :                 NEEDBITS(32);

  01c86	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  01c8a	73 3d		 jae	 SHORT $LN43@inflate
$LN39@inflate:
  01c8c	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01c90	75 05		 jne	 SHORT $LN36@inflate
  01c92	e9 1d 02 00 00	 jmp	 $inf_leave$77798
$LN36@inflate:
  01c97	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01c9a	83 e9 01	 sub	 ecx, 1
  01c9d	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01ca0	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  01ca3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01ca6	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01ca9	d3 e0		 shl	 eax, cl
  01cab	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01cae	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01cb1	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  01cb4	83 c1 01	 add	 ecx, 1
  01cb7	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  01cba	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01cbd	83 c2 08	 add	 edx, 8
  01cc0	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01cc3	33 c0		 xor	 eax, eax
  01cc5	75 c5		 jne	 SHORT $LN39@inflate
  01cc7	eb bd		 jmp	 SHORT $LN41@inflate
$LN43@inflate:
  01cc9	33 c9		 xor	 ecx, ecx
  01ccb	75 b9		 jne	 SHORT $LN41@inflate

; 1200 :                 out -= left;

  01ccd	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  01cd0	2b 55 e0	 sub	 edx, DWORD PTR _left$[ebp]
  01cd3	89 55 c4	 mov	 DWORD PTR _out$[ebp], edx

; 1201 :                 strm->total_out += out;

  01cd6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01cd9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01cdc	03 4d c4	 add	 ecx, DWORD PTR _out$[ebp]
  01cdf	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01ce2	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1202 :                 state->total += out;

  01ce5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01ce8	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  01ceb	03 4d c4	 add	 ecx, DWORD PTR _out$[ebp]
  01cee	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01cf1	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 1203 :                 if ((state->wrap & 4) && out)

  01cf4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01cf7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01cfa	83 e1 04	 and	 ecx, 4
  01cfd	74 57		 je	 SHORT $LN35@inflate
  01cff	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01d03	74 51		 je	 SHORT $LN35@inflate

; 1204 :                     strm->adler = state->check =
; 1205 :                         UPDATE(state->check, put - out, out);

  01d05	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01d08	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  01d0c	74 1c		 je	 SHORT $LN505@inflate
  01d0e	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01d11	50		 push	 eax
  01d12	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01d15	2b 4d c4	 sub	 ecx, DWORD PTR _out$[ebp]
  01d18	51		 push	 ecx
  01d19	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01d1c	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  01d1f	50		 push	 eax
  01d20	e8 00 00 00 00	 call	 _crc32@12
  01d25	89 45 b0	 mov	 DWORD PTR tv1310[ebp], eax
  01d28	eb 1a		 jmp	 SHORT $LN506@inflate
$LN505@inflate:
  01d2a	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01d2d	51		 push	 ecx
  01d2e	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01d31	2b 55 c4	 sub	 edx, DWORD PTR _out$[ebp]
  01d34	52		 push	 edx
  01d35	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01d38	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  01d3b	51		 push	 ecx
  01d3c	e8 00 00 00 00	 call	 _adler32@12
  01d41	89 45 b0	 mov	 DWORD PTR tv1310[ebp], eax
$LN506@inflate:
  01d44	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01d47	8b 45 b0	 mov	 eax, DWORD PTR tv1310[ebp]
  01d4a	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  01d4d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01d50	8b 55 b0	 mov	 edx, DWORD PTR tv1310[ebp]
  01d53	89 51 30	 mov	 DWORD PTR [ecx+48], edx
$LN35@inflate:

; 1206 :                 out = left;

  01d56	8b 45 e0	 mov	 eax, DWORD PTR _left$[ebp]
  01d59	89 45 c4	 mov	 DWORD PTR _out$[ebp], eax

; 1207 :                 if ((state->wrap & 4) && (
; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {

  01d5c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01d5f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01d62	83 e2 04	 and	 edx, 4
  01d65	74 6c		 je	 SHORT $LN33@inflate
  01d67	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01d6a	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  01d6e	74 08		 je	 SHORT $LN507@inflate
  01d70	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  01d73	89 4d ac	 mov	 DWORD PTR tv1327[ebp], ecx
  01d76	eb 37		 jmp	 SHORT $LN508@inflate
$LN507@inflate:
  01d78	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01d7b	c1 ea 18	 shr	 edx, 24			; 00000018H
  01d7e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01d84	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01d87	c1 e8 08	 shr	 eax, 8
  01d8a	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01d8f	03 d0		 add	 edx, eax
  01d91	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  01d94	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  01d9a	c1 e1 08	 shl	 ecx, 8
  01d9d	03 d1		 add	 edx, ecx
  01d9f	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01da2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01da7	c1 e0 18	 shl	 eax, 24			; 00000018H
  01daa	03 d0		 add	 edx, eax
  01dac	89 55 ac	 mov	 DWORD PTR tv1327[ebp], edx
$LN508@inflate:
  01daf	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01db2	8b 55 ac	 mov	 edx, DWORD PTR tv1327[ebp]
  01db5	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  01db8	74 19		 je	 SHORT $LN33@inflate

; 1212 :                     strm->msg = (char *)"incorrect data check";

  01dba	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01dbd	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@

; 1213 :                     state->mode = BAD;

  01dc4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01dc7	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 1214 :                     break;

  01dce	e9 dc 00 00 00	 jmp	 $LN491@inflate
$LN33@inflate:

; 1215 :                 }
; 1216 :                 INITBITS();

  01dd3	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  01dda	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  01de1	33 d2		 xor	 edx, edx
  01de3	75 ee		 jne	 SHORT $LN33@inflate
$LN45@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  01de5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01de8	c7 40 04 4f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16207 ; 00003f4fH
$LN30@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  01def	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01df2	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  01df6	0f 84 83 00 00
	00		 je	 $LN29@inflate
  01dfc	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01dff	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  01e03	74 7a		 je	 SHORT $LN29@inflate
$LN25@inflate:

; 1223 :                 NEEDBITS(32);

  01e05	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  01e09	73 3d		 jae	 SHORT $LN27@inflate
$LN23@inflate:
  01e0b	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01e0f	75 05		 jne	 SHORT $LN20@inflate
  01e11	e9 9e 00 00 00	 jmp	 $inf_leave$77798
$LN20@inflate:
  01e16	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  01e19	83 e8 01	 sub	 eax, 1
  01e1c	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01e1f	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  01e22	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  01e25	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01e28	d3 e2		 shl	 edx, cl
  01e2a	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01e2d	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01e30	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01e33	83 c0 01	 add	 eax, 1
  01e36	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  01e39	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01e3c	83 c1 08	 add	 ecx, 8
  01e3f	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01e42	33 d2		 xor	 edx, edx
  01e44	75 c5		 jne	 SHORT $LN23@inflate
  01e46	eb bd		 jmp	 SHORT $LN25@inflate
$LN27@inflate:
  01e48	33 c0		 xor	 eax, eax
  01e4a	75 b9		 jne	 SHORT $LN25@inflate

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  01e4c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01e4f	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01e52	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  01e55	74 16		 je	 SHORT $LN18@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  01e57	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01e5a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@

; 1226 :                     state->mode = BAD;

  01e61	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01e64	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 1227 :                     break;

  01e6b	eb 42		 jmp	 SHORT $LN491@inflate
$LN18@inflate:

; 1228 :                 }
; 1229 :                 INITBITS();

  01e6d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  01e74	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  01e7b	33 d2		 xor	 edx, edx
  01e7d	75 ee		 jne	 SHORT $LN18@inflate
$LN29@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  01e7f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01e82	c7 40 04 50 3f
	00 00		 mov	 DWORD PTR [eax+4], 16208 ; 00003f50H
$LN15@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  01e89	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 1236 :             goto inf_leave;

  01e90	eb 22		 jmp	 SHORT $inf_leave$77798
$LN14@inflate:

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  01e92	c7 45 d8 fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH

; 1239 :             goto inf_leave;

  01e99	eb 19		 jmp	 SHORT $inf_leave$77798
$LN13@inflate:

; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;

  01e9b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01ea0	e9 de 01 00 00	 jmp	 $LN501@inflate
$LN12@inflate:

; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;

  01ea5	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  01eaa	e9 d4 01 00 00	 jmp	 $LN501@inflate
$LN491@inflate:

; 1245 :         }

  01eaf	e9 f1 e1 ff ff	 jmp	 $LN494@inflate
$inf_leave$77798:

; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  01eb4	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01eb7	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01eba	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  01ebd	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01ec0	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  01ec3	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01ec6	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01ec9	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01ecc	89 02		 mov	 DWORD PTR [edx], eax
  01ece	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01ed1	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01ed4	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01ed7	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01eda	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  01edd	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  01ee0	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01ee3	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  01ee6	89 42 40	 mov	 DWORD PTR [edx+64], eax
  01ee9	33 c9		 xor	 ecx, ecx
  01eeb	75 c7		 jne	 SHORT $inf_leave$77798

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))

  01eed	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01ef0	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  01ef4	75 29		 jne	 SHORT $LN7@inflate
  01ef6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01ef9	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01efc	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  01eff	74 53		 je	 SHORT $LN8@inflate
  01f01	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01f04	81 7a 04 51 3f
	00 00		 cmp	 DWORD PTR [edx+4], 16209 ; 00003f51H
  01f0b	7d 47		 jge	 SHORT $LN8@inflate
  01f0d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01f10	81 78 04 4e 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16206 ; 00003f4eH
  01f17	7c 06		 jl	 SHORT $LN7@inflate
  01f19	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01f1d	74 35		 je	 SHORT $LN8@inflate
$LN7@inflate:

; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  01f1f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01f22	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  01f25	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  01f28	52		 push	 edx
  01f29	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01f2c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01f2f	51		 push	 ecx
  01f30	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01f33	52		 push	 edx
  01f34	e8 00 00 00 00	 call	 _updatewindow
  01f39	83 c4 0c	 add	 esp, 12			; 0000000cH
  01f3c	85 c0		 test	 eax, eax
  01f3e	74 14		 je	 SHORT $LN8@inflate

; 1258 :             state->mode = MEM;

  01f40	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01f43	c7 40 04 52 3f
	00 00		 mov	 DWORD PTR [eax+4], 16210 ; 00003f52H

; 1259 :             return Z_MEM_ERROR;

  01f4a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01f4f	e9 2f 01 00 00	 jmp	 $LN501@inflate
$LN8@inflate:

; 1260 :         }
; 1261 :     in -= strm->avail_in;

  01f54	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01f57	8b 55 ec	 mov	 edx, DWORD PTR _in$[ebp]
  01f5a	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  01f5d	89 55 ec	 mov	 DWORD PTR _in$[ebp], edx

; 1262 :     out -= strm->avail_out;

  01f60	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01f63	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01f66	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  01f69	89 4d c4	 mov	 DWORD PTR _out$[ebp], ecx

; 1263 :     strm->total_in += in;

  01f6c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01f6f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01f72	03 45 ec	 add	 eax, DWORD PTR _in$[ebp]
  01f75	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01f78	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1264 :     strm->total_out += out;

  01f7b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01f7e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01f81	03 45 c4	 add	 eax, DWORD PTR _out$[ebp]
  01f84	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01f87	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1265 :     state->total += out;

  01f8a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01f8d	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  01f90	03 45 c4	 add	 eax, DWORD PTR _out$[ebp]
  01f93	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01f96	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 1266 :     if ((state->wrap & 4) && out)

  01f99	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01f9c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01f9f	83 e0 04	 and	 eax, 4
  01fa2	74 5d		 je	 SHORT $LN4@inflate
  01fa4	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01fa8	74 57		 je	 SHORT $LN4@inflate

; 1267 :         strm->adler = state->check =
; 1268 :             UPDATE(state->check, strm->next_out - out, out);

  01faa	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01fad	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  01fb1	74 1f		 je	 SHORT $LN509@inflate
  01fb3	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  01fb6	52		 push	 edx
  01fb7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01fba	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01fbd	2b 4d c4	 sub	 ecx, DWORD PTR _out$[ebp]
  01fc0	51		 push	 ecx
  01fc1	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01fc4	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  01fc7	50		 push	 eax
  01fc8	e8 00 00 00 00	 call	 _crc32@12
  01fcd	89 45 a8	 mov	 DWORD PTR tv1415[ebp], eax
  01fd0	eb 1d		 jmp	 SHORT $LN510@inflate
$LN509@inflate:
  01fd2	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01fd5	51		 push	 ecx
  01fd6	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01fd9	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01fdc	2b 45 c4	 sub	 eax, DWORD PTR _out$[ebp]
  01fdf	50		 push	 eax
  01fe0	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01fe3	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  01fe6	52		 push	 edx
  01fe7	e8 00 00 00 00	 call	 _adler32@12
  01fec	89 45 a8	 mov	 DWORD PTR tv1415[ebp], eax
$LN510@inflate:
  01fef	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01ff2	8b 4d a8	 mov	 ecx, DWORD PTR tv1415[ebp]
  01ff5	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  01ff8	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01ffb	8b 45 a8	 mov	 eax, DWORD PTR tv1415[ebp]
  01ffe	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN4@inflate:

; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +
; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  02001	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  02004	81 79 04 47 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  0200b	74 15		 je	 SHORT $LN511@inflate
  0200d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  02010	81 7a 04 42 3f
	00 00		 cmp	 DWORD PTR [edx+4], 16194 ; 00003f42H
  02017	74 09		 je	 SHORT $LN511@inflate
  02019	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv1430[ebp], 0
  02020	eb 07		 jmp	 SHORT $LN512@inflate
$LN511@inflate:
  02022	c7 45 a4 00 01
	00 00		 mov	 DWORD PTR tv1430[ebp], 256 ; 00000100H
$LN512@inflate:
  02029	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0202c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0202f	f7 d9		 neg	 ecx
  02031	1b c9		 sbb	 ecx, ecx
  02033	83 e1 40	 and	 ecx, 64			; 00000040H
  02036	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  02039	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0203c	03 c1		 add	 eax, ecx
  0203e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  02041	33 d2		 xor	 edx, edx
  02043	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  0204a	0f 95 c2	 setne	 dl
  0204d	83 ea 01	 sub	 edx, 1
  02050	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  02056	03 45 a4	 add	 eax, DWORD PTR tv1430[ebp]
  02059	03 d0		 add	 edx, eax
  0205b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0205e	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  02061	83 7d ec 00	 cmp	 DWORD PTR _in$[ebp], 0
  02065	75 06		 jne	 SHORT $LN1@inflate
  02067	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  0206b	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  0206d	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  02071	75 0d		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  02073	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  02077	75 07		 jne	 SHORT $LN3@inflate

; 1273 :         ret = Z_BUF_ERROR;

  02079	c7 45 d8 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
$LN3@inflate:

; 1274 :     return ret;

  02080	8b 45 d8	 mov	 eax, DWORD PTR _ret$[ebp]
$LN501@inflate:

; 1275 : }

  02083	8b e5		 mov	 esp, ebp
  02085	5d		 pop	 ebp
  02086	c2 08 00	 ret	 8
  02089	8d 49 00	 npad	 3
$LN513@inflate:
  0208c	00 00 00 00	 DD	 $LN490@inflate
  02090	00 00 00 00	 DD	 $LN454@inflate
  02094	00 00 00 00	 DD	 $LN434@inflate
  02098	00 00 00 00	 DD	 $LN416@inflate
  0209c	00 00 00 00	 DD	 $LN402@inflate
  020a0	00 00 00 00	 DD	 $LN381@inflate
  020a4	00 00 00 00	 DD	 $LN374@inflate
  020a8	00 00 00 00	 DD	 $LN362@inflate
  020ac	00 00 00 00	 DD	 $LN350@inflate
  020b0	00 00 00 00	 DD	 $LN330@inflate
  020b4	00 00 00 00	 DD	 $LN321@inflate
  020b8	00 00 00 00	 DD	 $LN316@inflate
  020bc	00 00 00 00	 DD	 $LN313@inflate
  020c0	00 00 00 00	 DD	 $LN282@inflate
  020c4	00 00 00 00	 DD	 $LN265@inflate
  020c8	00 00 00 00	 DD	 $LN264@inflate
  020cc	00 00 00 00	 DD	 $LN255@inflate
  020d0	00 00 00 00	 DD	 $LN237@inflate
  020d4	00 00 00 00	 DD	 $LN219@inflate
  020d8	00 00 00 00	 DD	 $LN147@inflate
  020dc	00 00 00 00	 DD	 $LN146@inflate
  020e0	00 00 00 00	 DD	 $LN113@inflate
  020e4	00 00 00 00	 DD	 $LN98@inflate
  020e8	00 00 00 00	 DD	 $LN76@inflate
  020ec	00 00 00 00	 DD	 $LN62@inflate
  020f0	00 00 00 00	 DD	 $LN48@inflate
  020f4	00 00 00 00	 DD	 $LN46@inflate
  020f8	00 00 00 00	 DD	 $LN30@inflate
  020fc	00 00 00 00	 DD	 $LN15@inflate
  02100	00 00 00 00	 DD	 $LN14@inflate
  02104	00 00 00 00	 DD	 $LN13@inflate
$LN514@inflate:
  02108	00 00 00 00	 DD	 $LN294@inflate
  0210c	00 00 00 00	 DD	 $LN293@inflate
  02110	00 00 00 00	 DD	 $LN288@inflate
  02114	00 00 00 00	 DD	 $LN287@inflate
_inflate@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateReset@4
; Function compile flags: /Odtp
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 07		 je	 SHORT $LN1@inflateRes@2
  00014	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00019	eb 30		 jmp	 SHORT $LN2@inflateRes@2
$LN1@inflateRes@2:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00021	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 151  :     state->wsize = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00027	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 152  :     state->whave = 0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00031	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 153  :     state->wnext = 0;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0003b	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 154  :     return inflateResetKeep(strm);

  00042	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _inflateResetKeep@4
$LN2@inflateRes@2:

; 155  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
_inflateReset@4 ENDP
PUBLIC	_inflateSync@4
; Function compile flags: /Odtp
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_state$ = -20						; size = 4
_out$ = -16						; size = 4
_buf$ = -12						; size = 4
_len$ = -8						; size = 4
_in$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	83 c4 04	 add	 esp, 4
  00012	85 c0		 test	 eax, eax
  00014	74 0a		 je	 SHORT $LN6@inflateSyn@2
  00016	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001b	e9 67 01 00 00	 jmp	 $LN7@inflateSyn@2
$LN6@inflateSyn@2:

; 1410 :     state = (struct inflate_state FAR *)strm->state;

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00023	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00026	89 55 ec	 mov	 DWORD PTR _state$[ebp], edx

; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00029	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00030	75 13		 jne	 SHORT $LN5@inflateSyn@2
  00032	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	83 79 40 08	 cmp	 DWORD PTR [ecx+64], 8
  00039	73 0a		 jae	 SHORT $LN5@inflateSyn@2
  0003b	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00040	e9 42 01 00 00	 jmp	 $LN7@inflateSyn@2
$LN5@inflateSyn@2:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00045	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00048	81 7a 04 53 3f
	00 00		 cmp	 DWORD PTR [edx+4], 16211 ; 00003f53H
  0004f	0f 84 9f 00 00
	00		 je	 $LN4@inflateSyn@2

; 1415 :         state->mode = SYNC;

  00055	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00058	c7 40 04 53 3f
	00 00		 mov	 DWORD PTR [eax+4], 16211 ; 00003f53H

; 1416 :         state->hold <<= state->bits & 7;

  0005f	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00062	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  00065	83 e1 07	 and	 ecx, 7
  00068	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0006b	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0006e	d3 e0		 shl	 eax, cl
  00070	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00073	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 1417 :         state->bits -= state->bits & 7;

  00076	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00079	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0007c	83 e0 07	 and	 eax, 7
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00082	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00085	2b d0		 sub	 edx, eax
  00087	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0008a	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 1418 :         len = 0;

  0008d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN3@inflateSyn@2:

; 1419 :         while (state->bits >= 8) {

  00094	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00097	83 79 40 08	 cmp	 DWORD PTR [ecx+64], 8
  0009b	72 36		 jb	 SHORT $LN2@inflateSyn@2

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  0009d	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  000a0	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000a3	8a 48 3c	 mov	 cl, BYTE PTR [eax+60]
  000a6	88 4c 15 f4	 mov	 BYTE PTR _buf$[ebp+edx], cl
  000aa	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  000ad	83 c2 01	 add	 edx, 1
  000b0	89 55 f8	 mov	 DWORD PTR _len$[ebp], edx

; 1421 :             state->hold >>= 8;

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000b6	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000b9	c1 e9 08	 shr	 ecx, 8
  000bc	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000bf	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 1422 :             state->bits -= 8;

  000c2	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000c5	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000c8	83 e9 08	 sub	 ecx, 8
  000cb	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000ce	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 1423 :         }

  000d1	eb c1		 jmp	 SHORT $LN3@inflateSyn@2
$LN2@inflateSyn@2:

; 1424 :         state->have = 0;

  000d3	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000d6	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0

; 1425 :         syncsearch(&(state->have), buf, len);

  000dd	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  000e0	51		 push	 ecx
  000e1	8d 55 f4	 lea	 edx, DWORD PTR _buf$[ebp]
  000e4	52		 push	 edx
  000e5	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000e8	83 c0 6c	 add	 eax, 108		; 0000006cH
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _syncsearch
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@inflateSyn@2:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000f7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fa	52		 push	 edx
  000fb	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00100	51		 push	 ecx
  00101	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00104	83 c2 6c	 add	 edx, 108		; 0000006cH
  00107	52		 push	 edx
  00108	e8 00 00 00 00	 call	 _syncsearch
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00110	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 1430 :     strm->avail_in -= len;

  00113	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00116	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00119	2b 4d f8	 sub	 ecx, DWORD PTR _len$[ebp]
  0011c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0011f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1431 :     strm->next_in += len;

  00122	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00125	8b 08		 mov	 ecx, DWORD PTR [eax]
  00127	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  0012a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0012d	89 0a		 mov	 DWORD PTR [edx], ecx

; 1432 :     strm->total_in += len;

  0012f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00132	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00135	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00138	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0013b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  0013e	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00141	83 78 6c 04	 cmp	 DWORD PTR [eax+108], 4
  00145	74 07		 je	 SHORT $LN1@inflateSyn@2
  00147	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0014c	eb 39		 jmp	 SHORT $LN7@inflateSyn@2
$LN1@inflateSyn@2:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  0014e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00151	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00154	89 55 fc	 mov	 DWORD PTR _in$[ebp], edx
  00157	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0015a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0015d	89 4d f0	 mov	 DWORD PTR _out$[ebp], ecx

; 1437 :     inflateReset(strm);

  00160	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00163	52		 push	 edx
  00164	e8 00 00 00 00	 call	 _inflateReset@4

; 1438 :     strm->total_in = in;  strm->total_out = out;

  00169	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0016c	8b 4d fc	 mov	 ecx, DWORD PTR _in$[ebp]
  0016f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00172	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00175	8b 45 f0	 mov	 eax, DWORD PTR _out$[ebp]
  00178	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1439 :     state->mode = TYPE;

  0017b	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0017e	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 1440 :     return Z_OK;

  00185	33 c0		 xor	 eax, eax
$LN7@inflateSyn@2:

; 1441 : }

  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateReset2@8
; Function compile flags: /Odtp
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_state$ = -8						; size = 4
_wrap$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	83 c4 04	 add	 esp, 4
  00012	85 c0		 test	 eax, eax
  00014	74 0a		 je	 SHORT $LN7@inflateRes@3
  00016	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001b	e9 a6 00 00 00	 jmp	 $LN8@inflateRes@3
$LN7@inflateRes@3:

; 166  :     state = (struct inflate_state FAR *)strm->state;

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00023	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00026	89 55 f8	 mov	 DWORD PTR _state$[ebp], edx

; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00029	83 7d 0c 00	 cmp	 DWORD PTR _windowBits$[ebp], 0
  0002d	7d 11		 jge	 SHORT $LN6@inflateRes@3

; 170  :         wrap = 0;

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _wrap$[ebp], 0

; 171  :         windowBits = -windowBits;

  00036	8b 45 0c	 mov	 eax, DWORD PTR _windowBits$[ebp]
  00039	f7 d8		 neg	 eax
  0003b	89 45 0c	 mov	 DWORD PTR _windowBits$[ebp], eax

; 172  :     }
; 173  :     else {

  0003e	eb 1b		 jmp	 SHORT $LN5@inflateRes@3
$LN6@inflateRes@3:

; 174  :         wrap = (windowBits >> 4) + 5;

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  00043	c1 f9 04	 sar	 ecx, 4
  00046	83 c1 05	 add	 ecx, 5
  00049	89 4d fc	 mov	 DWORD PTR _wrap$[ebp], ecx

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  0004c	83 7d 0c 30	 cmp	 DWORD PTR _windowBits$[ebp], 48 ; 00000030H
  00050	7d 09		 jge	 SHORT $LN5@inflateRes@3

; 177  :             windowBits &= 15;

  00052	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  00055	83 e2 0f	 and	 edx, 15			; 0000000fH
  00058	89 55 0c	 mov	 DWORD PTR _windowBits$[ebp], edx
$LN5@inflateRes@3:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  0005b	83 7d 0c 00	 cmp	 DWORD PTR _windowBits$[ebp], 0
  0005f	74 13		 je	 SHORT $LN3@inflateRes@3
  00061	83 7d 0c 08	 cmp	 DWORD PTR _windowBits$[ebp], 8
  00065	7c 06		 jl	 SHORT $LN2@inflateRes@3
  00067	83 7d 0c 0f	 cmp	 DWORD PTR _windowBits$[ebp], 15 ; 0000000fH
  0006b	7e 07		 jle	 SHORT $LN3@inflateRes@3
$LN2@inflateRes@3:

; 183  :         return Z_STREAM_ERROR;

  0006d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00072	eb 52		 jmp	 SHORT $LN8@inflateRes@3
$LN3@inflateRes@3:

; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00074	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00077	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0007b	74 2e		 je	 SHORT $LN1@inflateRes@3
  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00080	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00083	3b 55 0c	 cmp	 edx, DWORD PTR _windowBits$[ebp]
  00086	74 23		 je	 SHORT $LN1@inflateRes@3

; 185  :         ZFREE(strm, state->window);

  00088	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0008b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0008e	51		 push	 ecx
  0008f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00092	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00095	50		 push	 eax
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00099	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0009c	ff d2		 call	 edx
  0009e	83 c4 08	 add	 esp, 8

; 186  :         state->window = Z_NULL;

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a4	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN1@inflateRes@3:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;

  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000ae	8b 55 fc	 mov	 edx, DWORD PTR _wrap$[ebp]
  000b1	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 191  :     state->wbits = (unsigned)windowBits;

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000ba	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 192  :     return inflateReset(strm);

  000bd	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 _inflateReset@4
$LN8@inflateRes@3:

; 193  : }

  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
PUBLIC	_inflateInit2_@16
; Function compile flags: /Odtp
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 205  :         stream_size != (int)(sizeof(z_stream)))

  00006	83 7d 10 00	 cmp	 DWORD PTR _version$[ebp], 0
  0000a	74 17		 je	 SHORT $LN6@inflateIni
  0000c	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  0000f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00012	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR ??_C@_06CJNJFBNP@1?42?411?$AA@
  00019	3b ca		 cmp	 ecx, edx
  0001b	75 06		 jne	 SHORT $LN6@inflateIni
  0001d	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  00021	74 0a		 je	 SHORT $LN7@inflateIni
$LN6@inflateIni:

; 206  :         return Z_VERSION_ERROR;

  00023	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00028	e9 d1 00 00 00	 jmp	 $LN8@inflateIni
$LN7@inflateIni:

; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002d	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00031	75 0a		 jne	 SHORT $LN5@inflateIni
  00033	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00038	e9 c1 00 00 00	 jmp	 $LN8@inflateIni
$LN5@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */

  0003d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00040	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 209  :     if (strm->zalloc == (alloc_func)0) {

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0004a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0004e	75 14		 jne	 SHORT $LN4@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;

  00050	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00053	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _zcalloc

; 214  :         strm->opaque = (voidpf)0;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0005d	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$LN4@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00067	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0006b	75 0a		 jne	 SHORT $LN3@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  0006d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00070	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _zcfree
$LN3@inflateIni:

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)
; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00077	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0007c	6a 01		 push	 1
  0007e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00081	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00084	51		 push	 ecx
  00085	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00088	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0008b	ff d0		 call	 eax
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00093	83 7d f8 00	 cmp	 DWORD PTR _state$[ebp], 0
  00097	75 07		 jne	 SHORT $LN2@inflateIni
  00099	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0009e	eb 5e		 jmp	 SHORT $LN8@inflateIni
$LN2@inflateIni:

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;

  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000a6	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 228  :     state->strm = strm;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000af	89 08		 mov	 DWORD PTR [eax], ecx

; 229  :     state->window = Z_NULL;

  000b1	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000b4	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000be	c7 40 04 34 3f
	00 00		 mov	 DWORD PTR [eax+4], 16180 ; 00003f34H

; 231  :     ret = inflateReset2(strm, windowBits);

  000c5	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _inflateReset2@8
  000d2	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 232  :     if (ret != Z_OK) {

  000d5	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000d9	74 20		 je	 SHORT $LN1@inflateIni

; 233  :         ZFREE(strm, state);

  000db	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000de	50		 push	 eax
  000df	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000e2	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000e5	52		 push	 edx
  000e6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000e9	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000ec	ff d1		 call	 ecx
  000ee	83 c4 08	 add	 esp, 8

; 234  :         strm->state = Z_NULL;

  000f1	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000f4	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
$LN1@inflateIni:

; 235  :     }
; 236  :     return ret;

  000fb	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN8@inflateIni:

; 237  : }

  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
PUBLIC	_inflateInit_@12
; Function compile flags: /Odtp
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	8b 45 10	 mov	 eax, DWORD PTR _stream_size$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _version$[ebp]
  0000a	51		 push	 ecx
  0000b	6a 0f		 push	 15			; 0000000fH
  0000d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _inflateInit2_@16

; 245  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
END
