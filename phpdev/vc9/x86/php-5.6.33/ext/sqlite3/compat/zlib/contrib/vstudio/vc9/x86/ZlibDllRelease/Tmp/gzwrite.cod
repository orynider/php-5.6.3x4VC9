; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\gzwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
EXTRN	_vsnprintf:PROC
EXTRN	_write:PROC
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
; Function compile flags: /Odtp
; File c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\gzwrite.c
;	COMDAT _gz_init
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_init PROC						; COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20   :     int ret;
; 21   :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 64	 add	 eax, 100		; 00000064H
  0000c	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 22   : 
; 23   :     /* allocate input buffer (double size for gzprintf) */
; 24   :     state->in = (unsigned char *)malloc(state->want << 1);

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00012	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00015	d1 e2		 shl	 edx, 1
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _malloc
  0001d	83 c4 04	 add	 esp, 4
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00023	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 25   :     if (state->in == NULL) {

  00026	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00029	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0002d	75 1b		 jne	 SHORT $LN5@gz_init

; 26   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00034	6a fc		 push	 -4			; fffffffcH
  00036	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _gz_error
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27   :         return -1;

  00042	83 c8 ff	 or	 eax, -1
  00045	e9 1a 01 00 00	 jmp	 $LN6@gz_init
$LN5@gz_init:

; 28   :     }
; 29   : 
; 30   :     /* only need output buffer and deflate state if compressing */
; 31   :     if (!state->direct) {

  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0004d	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  00051	0f 85 d2 00 00
	00		 jne	 $LN4@gz_init

; 32   :         /* allocate output buffer */
; 33   :         state->out = (unsigned char *)malloc(state->want);

  00057	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0005a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _malloc
  00063	83 c4 04	 add	 esp, 4
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00069	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 34   :         if (state->out == NULL) {

  0006c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0006f	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00073	75 2a		 jne	 SHORT $LN3@gz_init

; 35   :             free(state->in);

  00075	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00078	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 _free
  00081	83 c4 04	 add	 esp, 4

; 36   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00089	6a fc		 push	 -4			; fffffffcH
  0008b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _gz_error
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 37   :             return -1;

  00097	83 c8 ff	 or	 eax, -1
  0009a	e9 c5 00 00 00	 jmp	 $LN6@gz_init
$LN3@gz_init:

; 38   :         }
; 39   : 
; 40   :         /* allocate deflate memory, set up for gzip compression */
; 41   :         strm->zalloc = Z_NULL;

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000a2	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 42   :         strm->zfree = Z_NULL;

  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000ac	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 43   :         strm->opaque = Z_NULL;

  000b3	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000b6	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0

; 44   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 45   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);

  000bd	6a 38		 push	 56			; 00000038H
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411?$AA@
  000c4	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c7	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000ca	51		 push	 ecx
  000cb	6a 08		 push	 8
  000cd	6a 1f		 push	 31			; 0000001fH
  000cf	6a 08		 push	 8
  000d1	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d4	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  000d7	50		 push	 eax
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _deflateInit2_@32
  000e1	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 46   :         if (ret != Z_OK) {

  000e4	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000e8	74 36		 je	 SHORT $LN2@gz_init

; 47   :             free(state->out);

  000ea	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ed	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 _free
  000f6	83 c4 04	 add	 esp, 4

; 48   :             free(state->in);

  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000fc	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 _free
  00105	83 c4 04	 add	 esp, 4

; 49   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  0010d	6a fc		 push	 -4			; fffffffcH
  0010f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _gz_error
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH

; 50   :             return -1;

  0011b	83 c8 ff	 or	 eax, -1
  0011e	eb 44		 jmp	 SHORT $LN6@gz_init
$LN2@gz_init:

; 51   :         }
; 52   :         strm->next_in = NULL;

  00120	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00123	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN4@gz_init:

; 53   :     }
; 54   : 
; 55   :     /* mark state as initialized */
; 56   :     state->size = state->want;

  00129	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0012c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0012f	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00132	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 57   : 
; 58   :     /* initialize write buffer if compressing */
; 59   :     if (!state->direct) {

  00135	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00138	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  0013c	75 24		 jne	 SHORT $LN1@gz_init

; 60   :         strm->avail_out = state->size;

  0013e	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00141	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00144	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00147	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 61   :         strm->next_out = state->out;

  0014a	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  0014d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00150	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00153	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 62   :         state->x.next = strm->next_out;

  00156	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00159	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0015c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0015f	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN1@gz_init:

; 63   :     }
; 64   :     return 0;

  00162	33 c0		 xor	 eax, eax
$LN6@gz_init:

; 65   : }

  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
_gz_init ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_comp
_TEXT	SEGMENT
tv141 = -32						; size = 4
tv77 = -28						; size = 4
_max$ = -24						; size = 4
_writ$ = -20						; size = 4
_ret$ = -16						; size = 4
_strm$ = -12						; size = 4
_have$ = -8						; size = 4
_put$ = -4						; size = 4
_state$ = 8						; size = 4
_flush$ = 12						; size = 4
_gz_comp PROC						; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 77   :     int ret, writ;
; 78   :     unsigned have, put, max = ((unsigned)-1 >> 2) + 1;

  00006	c7 45 e8 00 00
	00 40		 mov	 DWORD PTR _max$[ebp], 1073741824 ; 40000000H

; 79   :     z_streamp strm = &(state->strm);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00010	83 c0 64	 add	 eax, 100		; 00000064H
  00013	89 45 f4	 mov	 DWORD PTR _strm$[ebp], eax

; 80   : 
; 81   :     /* allocate memory if this is the first time through */
; 82   :     if (state->size == 0 && gz_init(state) == -1)

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00019	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  0001d	75 19		 jne	 SHORT $LN17@gz_comp
  0001f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 _gz_init
  00028	83 c4 04	 add	 esp, 4
  0002b	83 f8 ff	 cmp	 eax, -1
  0002e	75 08		 jne	 SHORT $LN17@gz_comp

; 83   :         return -1;

  00030	83 c8 ff	 or	 eax, -1
  00033	e9 fc 01 00 00	 jmp	 $LN18@gz_comp
$LN17@gz_comp:

; 84   : 
; 85   :     /* write directly if requested */
; 86   :     if (state->direct) {

  00038	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0003b	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0003f	0f 84 a0 00 00
	00		 je	 $LN16@gz_comp
$LN15@gz_comp:

; 87   :         while (strm->avail_in) {

  00045	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00048	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0004c	0f 84 8c 00 00
	00		 je	 $LN14@gz_comp

; 88   :             put = strm->avail_in > max ? max : strm->avail_in;

  00052	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00055	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00058	3b 45 e8	 cmp	 eax, DWORD PTR _max$[ebp]
  0005b	76 08		 jbe	 SHORT $LN20@gz_comp
  0005d	8b 4d e8	 mov	 ecx, DWORD PTR _max$[ebp]
  00060	89 4d e4	 mov	 DWORD PTR tv77[ebp], ecx
  00063	eb 09		 jmp	 SHORT $LN21@gz_comp
$LN20@gz_comp:
  00065	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  00068	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006b	89 45 e4	 mov	 DWORD PTR tv77[ebp], eax
$LN21@gz_comp:
  0006e	8b 4d e4	 mov	 ecx, DWORD PTR tv77[ebp]
  00071	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx

; 89   :             writ = write(state->fd, strm->next_in, put);

  00074	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00077	52		 push	 edx
  00078	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	51		 push	 ecx
  0007e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00081	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _write
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	89 45 ec	 mov	 DWORD PTR _writ$[ebp], eax

; 90   :             if (writ < 0) {

  00090	83 7d ec 00	 cmp	 DWORD PTR _writ$[ebp], 0
  00094	7d 27		 jge	 SHORT $LN13@gz_comp

; 91   :                 gz_error(state, Z_ERRNO, zstrerror());

  00096	e8 00 00 00 00	 call	 __errno
  0009b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 _strerror
  000a3	83 c4 04	 add	 esp, 4
  000a6	50		 push	 eax
  000a7	6a ff		 push	 -1
  000a9	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 _gz_error
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 92   :                 return -1;

  000b5	83 c8 ff	 or	 eax, -1
  000b8	e9 77 01 00 00	 jmp	 $LN18@gz_comp
$LN13@gz_comp:

; 93   :             }
; 94   :             strm->avail_in -= (unsigned)writ;

  000bd	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	2b 4d ec	 sub	 ecx, DWORD PTR _writ$[ebp]
  000c6	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  000c9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 95   :             strm->next_in += writ;

  000cc	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  000cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d1	03 4d ec	 add	 ecx, DWORD PTR _writ$[ebp]
  000d4	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  000d7	89 0a		 mov	 DWORD PTR [edx], ecx

; 96   :         }

  000d9	e9 67 ff ff ff	 jmp	 $LN15@gz_comp
$LN14@gz_comp:

; 97   :         return 0;

  000de	33 c0		 xor	 eax, eax
  000e0	e9 4f 01 00 00	 jmp	 $LN18@gz_comp
$LN16@gz_comp:

; 98   :     }
; 99   : 
; 100  :     /* run deflate() on provided input until it produces no more output */
; 101  :     ret = Z_OK;

  000e5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN12@gz_comp:

; 102  :     do {
; 103  :         /* write out current buffer contents if full, or if flushing, but if
; 104  :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 105  :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 106  :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  000ec	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  000ef	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000f3	74 1a		 je	 SHORT $LN6@gz_comp
  000f5	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  000f9	0f 84 db 00 00
	00		 je	 $LN9@gz_comp
  000ff	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  00103	75 0a		 jne	 SHORT $LN6@gz_comp
  00105	83 7d f0 01	 cmp	 DWORD PTR _ret$[ebp], 1
  00109	0f 85 cb 00 00
	00		 jne	 $LN9@gz_comp
$LN6@gz_comp:

; 107  :             while (strm->next_out > state->x.next) {

  0010f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00112	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00115	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00118	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0011b	0f 86 8c 00 00
	00		 jbe	 $LN5@gz_comp

; 108  :                 put = strm->next_out - state->x.next > (int)max ? max :
; 109  :                       (unsigned)(strm->next_out - state->x.next);

  00121	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00124	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00127	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0012a	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0012d	3b 45 e8	 cmp	 eax, DWORD PTR _max$[ebp]
  00130	7e 08		 jle	 SHORT $LN22@gz_comp
  00132	8b 4d e8	 mov	 ecx, DWORD PTR _max$[ebp]
  00135	89 4d e0	 mov	 DWORD PTR tv141[ebp], ecx
  00138	eb 0f		 jmp	 SHORT $LN23@gz_comp
$LN22@gz_comp:
  0013a	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0013d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00140	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00143	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00146	89 4d e0	 mov	 DWORD PTR tv141[ebp], ecx
$LN23@gz_comp:
  00149	8b 55 e0	 mov	 edx, DWORD PTR tv141[ebp]
  0014c	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 110  :                 writ = write(state->fd, state->x.next, put);

  0014f	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  00152	50		 push	 eax
  00153	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00156	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00159	52		 push	 edx
  0015a	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0015d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00160	51		 push	 ecx
  00161	e8 00 00 00 00	 call	 _write
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH
  00169	89 45 ec	 mov	 DWORD PTR _writ$[ebp], eax

; 111  :                 if (writ < 0) {

  0016c	83 7d ec 00	 cmp	 DWORD PTR _writ$[ebp], 0
  00170	7d 27		 jge	 SHORT $LN4@gz_comp

; 112  :                     gz_error(state, Z_ERRNO, zstrerror());

  00172	e8 00 00 00 00	 call	 __errno
  00177	8b 10		 mov	 edx, DWORD PTR [eax]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 _strerror
  0017f	83 c4 04	 add	 esp, 4
  00182	50		 push	 eax
  00183	6a ff		 push	 -1
  00185	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 _gz_error
  0018e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 113  :                     return -1;

  00191	83 c8 ff	 or	 eax, -1
  00194	e9 9b 00 00 00	 jmp	 $LN18@gz_comp
$LN4@gz_comp:

; 114  :                 }
; 115  :                 state->x.next += writ;

  00199	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0019c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0019f	03 55 ec	 add	 edx, DWORD PTR _writ$[ebp]
  001a2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001a5	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 116  :             }

  001a8	e9 62 ff ff ff	 jmp	 $LN6@gz_comp
$LN5@gz_comp:

; 117  :             if (strm->avail_out == 0) {

  001ad	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  001b0	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  001b4	75 24		 jne	 SHORT $LN9@gz_comp

; 118  :                 strm->avail_out = state->size;

  001b6	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  001b9	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001bc	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001bf	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 119  :                 strm->next_out = state->out;

  001c2	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  001c5	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001c8	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001cb	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 120  :                 state->x.next = state->out;

  001ce	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001d1	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001d4	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001d7	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN9@gz_comp:

; 121  :             }
; 122  :         }
; 123  : 
; 124  :         /* compress */
; 125  :         have = strm->avail_out;

  001da	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  001dd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001e0	89 45 f8	 mov	 DWORD PTR _have$[ebp], eax

; 126  :         ret = deflate(strm, flush);

  001e3	8b 4d 0c	 mov	 ecx, DWORD PTR _flush$[ebp]
  001e6	51		 push	 ecx
  001e7	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  001ea	52		 push	 edx
  001eb	e8 00 00 00 00	 call	 _deflate@8
  001f0	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax

; 127  :         if (ret == Z_STREAM_ERROR) {

  001f3	83 7d f0 fe	 cmp	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  001f7	75 18		 jne	 SHORT $LN2@gz_comp

; 128  :             gz_error(state, Z_STREAM_ERROR,
; 129  :                       "internal error: deflate stream corrupt");

  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  001fe	6a fe		 push	 -2			; fffffffeH
  00200	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 _gz_error
  00209	83 c4 0c	 add	 esp, 12			; 0000000cH

; 130  :             return -1;

  0020c	83 c8 ff	 or	 eax, -1
  0020f	eb 23		 jmp	 SHORT $LN18@gz_comp
$LN2@gz_comp:

; 131  :         }
; 132  :         have -= strm->avail_out;

  00211	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00214	8b 55 f8	 mov	 edx, DWORD PTR _have$[ebp]
  00217	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  0021a	89 55 f8	 mov	 DWORD PTR _have$[ebp], edx

; 133  :     } while (have);

  0021d	0f 85 c9 fe ff
	ff		 jne	 $LN12@gz_comp

; 134  : 
; 135  :     /* if that completed a deflate stream, allow another to start */
; 136  :     if (flush == Z_FINISH)

  00223	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  00227	75 09		 jne	 SHORT $LN1@gz_comp

; 137  :         deflateReset(strm);

  00229	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 _deflateReset@4
$LN1@gz_comp:

; 138  : 
; 139  :     /* all done, no errors */
; 140  :     return 0;

  00232	33 c0		 xor	 eax, eax
$LN18@gz_comp:

; 141  : }

  00234	8b e5		 mov	 esp, ebp
  00236	5d		 pop	 ebp
  00237	c3		 ret	 0
_gz_comp ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_zero
_TEXT	SEGMENT
tv78 = -24						; size = 4
tv140 = -20						; size = 8
_strm$ = -12						; size = 4
_n$ = -8						; size = 4
_first$ = -4						; size = 4
_state$ = 8						; size = 4
_len$ = 12						; size = 8
_gz_zero PROC						; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 149  :     int first;
; 150  :     unsigned n;
; 151  :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 64	 add	 eax, 100		; 00000064H
  0000c	89 45 f4	 mov	 DWORD PTR _strm$[ebp], eax

; 152  : 
; 153  :     /* consume whatever's left in the input buffer */
; 154  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00012	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00016	74 1b		 je	 SHORT $LN5@gz_zero
  00018	6a 00		 push	 0
  0001a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _gz_comp
  00023	83 c4 08	 add	 esp, 8
  00026	83 f8 ff	 cmp	 eax, -1
  00029	75 08		 jne	 SHORT $LN5@gz_zero

; 155  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1
  0002e	e9 d1 00 00 00	 jmp	 $LN6@gz_zero
$LN5@gz_zero:

; 156  : 
; 157  :     /* compress len zeros (len guaranteed > 0) */
; 158  :     first = 1;

  00033	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _first$[ebp], 1
$LN4@gz_zero:

; 159  :     while (len) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  0003d	0b 45 10	 or	 eax, DWORD PTR _len$[ebp+4]
  00040	0f 84 bc 00 00
	00		 je	 $LN3@gz_zero

; 160  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 161  :             (unsigned)len : state->size;

  00046	33 c9		 xor	 ecx, ecx
  00048	75 2b		 jne	 SHORT $LN8@gz_zero
  0004a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0004d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00050	33 c9		 xor	 ecx, ecx
  00052	89 45 ec	 mov	 DWORD PTR tv140[ebp], eax
  00055	89 4d f0	 mov	 DWORD PTR tv140[ebp+4], ecx
  00058	8b 55 f0	 mov	 edx, DWORD PTR tv140[ebp+4]
  0005b	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp+4]
  0005e	7f 15		 jg	 SHORT $LN8@gz_zero
  00060	7c 08		 jl	 SHORT $LN10@gz_zero
  00062	8b 45 ec	 mov	 eax, DWORD PTR tv140[ebp]
  00065	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00068	77 0b		 ja	 SHORT $LN8@gz_zero
$LN10@gz_zero:
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00070	89 55 e8	 mov	 DWORD PTR tv78[ebp], edx
  00073	eb 06		 jmp	 SHORT $LN9@gz_zero
$LN8@gz_zero:
  00075	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00078	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$LN9@gz_zero:
  0007b	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  0007e	89 4d f8	 mov	 DWORD PTR _n$[ebp], ecx

; 162  :         if (first) {

  00081	83 7d fc 00	 cmp	 DWORD PTR _first$[ebp], 0
  00085	74 1c		 je	 SHORT $LN2@gz_zero

; 163  :             memset(state->in, 0, n);

  00087	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  0008a	52		 push	 edx
  0008b	6a 00		 push	 0
  0008d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00090	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _memset
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  :             first = 0;

  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _first$[ebp], 0
$LN2@gz_zero:

; 165  :         }
; 166  :         strm->avail_in = n;

  000a3	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  000a6	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000a9	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 167  :         strm->next_in = state->in;

  000ac	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  000af	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b2	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000b5	89 01		 mov	 DWORD PTR [ecx], eax

; 168  :         state->x.pos += n;

  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000ba	33 d2		 xor	 edx, edx
  000bc	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000bf	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  000c2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000c5	13 c2		 adc	 eax, edx
  000c7	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ca	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  000cd	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 169  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000d0	6a 00		 push	 0
  000d2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _gz_comp
  000db	83 c4 08	 add	 esp, 8
  000de	83 f8 ff	 cmp	 eax, -1
  000e1	75 05		 jne	 SHORT $LN1@gz_zero

; 170  :             return -1;

  000e3	83 c8 ff	 or	 eax, -1
  000e6	eb 1c		 jmp	 SHORT $LN6@gz_zero
$LN1@gz_zero:

; 171  :         len -= n;

  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000eb	33 d2		 xor	 edx, edx
  000ed	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  000f0	2b c1		 sub	 eax, ecx
  000f2	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp+4]
  000f5	1b ca		 sbb	 ecx, edx
  000f7	89 45 0c	 mov	 DWORD PTR _len$[ebp], eax
  000fa	89 4d 10	 mov	 DWORD PTR _len$[ebp+4], ecx

; 172  :     }

  000fd	e9 38 ff ff ff	 jmp	 $LN4@gz_zero
$LN3@gz_zero:

; 173  :     return 0;

  00102	33 c0		 xor	 eax, eax
$LN6@gz_zero:

; 174  : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
_gz_zero ENDP
PUBLIC	_gzclose_w@4
; Function compile flags: /Odtp
;	COMDAT _gzclose_w@4
_TEXT	SEGMENT
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclose_w@4 PROC					; COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 630  :     int ret = Z_OK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00011	75 0a		 jne	 SHORT $LN8@gzclose_w

; 635  :         return Z_STREAM_ERROR;

  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	e9 f5 00 00 00	 jmp	 $LN9@gzclose_w
$LN8@gzclose_w:

; 636  :     state = (gz_statep)file;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00020	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 637  : 
; 638  :     /* check that we're writing */
; 639  :     if (state->mode != GZ_WRITE)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00026	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  0002d	74 0a		 je	 SHORT $LN7@gzclose_w

; 640  :         return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00034	e9 d9 00 00 00	 jmp	 $LN9@gzclose_w
$LN7@gzclose_w:

; 641  : 
; 642  :     /* check for seek request */
; 643  :     if (state->seek) {

  00039	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0003c	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00040	74 2f		 je	 SHORT $LN6@gzclose_w

; 644  :         state->seek = 0;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00045	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 645  :         if (gz_zero(state, state->skip) == -1)

  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0004f	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00052	52		 push	 edx
  00053	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00056	50		 push	 eax
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 _gz_zero
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	83 f8 ff	 cmp	 eax, -1
  00066	75 09		 jne	 SHORT $LN6@gzclose_w

; 646  :             ret = state->err;

  00068	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0006b	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  0006e	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
$LN6@gzclose_w:

; 647  :     }
; 648  : 
; 649  :     /* flush, free memory, and close file */
; 650  :     if (gz_comp(state, Z_FINISH) == -1)

  00071	6a 04		 push	 4
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 _gz_comp
  0007c	83 c4 08	 add	 esp, 8
  0007f	83 f8 ff	 cmp	 eax, -1
  00082	75 09		 jne	 SHORT $LN4@gzclose_w

; 651  :         ret = state->err;

  00084	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00087	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  0008a	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
$LN4@gzclose_w:

; 652  :     if (state->size) {

  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00090	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00094	74 33		 je	 SHORT $LN3@gzclose_w

; 653  :         if (!state->direct) {

  00096	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00099	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  0009d	75 1b		 jne	 SHORT $LN2@gzclose_w

; 654  :             (void)deflateEnd(&(state->strm));

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a2	83 c0 64	 add	 eax, 100		; 00000064H
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _deflateEnd@4

; 655  :             free(state->out);

  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000ae	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 _free
  000b7	83 c4 04	 add	 esp, 4
$LN2@gzclose_w:

; 656  :         }
; 657  :         free(state->in);

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000bd	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _free
  000c6	83 c4 04	 add	 esp, 4
$LN3@gzclose_w:

; 658  :     }
; 659  :     gz_error(state, Z_OK, NULL);

  000c9	6a 00		 push	 0
  000cb	6a 00		 push	 0
  000cd	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _gz_error
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 660  :     free(state->path);

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000dc	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _free
  000e5	83 c4 04	 add	 esp, 4

; 661  :     if (close(state->fd) == -1)

  000e8	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000eb	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _close
  000f4	83 c4 04	 add	 esp, 4
  000f7	83 f8 ff	 cmp	 eax, -1
  000fa	75 07		 jne	 SHORT $LN1@gzclose_w

; 662  :         ret = Z_ERRNO;

  000fc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
$LN1@gzclose_w:

; 663  :     free(state);

  00103	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00106	51		 push	 ecx
  00107	e8 00 00 00 00	 call	 _free
  0010c	83 c4 04	 add	 esp, 4

; 664  :     return ret;

  0010f	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN9@gzclose_w:

; 665  : }

  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 04 00	 ret	 4
_gzclose_w@4 ENDP
_TEXT	ENDS
PUBLIC	_gzsetparams@12
; Function compile flags: /Odtp
;	COMDAT _gzsetparams@12
_TEXT	SEGMENT
_state$ = -8						; size = 4
_strm$ = -4						; size = 4
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams@12 PROC					; COMDAT

; 589  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 590  :     gz_statep state;
; 591  :     z_streamp strm;
; 592  : 
; 593  :     /* get internal structure */
; 594  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 0a		 jne	 SHORT $LN8@gzsetparam

; 595  :         return Z_STREAM_ERROR;

  0000c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00011	e9 d4 00 00 00	 jmp	 $LN9@gzsetparam
$LN8@gzsetparam:

; 596  :     state = (gz_statep)file;

  00016	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00019	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 597  :     strm = &(state->strm);

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0001f	83 c1 64	 add	 ecx, 100		; 00000064H
  00022	89 4d fc	 mov	 DWORD PTR _strm$[ebp], ecx

; 598  : 
; 599  :     /* check that we're writing and that there's no error */
; 600  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00025	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00028	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002f	75 09		 jne	 SHORT $LN6@gzsetparam
  00031	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00034	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00038	74 0a		 je	 SHORT $LN7@gzsetparam
$LN6@gzsetparam:

; 601  :         return Z_STREAM_ERROR;

  0003a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003f	e9 a6 00 00 00	 jmp	 $LN9@gzsetparam
$LN7@gzsetparam:

; 602  : 
; 603  :     /* if no change is requested, then do nothing */
; 604  :     if (level == state->level && strategy == state->strategy)

  00044	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00047	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  0004a	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  0004d	75 12		 jne	 SHORT $LN5@gzsetparam
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00052	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  00055	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  00058	75 07		 jne	 SHORT $LN5@gzsetparam

; 605  :         return Z_OK;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 89 00 00 00	 jmp	 $LN9@gzsetparam
$LN5@gzsetparam:

; 606  : 
; 607  :     /* check for seek request */
; 608  :     if (state->seek) {

  00061	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00064	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00068	74 2e		 je	 SHORT $LN4@gzsetparam

; 609  :         state->seek = 0;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0006d	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 610  :         if (gz_zero(state, state->skip) == -1)

  00074	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00077	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0007a	52		 push	 edx
  0007b	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  0007e	50		 push	 eax
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _gz_zero
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	83 f8 ff	 cmp	 eax, -1
  0008e	75 08		 jne	 SHORT $LN4@gzsetparam

; 611  :             return state->err;

  00090	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00093	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00096	eb 52		 jmp	 SHORT $LN9@gzsetparam
$LN4@gzsetparam:

; 612  :     }
; 613  : 
; 614  :     /* change compression parameters for subsequent input */
; 615  :     if (state->size) {

  00098	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0009b	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0009f	74 35		 je	 SHORT $LN2@gzsetparam

; 616  :         /* flush previous input with previous parameters before changing */
; 617  :         if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)

  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000a4	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000a8	74 1b		 je	 SHORT $LN1@gzsetparam
  000aa	6a 05		 push	 5
  000ac	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000af	52		 push	 edx
  000b0	e8 00 00 00 00	 call	 _gz_comp
  000b5	83 c4 08	 add	 esp, 8
  000b8	83 f8 ff	 cmp	 eax, -1
  000bb	75 08		 jne	 SHORT $LN1@gzsetparam

; 618  :             return state->err;

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000c0	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  000c3	eb 25		 jmp	 SHORT $LN9@gzsetparam
$LN1@gzsetparam:

; 619  :         deflateParams(strm, level, strategy);

  000c5	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _deflateParams@12
$LN2@gzsetparam:

; 620  :     }
; 621  :     state->level = level;

  000d6	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  000dc	89 51 48	 mov	 DWORD PTR [ecx+72], edx

; 622  :     state->strategy = strategy;

  000df	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000e2	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  000e5	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 623  :     return Z_OK;

  000e8	33 c0		 xor	 eax, eax
$LN9@gzsetparam:

; 624  : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 0c 00	 ret	 12			; 0000000cH
_gzsetparams@12 ENDP
_TEXT	ENDS
PUBLIC	_gzflush@8
; Function compile flags: /Odtp
;	COMDAT _gzflush@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush@8 PROC						; COMDAT

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 557  :     gz_statep state;
; 558  : 
; 559  :     /* get internal structure */
; 560  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 0a		 jne	 SHORT $LN7@gzflush

; 561  :         return Z_STREAM_ERROR;

  0000a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0000f	e9 82 00 00 00	 jmp	 $LN8@gzflush
$LN7@gzflush:

; 562  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 563  : 
; 564  :     /* check that we're writing and that there's no error */
; 565  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  00024	75 09		 jne	 SHORT $LN5@gzflush
  00026	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00029	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0002d	74 07		 je	 SHORT $LN6@gzflush
$LN5@gzflush:

; 566  :         return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00034	eb 60		 jmp	 SHORT $LN8@gzflush
$LN6@gzflush:

; 567  : 
; 568  :     /* check flush parameter */
; 569  :     if (flush < 0 || flush > Z_FINISH)

  00036	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  0003a	7c 06		 jl	 SHORT $LN3@gzflush
  0003c	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  00040	7e 07		 jle	 SHORT $LN4@gzflush
$LN3@gzflush:

; 570  :         return Z_STREAM_ERROR;

  00042	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00047	eb 4d		 jmp	 SHORT $LN8@gzflush
$LN4@gzflush:

; 571  : 
; 572  :     /* check for seek request */
; 573  :     if (state->seek) {

  00049	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0004c	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00050	74 2e		 je	 SHORT $LN2@gzflush

; 574  :         state->seek = 0;

  00052	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00055	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 575  :         if (gz_zero(state, state->skip) == -1)

  0005c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005f	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00062	50		 push	 eax
  00063	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00066	51		 push	 ecx
  00067	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 _gz_zero
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	83 f8 ff	 cmp	 eax, -1
  00076	75 08		 jne	 SHORT $LN2@gzflush

; 576  :             return state->err;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0007b	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  0007e	eb 16		 jmp	 SHORT $LN8@gzflush
$LN2@gzflush:

; 577  :     }
; 578  : 
; 579  :     /* compress remaining data with requested flush */
; 580  :     (void)gz_comp(state, flush);

  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _flush$[ebp]
  00083	51		 push	 ecx
  00084	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 _gz_comp
  0008d	83 c4 08	 add	 esp, 8

; 581  :     return state->err;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00093	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
$LN8@gzflush:

; 582  : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 08 00	 ret	 8
_gzflush@8 ENDP
_TEXT	ENDS
PUBLIC	_gzvprintf
; Function compile flags: /Odtp
;	COMDAT _gzvprintf
_TEXT	SEGMENT
_state$ = -20						; size = 4
_len$ = -16						; size = 4
_left$ = -12						; size = 4
_next$ = -8						; size = 4
_strm$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_va$ = 16						; size = 4
_gzvprintf PROC						; COMDAT

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 381  :     int len;
; 382  :     unsigned left;
; 383  :     char *next;
; 384  :     gz_statep state;
; 385  :     z_streamp strm;
; 386  : 
; 387  :     /* get internal structure */
; 388  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 0a		 jne	 SHORT $LN11@gzvprintf

; 389  :         return Z_STREAM_ERROR;

  0000c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00011	e9 b5 01 00 00	 jmp	 $LN12@gzvprintf
$LN11@gzvprintf:

; 390  :     state = (gz_statep)file;

  00016	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00019	89 45 ec	 mov	 DWORD PTR _state$[ebp], eax

; 391  :     strm = &(state->strm);

  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0001f	83 c1 64	 add	 ecx, 100		; 00000064H
  00022	89 4d fc	 mov	 DWORD PTR _strm$[ebp], ecx

; 392  : 
; 393  :     /* check that we're writing and that there's no error */
; 394  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00025	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00028	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002f	75 09		 jne	 SHORT $LN9@gzvprintf
  00031	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00034	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00038	74 0a		 je	 SHORT $LN10@gzvprintf
$LN9@gzvprintf:

; 395  :         return Z_STREAM_ERROR;

  0003a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003f	e9 87 01 00 00	 jmp	 $LN12@gzvprintf
$LN10@gzvprintf:

; 396  : 
; 397  :     /* make sure we have some buffer space */
; 398  :     if (state->size == 0 && gz_init(state) == -1)

  00044	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00047	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  0004b	75 1c		 jne	 SHORT $LN8@gzvprintf
  0004d	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 _gz_init
  00056	83 c4 04	 add	 esp, 4
  00059	83 f8 ff	 cmp	 eax, -1
  0005c	75 0b		 jne	 SHORT $LN8@gzvprintf

; 399  :         return state->err;

  0005e	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00061	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  00064	e9 62 01 00 00	 jmp	 $LN12@gzvprintf
$LN8@gzvprintf:

; 400  : 
; 401  :     /* check for seek request */
; 402  :     if (state->seek) {

  00069	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0006c	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00070	74 31		 je	 SHORT $LN7@gzvprintf

; 403  :         state->seek = 0;

  00072	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00075	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 404  :         if (gz_zero(state, state->skip) == -1)

  0007c	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0007f	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00082	51		 push	 ecx
  00083	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  00086	52		 push	 edx
  00087	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _gz_zero
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	83 f8 ff	 cmp	 eax, -1
  00096	75 0b		 jne	 SHORT $LN7@gzvprintf

; 405  :             return state->err;

  00098	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0009b	8b 41 5c	 mov	 eax, DWORD PTR [ecx+92]
  0009e	e9 28 01 00 00	 jmp	 $LN12@gzvprintf
$LN7@gzvprintf:

; 406  :     }
; 407  : 
; 408  :     /* do the printf() into the input buffer, put length in len -- the input
; 409  :        buffer is double-sized just for this function, so there is guaranteed to
; 410  :        be state->size bytes available after the current contents */
; 411  :     if (strm->avail_in == 0)

  000a3	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000a6	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000aa	75 0b		 jne	 SHORT $LN5@gzvprintf

; 412  :         strm->next_in = state->in;

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000af	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000b2	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000b5	89 10		 mov	 DWORD PTR [eax], edx
$LN5@gzvprintf:

; 413  :     next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);

  000b7	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000bd	8b 10		 mov	 edx, DWORD PTR [eax]
  000bf	2b 51 24	 sub	 edx, DWORD PTR [ecx+36]
  000c2	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000c5	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000c8	03 ca		 add	 ecx, edx
  000ca	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000cd	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000d0	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 414  :     next[state->size - 1] = 0;

  000d3	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000d6	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000d9	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  000dc	c6 44 0a ff 00	 mov	 BYTE PTR [edx+ecx-1], 0

; 415  : #ifdef NO_vsnprintf
; 416  : #  ifdef HAS_vsprintf_void
; 417  :     (void)vsprintf(next, format, va);
; 418  :     for (len = 0; len < state->size; len++)
; 419  :         if (next[len] == 0) break;
; 420  : #  else
; 421  :     len = vsprintf(next, format, va);
; 422  : #  endif
; 423  : #else
; 424  : #  ifdef HAS_vsnprintf_void
; 425  :     (void)vsnprintf(next, state->size, format, va);
; 426  :     len = strlen(next);
; 427  : #  else
; 428  :     len = vsnprintf(next, state->size, format, va);

  000e1	8b 45 10	 mov	 eax, DWORD PTR _va$[ebp]
  000e4	50		 push	 eax
  000e5	8b 4d 0c	 mov	 ecx, DWORD PTR _format$[ebp]
  000e8	51		 push	 ecx
  000e9	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000ec	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000ef	50		 push	 eax
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 _vsnprintf
  000f9	83 c4 10	 add	 esp, 16			; 00000010H
  000fc	89 45 f0	 mov	 DWORD PTR _len$[ebp], eax

; 429  : #  endif
; 430  : #endif
; 431  : 
; 432  :     /* check that printf() results fit in buffer */
; 433  :     if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)

  000ff	83 7d f0 00	 cmp	 DWORD PTR _len$[ebp], 0
  00103	74 1d		 je	 SHORT $LN3@gzvprintf
  00105	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00108	8b 45 f0	 mov	 eax, DWORD PTR _len$[ebp]
  0010b	3b 42 1c	 cmp	 eax, DWORD PTR [edx+28]
  0010e	73 12		 jae	 SHORT $LN3@gzvprintf
  00110	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00113	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00116	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00119	0f be 4c 10 ff	 movsx	 ecx, BYTE PTR [eax+edx-1]
  0011e	85 c9		 test	 ecx, ecx
  00120	74 07		 je	 SHORT $LN4@gzvprintf
$LN3@gzvprintf:

; 434  :         return 0;

  00122	33 c0		 xor	 eax, eax
  00124	e9 a2 00 00 00	 jmp	 $LN12@gzvprintf
$LN4@gzvprintf:

; 435  : 
; 436  :     /* update buffer and position, compress first half if past that */
; 437  :     strm->avail_in += (unsigned)len;

  00129	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0012c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0012f	03 45 f0	 add	 eax, DWORD PTR _len$[ebp]
  00132	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00135	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 438  :     state->x.pos += len;

  00138	8b 45 f0	 mov	 eax, DWORD PTR _len$[ebp]
  0013b	99		 cdq
  0013c	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0013f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00142	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00145	13 ca		 adc	 ecx, edx
  00147	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0014a	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0014d	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 439  :     if (strm->avail_in >= state->size) {

  00150	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00153	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00156	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00159	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  0015c	72 6a		 jb	 SHORT $LN2@gzvprintf

; 440  :         left = strm->avail_in - state->size;

  0015e	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00161	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00164	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00167	2b 51 1c	 sub	 edx, DWORD PTR [ecx+28]
  0016a	89 55 f4	 mov	 DWORD PTR _left$[ebp], edx

; 441  :         strm->avail_in = state->size;

  0016d	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00170	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00173	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00176	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 442  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00179	6a 00		 push	 0
  0017b	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0017e	50		 push	 eax
  0017f	e8 00 00 00 00	 call	 _gz_comp
  00184	83 c4 08	 add	 esp, 8
  00187	83 f8 ff	 cmp	 eax, -1
  0018a	75 08		 jne	 SHORT $LN1@gzvprintf

; 443  :             return state->err;

  0018c	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0018f	8b 41 5c	 mov	 eax, DWORD PTR [ecx+92]
  00192	eb 37		 jmp	 SHORT $LN12@gzvprintf
$LN1@gzvprintf:

; 444  :         memcpy(state->in, state->in + state->size, left);

  00194	8b 55 f4	 mov	 edx, DWORD PTR _left$[ebp]
  00197	52		 push	 edx
  00198	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0019b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0019e	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  001a1	03 4a 1c	 add	 ecx, DWORD PTR [edx+28]
  001a4	51		 push	 ecx
  001a5	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  001a8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001ab	51		 push	 ecx
  001ac	e8 00 00 00 00	 call	 _memcpy
  001b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 445  :         strm->next_in = state->in;

  001b4	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  001b7	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  001ba	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001bd	89 0a		 mov	 DWORD PTR [edx], ecx

; 446  :         strm->avail_in = left;

  001bf	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  001c2	8b 45 f4	 mov	 eax, DWORD PTR _left$[ebp]
  001c5	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN2@gzvprintf:

; 447  :     }
; 448  :     return len;

  001c8	8b 45 f0	 mov	 eax, DWORD PTR _len$[ebp]
$LN12@gzvprintf:

; 449  : }

  001cb	8b e5		 mov	 esp, ebp
  001cd	5d		 pop	 ebp
  001ce	c3		 ret	 0
_gzvprintf ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_write
_TEXT	SEGMENT
_n$79675 = -16						; size = 4
_copy$79663 = -12					; size = 4
_have$79662 = -8					; size = 4
_put$ = -4						; size = 4
_state$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gz_write PROC						; COMDAT

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 183  :     z_size_t put = len;

  00006	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax

; 184  : 
; 185  :     /* if len is zero, avoid unnecessary operations */
; 186  :     if (len == 0)

  0000c	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00010	75 07		 jne	 SHORT $LN18@gz_write

; 187  :         return 0;

  00012	33 c0		 xor	 eax, eax
  00014	e9 ae 01 00 00	 jmp	 $LN19@gz_write
$LN18@gz_write:

; 188  : 
; 189  :     /* allocate memory if this is the first time through */
; 190  :     if (state->size == 0 && gz_init(state) == -1)

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0001c	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00020	75 18		 jne	 SHORT $LN17@gz_write
  00022	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 _gz_init
  0002b	83 c4 04	 add	 esp, 4
  0002e	83 f8 ff	 cmp	 eax, -1
  00031	75 07		 jne	 SHORT $LN17@gz_write

; 191  :         return 0;

  00033	33 c0		 xor	 eax, eax
  00035	e9 8d 01 00 00	 jmp	 $LN19@gz_write
$LN17@gz_write:

; 192  : 
; 193  :     /* check for seek request */
; 194  :     if (state->seek) {

  0003a	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0003d	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00041	74 2d		 je	 SHORT $LN16@gz_write

; 195  :         state->seek = 0;

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00046	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 196  :         if (gz_zero(state, state->skip) == -1)

  0004d	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00050	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00053	50		 push	 eax
  00054	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00057	51		 push	 ecx
  00058	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _gz_zero
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	83 f8 ff	 cmp	 eax, -1
  00067	75 07		 jne	 SHORT $LN16@gz_write

; 197  :             return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 57 01 00 00	 jmp	 $LN19@gz_write
$LN16@gz_write:

; 198  :     }
; 199  : 
; 200  :     /* for small len, copy to input buffer, otherwise compress directly */
; 201  :     if (len < state->size) {

  00070	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00073	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  00076	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  00079	0f 83 c3 00 00
	00		 jae	 $LN14@gz_write
$LN13@gz_write:

; 202  :         /* copy to input buffer, compress when full */
; 203  :         do {
; 204  :             unsigned have, copy;
; 205  : 
; 206  :             if (state->strm.avail_in == 0)

  0007f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00082	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  00086	75 0c		 jne	 SHORT $LN10@gz_write

; 207  :                 state->strm.next_in = state->in;

  00088	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0008b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0008e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00091	89 50 64	 mov	 DWORD PTR [eax+100], edx
$LN10@gz_write:

; 208  :             have = (unsigned)((state->strm.next_in + state->strm.avail_in) -
; 209  :                               state->in);

  00094	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00097	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0009a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0009d	03 4a 68	 add	 ecx, DWORD PTR [edx+104]
  000a0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a3	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  000a6	89 4d f8	 mov	 DWORD PTR _have$79662[ebp], ecx

; 210  :             copy = state->size - have;

  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000ac	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000af	2b 55 f8	 sub	 edx, DWORD PTR _have$79662[ebp]
  000b2	89 55 f4	 mov	 DWORD PTR _copy$79663[ebp], edx

; 211  :             if (copy > len)

  000b5	8b 45 f4	 mov	 eax, DWORD PTR _copy$79663[ebp]
  000b8	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  000bb	76 06		 jbe	 SHORT $LN9@gz_write

; 212  :                 copy = len;

  000bd	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  000c0	89 4d f4	 mov	 DWORD PTR _copy$79663[ebp], ecx
$LN9@gz_write:

; 213  :             memcpy(state->in + have, buf, copy);

  000c3	8b 55 f4	 mov	 edx, DWORD PTR _copy$79663[ebp]
  000c6	52		 push	 edx
  000c7	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  000ca	50		 push	 eax
  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000ce	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000d1	03 55 f8	 add	 edx, DWORD PTR _have$79662[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 _memcpy
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 214  :             state->strm.avail_in += copy;

  000dd	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000e0	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  000e3	03 4d f4	 add	 ecx, DWORD PTR _copy$79663[ebp]
  000e6	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000e9	89 4a 68	 mov	 DWORD PTR [edx+104], ecx

; 215  :             state->x.pos += copy;

  000ec	8b 45 f4	 mov	 eax, DWORD PTR _copy$79663[ebp]
  000ef	33 c9		 xor	 ecx, ecx
  000f1	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000f4	03 42 08	 add	 eax, DWORD PTR [edx+8]
  000f7	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  000fa	13 d1		 adc	 edx, ecx
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000ff	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00102	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 216  :             buf = (const char *)buf + copy;

  00105	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00108	03 55 f4	 add	 edx, DWORD PTR _copy$79663[ebp]
  0010b	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 217  :             len -= copy;

  0010e	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00111	2b 45 f4	 sub	 eax, DWORD PTR _copy$79663[ebp]
  00114	89 45 10	 mov	 DWORD PTR _len$[ebp], eax

; 218  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  00117	74 1a		 je	 SHORT $LN12@gz_write
  00119	6a 00		 push	 0
  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0011e	51		 push	 ecx
  0011f	e8 00 00 00 00	 call	 _gz_comp
  00124	83 c4 08	 add	 esp, 8
  00127	83 f8 ff	 cmp	 eax, -1
  0012a	75 07		 jne	 SHORT $LN12@gz_write

; 219  :                 return 0;

  0012c	33 c0		 xor	 eax, eax
  0012e	e9 94 00 00 00	 jmp	 $LN19@gz_write
$LN12@gz_write:

; 220  :         } while (len);

  00133	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00137	0f 85 42 ff ff
	ff		 jne	 $LN13@gz_write

; 221  :     }
; 222  :     else {

  0013d	e9 82 00 00 00	 jmp	 $LN7@gz_write
$LN14@gz_write:

; 223  :         /* consume whatever's left in the input buffer */
; 224  :         if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00142	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00145	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  00149	74 17		 je	 SHORT $LN6@gz_write
  0014b	6a 00		 push	 0
  0014d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _gz_comp
  00156	83 c4 08	 add	 esp, 8
  00159	83 f8 ff	 cmp	 eax, -1
  0015c	75 04		 jne	 SHORT $LN6@gz_write

; 225  :             return 0;

  0015e	33 c0		 xor	 eax, eax
  00160	eb 65		 jmp	 SHORT $LN19@gz_write
$LN6@gz_write:

; 226  : 
; 227  :         /* directly compress user buffer to file */
; 228  :         state->strm.next_in = (z_const Bytef *)buf;

  00162	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00165	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00168	89 51 64	 mov	 DWORD PTR [ecx+100], edx
$LN5@gz_write:

; 229  :         do {
; 230  :             unsigned n = (unsigned)-1;

  0016b	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _n$79675[ebp], -1

; 231  :             if (n > len)

  00172	8b 45 f0	 mov	 eax, DWORD PTR _n$79675[ebp]
  00175	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  00178	76 06		 jbe	 SHORT $LN2@gz_write

; 232  :                 n = len;

  0017a	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0017d	89 4d f0	 mov	 DWORD PTR _n$79675[ebp], ecx
$LN2@gz_write:

; 233  :             state->strm.avail_in = n;

  00180	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00183	8b 45 f0	 mov	 eax, DWORD PTR _n$79675[ebp]
  00186	89 42 68	 mov	 DWORD PTR [edx+104], eax

; 234  :             state->x.pos += n;

  00189	8b 4d f0	 mov	 ecx, DWORD PTR _n$79675[ebp]
  0018c	33 d2		 xor	 edx, edx
  0018e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00191	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  00194	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00197	13 c2		 adc	 eax, edx
  00199	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0019c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0019f	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 235  :             if (gz_comp(state, Z_NO_FLUSH) == -1)

  001a2	6a 00		 push	 0
  001a4	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 _gz_comp
  001ad	83 c4 08	 add	 esp, 8
  001b0	83 f8 ff	 cmp	 eax, -1
  001b3	75 04		 jne	 SHORT $LN1@gz_write

; 236  :                 return 0;

  001b5	33 c0		 xor	 eax, eax
  001b7	eb 0e		 jmp	 SHORT $LN19@gz_write
$LN1@gz_write:

; 237  :             len -= n;

  001b9	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  001bc	2b 4d f0	 sub	 ecx, DWORD PTR _n$79675[ebp]
  001bf	89 4d 10	 mov	 DWORD PTR _len$[ebp], ecx

; 238  :         } while (len);

  001c2	75 a7		 jne	 SHORT $LN5@gz_write
$LN7@gz_write:

; 239  :     }
; 240  : 
; 241  :     /* input was all buffered or compressed */
; 242  :     return put;

  001c4	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
$LN19@gz_write:

; 243  : }

  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c3		 ret	 0
_gz_write ENDP
PUBLIC	_gzprintf
; Function compile flags: /Odtp
;	COMDAT _gzprintf
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_va$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 453  :     va_list va;
; 454  :     int ret;
; 455  : 
; 456  :     va_start(va, format);

  00006	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 457  :     ret = gzvprintf(file, format, va);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _format$[ebp]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _gzvprintf
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 458  :     va_end(va);

  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 459  :     return ret;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 460  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
PUBLIC	_gzputs@8
; Function compile flags: /Odtp
;	COMDAT _gzputs@8
_TEXT	SEGMENT
tv77 = -16						; size = 4
_state$ = -12						; size = 4
_ret$ = -8						; size = 4
_len$ = -4						; size = 4
_file$ = 8						; size = 4
_str$ = 12						; size = 4
_gzputs@8 PROC						; COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 356  :     int ret;
; 357  :     z_size_t len;
; 358  :     gz_statep state;
; 359  : 
; 360  :     /* get internal structure */
; 361  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 05		 jne	 SHORT $LN3@gzputs

; 362  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	eb 64		 jmp	 SHORT $LN4@gzputs
$LN3@gzputs:

; 363  :     state = (gz_statep)file;

  00011	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00014	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 364  : 
; 365  :     /* check that we're writing and that there's no error */
; 366  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00017	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0001a	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  00021	75 09		 jne	 SHORT $LN1@gzputs
  00023	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00026	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0002a	74 05		 je	 SHORT $LN2@gzputs
$LN1@gzputs:

; 367  :         return -1;

  0002c	83 c8 ff	 or	 eax, -1
  0002f	eb 44		 jmp	 SHORT $LN4@gzputs
$LN2@gzputs:

; 368  : 
; 369  :     /* write string */
; 370  :     len = strlen(str);

  00031	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _strlen
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 371  :     ret = gz_write(state, str, len);

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 0c	 mov	 edx, DWORD PTR _str$[ebp]
  00047	52		 push	 edx
  00048	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _gz_write
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 372  :     return ret == 0 && len != 0 ? -1 : ret;

  00057	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0005b	75 0f		 jne	 SHORT $LN6@gzputs
  0005d	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00061	74 09		 je	 SHORT $LN6@gzputs
  00063	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR tv77[ebp], -1
  0006a	eb 06		 jmp	 SHORT $LN7@gzputs
$LN6@gzputs:
  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  0006f	89 4d f0	 mov	 DWORD PTR tv77[ebp], ecx
$LN7@gzputs:
  00072	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
$LN4@gzputs:

; 373  : }

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
_gzputs@8 ENDP
_TEXT	ENDS
PUBLIC	_gzputc@8
; Function compile flags: /Odtp
;	COMDAT _gzputc@8
_TEXT	SEGMENT
_state$ = -16						; size = 4
_buf$ = -9						; size = 1
_strm$ = -8						; size = 4
_have$ = -4						; size = 4
_file$ = 8						; size = 4
_c$ = 12						; size = 4
_gzputc@8 PROC						; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 308  :     unsigned have;
; 309  :     unsigned char buf[1];
; 310  :     gz_statep state;
; 311  :     z_streamp strm;
; 312  : 
; 313  :     /* get internal structure */
; 314  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN9@gzputc

; 315  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 09 01 00 00	 jmp	 $LN10@gzputc
$LN9@gzputc:

; 316  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 317  :     strm = &(state->strm);

  0001a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	83 c1 64	 add	 ecx, 100		; 00000064H
  00020	89 4d f8	 mov	 DWORD PTR _strm$[ebp], ecx

; 318  : 
; 319  :     /* check that we're writing and that there's no error */
; 320  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00023	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00026	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002d	75 09		 jne	 SHORT $LN7@gzputc
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00032	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00036	74 08		 je	 SHORT $LN8@gzputc
$LN7@gzputc:

; 321  :         return -1;

  00038	83 c8 ff	 or	 eax, -1
  0003b	e9 dd 00 00 00	 jmp	 $LN10@gzputc
$LN8@gzputc:

; 322  : 
; 323  :     /* check for seek request */
; 324  :     if (state->seek) {

  00040	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00043	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00047	74 2e		 je	 SHORT $LN6@gzputc

; 325  :         state->seek = 0;

  00049	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0004c	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 326  :         if (gz_zero(state, state->skip) == -1)

  00053	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00056	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00059	51		 push	 ecx
  0005a	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  0005d	52		 push	 edx
  0005e	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _gz_zero
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	83 f8 ff	 cmp	 eax, -1
  0006d	75 08		 jne	 SHORT $LN6@gzputc

; 327  :             return -1;

  0006f	83 c8 ff	 or	 eax, -1
  00072	e9 a6 00 00 00	 jmp	 $LN10@gzputc
$LN6@gzputc:

; 328  :     }
; 329  : 
; 330  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 331  :        initialized) */
; 332  :     if (state->size) {

  00077	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0007a	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  0007e	74 73		 je	 SHORT $LN4@gzputc

; 333  :         if (strm->avail_in == 0)

  00080	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00083	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00087	75 0b		 jne	 SHORT $LN3@gzputc

; 334  :             strm->next_in = state->in;

  00089	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0008f	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00092	89 10		 mov	 DWORD PTR [eax], edx
$LN3@gzputc:

; 335  :         have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00097	8b 08		 mov	 ecx, DWORD PTR [eax]
  00099	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  0009c	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0009f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000a2	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  000a5	89 4d fc	 mov	 DWORD PTR _have$[ebp], ecx

; 336  :         if (have < state->size) {

  000a8	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000ab	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  000ae	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  000b1	73 40		 jae	 SHORT $LN4@gzputc

; 337  :             state->in[have] = (unsigned char)c;

  000b3	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000b6	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000b9	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  000bc	8a 45 0c	 mov	 al, BYTE PTR _c$[ebp]
  000bf	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 338  :             strm->avail_in++;

  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000c5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c8	83 c2 01	 add	 edx, 1
  000cb	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  000ce	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 339  :             state->x.pos++;

  000d1	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000d4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d7	83 c2 01	 add	 edx, 1
  000da	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000dd	83 d0 00	 adc	 eax, 0
  000e0	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000e3	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000e6	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 340  :             return c & 0xff;

  000e9	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000ec	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000f1	eb 2a		 jmp	 SHORT $LN10@gzputc
$LN4@gzputc:

; 341  :         }
; 342  :     }
; 343  : 
; 344  :     /* no room in buffer or not initialized, use gz_write() */
; 345  :     buf[0] = (unsigned char)c;

  000f3	8a 55 0c	 mov	 dl, BYTE PTR _c$[ebp]
  000f6	88 55 f7	 mov	 BYTE PTR _buf$[ebp], dl

; 346  :     if (gz_write(state, buf, 1) != 1)

  000f9	6a 01		 push	 1
  000fb	8d 45 f7	 lea	 eax, DWORD PTR _buf$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00102	51		 push	 ecx
  00103	e8 00 00 00 00	 call	 _gz_write
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	83 f8 01	 cmp	 eax, 1
  0010e	74 05		 je	 SHORT $LN1@gzputc

; 347  :         return -1;

  00110	83 c8 ff	 or	 eax, -1
  00113	eb 08		 jmp	 SHORT $LN10@gzputc
$LN1@gzputc:

; 348  :     return c & 0xff;

  00115	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  00118	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
$LN10@gzputc:

; 349  : }

  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 08 00	 ret	 8
_gzputc@8 ENDP
_TEXT	ENDS
PUBLIC	_gzfwrite@16
; Function compile flags: /Odtp
;	COMDAT _gzfwrite@16
_TEXT	SEGMENT
tv82 = -12						; size = 4
_state$ = -8						; size = 4
_len$ = -4						; size = 4
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_nitems$ = 16						; size = 4
_file$ = 20						; size = 4
_gzfwrite@16 PROC					; COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 280  :     z_size_t len;
; 281  :     gz_statep state;
; 282  : 
; 283  :     /* get internal structure */
; 284  :     if (file == NULL)

  00006	83 7d 14 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 07		 jne	 SHORT $LN4@gzfwrite

; 285  :         return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	e9 81 00 00 00	 jmp	 $LN5@gzfwrite
$LN4@gzfwrite:

; 286  :     state = (gz_statep)file;

  00013	8b 45 14	 mov	 eax, DWORD PTR _file$[ebp]
  00016	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 287  : 
; 288  :     /* check that we're writing and that there's no error */
; 289  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0001c	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  00023	75 09		 jne	 SHORT $LN2@gzfwrite
  00025	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00028	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0002c	74 04		 je	 SHORT $LN3@gzfwrite
$LN2@gzfwrite:

; 290  :         return 0;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 62		 jmp	 SHORT $LN5@gzfwrite
$LN3@gzfwrite:

; 291  : 
; 292  :     /* compute bytes to read -- error on overflow */
; 293  :     len = nitems * size;

  00032	8b 45 10	 mov	 eax, DWORD PTR _nitems$[ebp]
  00035	0f af 45 0c	 imul	 eax, DWORD PTR _size$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 294  :     if (size && len / size != nitems) {

  0003c	83 7d 0c 00	 cmp	 DWORD PTR _size$[ebp], 0
  00040	74 24		 je	 SHORT $LN1@gzfwrite
  00042	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00045	33 d2		 xor	 edx, edx
  00047	f7 75 0c	 div	 DWORD PTR _size$[ebp]
  0004a	3b 45 10	 cmp	 eax, DWORD PTR _nitems$[ebp]
  0004d	74 17		 je	 SHORT $LN1@gzfwrite

; 295  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");

  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_t@
  00054	6a fe		 push	 -2			; fffffffeH
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 _gz_error
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 296  :         return 0;

  00062	33 c0		 xor	 eax, eax
  00064	eb 2e		 jmp	 SHORT $LN5@gzfwrite
$LN1@gzfwrite:

; 297  :     }
; 298  : 
; 299  :     /* write len bytes to buf, return the number of full items written */
; 300  :     return len ? gz_write(state, buf, len) / size : 0;

  00066	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  0006a	74 1e		 je	 SHORT $LN7@gzfwrite
  0006c	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  0006f	52		 push	 edx
  00070	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00073	50		 push	 eax
  00074	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _gz_write
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	33 d2		 xor	 edx, edx
  00082	f7 75 0c	 div	 DWORD PTR _size$[ebp]
  00085	89 45 f4	 mov	 DWORD PTR tv82[ebp], eax
  00088	eb 07		 jmp	 SHORT $LN8@gzfwrite
$LN7@gzfwrite:
  0008a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN8@gzfwrite:
  00091	8b 45 f4	 mov	 eax, DWORD PTR tv82[ebp]
$LN5@gzfwrite:

; 301  : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 10 00	 ret	 16			; 00000010H
_gzfwrite@16 ENDP
_TEXT	ENDS
PUBLIC	_gzwrite@12
; Function compile flags: /Odtp
;	COMDAT _gzwrite@12
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzwrite@12 PROC					; COMDAT

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 251  :     gz_statep state;
; 252  : 
; 253  :     /* get internal structure */
; 254  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 04		 jne	 SHORT $LN4@gzwrite

; 255  :         return 0;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 50		 jmp	 SHORT $LN5@gzwrite
$LN4@gzwrite:

; 256  :     state = (gz_statep)file;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00011	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 257  : 
; 258  :     /* check that we're writing and that there's no error */
; 259  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00017	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  0001e	75 09		 jne	 SHORT $LN2@gzwrite
  00020	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00023	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00027	74 04		 je	 SHORT $LN3@gzwrite
$LN2@gzwrite:

; 260  :         return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 31		 jmp	 SHORT $LN5@gzwrite
$LN3@gzwrite:

; 261  : 
; 262  :     /* since an int is returned, make sure len fits in one, otherwise return
; 263  :        with an error (this avoids a flaw in the interface) */
; 264  :     if ((int)len < 0) {

  0002d	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00031	7d 17		 jge	 SHORT $LN1@gzwrite

; 265  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00038	6a fd		 push	 -3			; fffffffdH
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _gz_error
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 266  :         return 0;

  00046	33 c0		 xor	 eax, eax
  00048	eb 14		 jmp	 SHORT $LN5@gzwrite
$LN1@gzwrite:

; 267  :     }
; 268  : 
; 269  :     /* write len bytes from buf (the return value will fit in an int) */
; 270  :     return (int)gz_write(state, buf, len);

  0004a	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0004d	51		 push	 ecx
  0004e	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00051	52		 push	 edx
  00052	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _gz_write
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@gzwrite:

; 271  : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 0c 00	 ret	 12			; 0000000cH
_gzwrite@12 ENDP
END
