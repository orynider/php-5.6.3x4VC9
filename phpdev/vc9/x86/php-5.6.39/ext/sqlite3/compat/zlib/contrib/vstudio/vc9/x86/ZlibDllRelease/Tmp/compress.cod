; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\compress.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_06CJNJFBNP@1?42?411?$AA@			; `string'
;	COMDAT ??_C@_06CJNJFBNP@1?42?411?$AA@
CONST	SEGMENT
??_C@_06CJNJFBNP@1?42?411?$AA@ DB '1.2.11', 00H		; `string'
PUBLIC	_compressBound@4
; Function compile flags: /Odtp
; File c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\compress.c
;	COMDAT _compressBound@4
_TEXT	SEGMENT
_sourceLen$ = 8						; size = 4
_compressBound@4 PROC					; COMDAT

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 84   :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
; 85   :            (sourceLen >> 25) + 13;

  00003	8b 45 08	 mov	 eax, DWORD PTR _sourceLen$[ebp]
  00006	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00009	03 45 08	 add	 eax, DWORD PTR _sourceLen$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _sourceLen$[ebp]
  0000f	c1 e9 0e	 shr	 ecx, 14			; 0000000eH
  00012	03 c1		 add	 eax, ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _sourceLen$[ebp]
  00017	c1 ea 19	 shr	 edx, 25			; 00000019H
  0001a	8d 44 10 0d	 lea	 eax, DWORD PTR [eax+edx+13]

; 86   : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
_compressBound@4 ENDP
PUBLIC	_compress2@20
; Function compile flags: /Odtp
;	COMDAT _compress2@20
_TEXT	SEGMENT
tv76 = -76						; size = 4
tv72 = -72						; size = 4
_max$ = -68						; size = 4
_err$ = -64						; size = 4
_left$ = -60						; size = 4
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_level$ = 24						; size = 4
_compress2@20 PROC					; COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 29   :     z_stream stream;
; 30   :     int err;
; 31   :     const uInt max = (uInt)-1;

  00006	c7 45 bc ff ff
	ff ff		 mov	 DWORD PTR _max$[ebp], -1

; 32   :     uLong left;
; 33   : 
; 34   :     left = *destLen;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _destLen$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	89 4d c4	 mov	 DWORD PTR _left$[ebp], ecx

; 35   :     *destLen = 0;

  00015	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  00018	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 36   : 
; 37   :     stream.zalloc = (alloc_func)0;

  0001e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+32], 0

; 38   :     stream.zfree = (free_func)0;

  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+36], 0

; 39   :     stream.opaque = (voidpf)0;

  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+40], 0

; 40   : 
; 41   :     err = deflateInit(&stream, level);

  00033	6a 38		 push	 56			; 00000038H
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411?$AA@
  0003a	8b 45 18	 mov	 eax, DWORD PTR _level$[ebp]
  0003d	50		 push	 eax
  0003e	8d 4d c8	 lea	 ecx, DWORD PTR _stream$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _deflateInit_@16
  00047	89 45 c0	 mov	 DWORD PTR _err$[ebp], eax

; 42   :     if (err != Z_OK) return err;

  0004a	83 7d c0 00	 cmp	 DWORD PTR _err$[ebp], 0
  0004e	74 08		 je	 SHORT $LN6@compress2
  00050	8b 45 c0	 mov	 eax, DWORD PTR _err$[ebp]
  00053	e9 ae 00 00 00	 jmp	 $LN7@compress2
$LN6@compress2:

; 43   : 
; 44   :     stream.next_out = dest;

  00058	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  0005b	89 55 d4	 mov	 DWORD PTR _stream$[ebp+12], edx

; 45   :     stream.avail_out = 0;

  0005e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+16], 0

; 46   :     stream.next_in = (z_const Bytef *)source;

  00065	8b 45 10	 mov	 eax, DWORD PTR _source$[ebp]
  00068	89 45 c8	 mov	 DWORD PTR _stream$[ebp], eax

; 47   :     stream.avail_in = 0;

  0006b	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+4], 0
$LN5@compress2:

; 48   : 
; 49   :     do {
; 50   :         if (stream.avail_out == 0) {

  00072	83 7d d8 00	 cmp	 DWORD PTR _stream$[ebp+16], 0
  00076	75 25		 jne	 SHORT $LN2@compress2

; 51   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00078	8b 4d c4	 mov	 ecx, DWORD PTR _left$[ebp]
  0007b	3b 4d bc	 cmp	 ecx, DWORD PTR _max$[ebp]
  0007e	76 08		 jbe	 SHORT $LN9@compress2
  00080	8b 55 bc	 mov	 edx, DWORD PTR _max$[ebp]
  00083	89 55 b8	 mov	 DWORD PTR tv72[ebp], edx
  00086	eb 06		 jmp	 SHORT $LN10@compress2
$LN9@compress2:
  00088	8b 45 c4	 mov	 eax, DWORD PTR _left$[ebp]
  0008b	89 45 b8	 mov	 DWORD PTR tv72[ebp], eax
$LN10@compress2:
  0008e	8b 4d b8	 mov	 ecx, DWORD PTR tv72[ebp]
  00091	89 4d d8	 mov	 DWORD PTR _stream$[ebp+16], ecx

; 52   :             left -= stream.avail_out;

  00094	8b 55 c4	 mov	 edx, DWORD PTR _left$[ebp]
  00097	2b 55 d8	 sub	 edx, DWORD PTR _stream$[ebp+16]
  0009a	89 55 c4	 mov	 DWORD PTR _left$[ebp], edx
$LN2@compress2:

; 53   :         }
; 54   :         if (stream.avail_in == 0) {

  0009d	83 7d cc 00	 cmp	 DWORD PTR _stream$[ebp+4], 0
  000a1	75 25		 jne	 SHORT $LN1@compress2

; 55   :             stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;

  000a3	8b 45 14	 mov	 eax, DWORD PTR _sourceLen$[ebp]
  000a6	3b 45 bc	 cmp	 eax, DWORD PTR _max$[ebp]
  000a9	76 08		 jbe	 SHORT $LN11@compress2
  000ab	8b 4d bc	 mov	 ecx, DWORD PTR _max$[ebp]
  000ae	89 4d b4	 mov	 DWORD PTR tv76[ebp], ecx
  000b1	eb 06		 jmp	 SHORT $LN12@compress2
$LN11@compress2:
  000b3	8b 55 14	 mov	 edx, DWORD PTR _sourceLen$[ebp]
  000b6	89 55 b4	 mov	 DWORD PTR tv76[ebp], edx
$LN12@compress2:
  000b9	8b 45 b4	 mov	 eax, DWORD PTR tv76[ebp]
  000bc	89 45 cc	 mov	 DWORD PTR _stream$[ebp+4], eax

; 56   :             sourceLen -= stream.avail_in;

  000bf	8b 4d 14	 mov	 ecx, DWORD PTR _sourceLen$[ebp]
  000c2	2b 4d cc	 sub	 ecx, DWORD PTR _stream$[ebp+4]
  000c5	89 4d 14	 mov	 DWORD PTR _sourceLen$[ebp], ecx
$LN1@compress2:

; 57   :         }
; 58   :         err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);

  000c8	8b 55 14	 mov	 edx, DWORD PTR _sourceLen$[ebp]
  000cb	f7 da		 neg	 edx
  000cd	1b d2		 sbb	 edx, edx
  000cf	83 e2 fc	 and	 edx, -4			; fffffffcH
  000d2	83 c2 04	 add	 edx, 4
  000d5	52		 push	 edx
  000d6	8d 45 c8	 lea	 eax, DWORD PTR _stream$[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _deflate@8
  000df	89 45 c0	 mov	 DWORD PTR _err$[ebp], eax

; 59   :     } while (err == Z_OK);

  000e2	83 7d c0 00	 cmp	 DWORD PTR _err$[ebp], 0
  000e6	74 8a		 je	 SHORT $LN5@compress2

; 60   : 
; 61   :     *destLen = stream.total_out;

  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR _destLen$[ebp]
  000eb	8b 55 dc	 mov	 edx, DWORD PTR _stream$[ebp+20]
  000ee	89 11		 mov	 DWORD PTR [ecx], edx

; 62   :     deflateEnd(&stream);

  000f0	8d 45 c8	 lea	 eax, DWORD PTR _stream$[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _deflateEnd@4

; 63   :     return err == Z_STREAM_END ? Z_OK : err;

  000f9	8b 45 c0	 mov	 eax, DWORD PTR _err$[ebp]
  000fc	83 e8 01	 sub	 eax, 1
  000ff	f7 d8		 neg	 eax
  00101	1b c0		 sbb	 eax, eax
  00103	23 45 c0	 and	 eax, DWORD PTR _err$[ebp]
$LN7@compress2:

; 64   : }

  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 14 00	 ret	 20			; 00000014H
_compress2@20 ENDP
PUBLIC	_compress@16
; Function compile flags: /Odtp
;	COMDAT _compress@16
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_compress@16 PROC					; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);

  00003	6a ff		 push	 -1
  00005	8b 45 14	 mov	 eax, DWORD PTR _sourceLen$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 10	 mov	 ecx, DWORD PTR _source$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  00010	52		 push	 edx
  00011	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _compress2@20

; 75   : }

  0001a	5d		 pop	 ebp
  0001b	c2 10 00	 ret	 16			; 00000010H
_compress@16 ENDP
END
