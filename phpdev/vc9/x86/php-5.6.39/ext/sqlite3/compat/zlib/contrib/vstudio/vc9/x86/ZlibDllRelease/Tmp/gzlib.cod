; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\gzlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@		; `string'
EXTRN	_wcstombs:PROC
EXTRN	__wopen:PROC
EXTRN	_open:PROC
EXTRN	__lseeki64:PROC
EXTRN	__snprintf:PROC
EXTRN	_strlen:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
;	COMDAT ??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@ DB '%s%s%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
PUBLIC	_gz_error
; Function compile flags: /Odtp
; File c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\gzlib.c
;	COMDAT _gz_error
_TEXT	SEGMENT
_state$ = 8						; size = 4
_err$ = 12						; size = 4
_msg$ = 16						; size = 4
_gz_error PROC						; COMDAT

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 584  :     /* free previously allocated message and clear */
; 585  :     if (state->msg != NULL) {

  00004	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00007	83 78 60 00	 cmp	 DWORD PTR [eax+96], 0
  0000b	74 22		 je	 SHORT $LN6@gz_error

; 586  :         if (state->err != Z_MEM_ERROR)

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	83 79 5c fc	 cmp	 DWORD PTR [ecx+92], -4	; fffffffcH
  00014	74 0f		 je	 SHORT $LN5@gz_error

; 587  :             free(state->msg);

  00016	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00019	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _free
  00022	83 c4 04	 add	 esp, 4
$LN5@gz_error:

; 588  :         state->msg = NULL;

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00028	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0
$LN6@gz_error:

; 589  :     }
; 590  : 
; 591  :     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
; 592  :     if (err != Z_OK && err != Z_BUF_ERROR)

  0002f	83 7d 0c 00	 cmp	 DWORD PTR _err$[ebp], 0
  00033	74 0f		 je	 SHORT $LN4@gz_error
  00035	83 7d 0c fb	 cmp	 DWORD PTR _err$[ebp], -5 ; fffffffbH
  00039	74 09		 je	 SHORT $LN4@gz_error

; 593  :         state->x.have = 0;

  0003b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0003e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN4@gz_error:

; 594  : 
; 595  :     /* set error code, and if no message, then done */
; 596  :     state->err = err;

  00044	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _err$[ebp]
  0004a	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 597  :     if (msg == NULL)

  0004d	83 7d 10 00	 cmp	 DWORD PTR _msg$[ebp], 0
  00051	75 05		 jne	 SHORT $LN3@gz_error

; 598  :         return;

  00053	e9 96 00 00 00	 jmp	 $LN7@gz_error
$LN3@gz_error:

; 599  : 
; 600  :     /* for an out of memory error, return literal string when requested */
; 601  :     if (err == Z_MEM_ERROR)

  00058	83 7d 0c fc	 cmp	 DWORD PTR _err$[ebp], -4 ; fffffffcH
  0005c	75 05		 jne	 SHORT $LN2@gz_error

; 602  :         return;

  0005e	e9 8b 00 00 00	 jmp	 $LN7@gz_error
$LN2@gz_error:

; 603  : 
; 604  :     /* construct error message with path */
; 605  :     if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
; 606  :             NULL) {

  00063	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00066	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _strlen
  0006f	83 c4 04	 add	 esp, 4
  00072	8b f0		 mov	 esi, eax
  00074	8b 4d 10	 mov	 ecx, DWORD PTR _msg$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _strlen
  0007d	83 c4 04	 add	 esp, 4
  00080	8d 54 06 03	 lea	 edx, DWORD PTR [esi+eax+3]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _malloc
  0008a	83 c4 04	 add	 esp, 4
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00090	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  00093	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00096	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  0009a	75 0c		 jne	 SHORT $LN1@gz_error

; 607  :         state->err = Z_MEM_ERROR;

  0009c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0009f	c7 40 5c fc ff
	ff ff		 mov	 DWORD PTR [eax+92], -4	; fffffffcH

; 608  :         return;

  000a6	eb 46		 jmp	 SHORT $LN7@gz_error
$LN1@gz_error:

; 609  :     }
; 610  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 611  :     (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
; 612  :                    "%s%s%s", state->path, ": ", msg);

  000a8	8b 4d 10	 mov	 ecx, DWORD PTR _msg$[ebp]
  000ab	51		 push	 ecx
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
  000b1	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b4	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000b7	50		 push	 eax
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@
  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000c0	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _strlen
  000c9	83 c4 04	 add	 esp, 4
  000cc	8b f0		 mov	 esi, eax
  000ce	8b 45 10	 mov	 eax, DWORD PTR _msg$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _strlen
  000d7	83 c4 04	 add	 esp, 4
  000da	8d 4c 06 03	 lea	 ecx, DWORD PTR [esi+eax+3]
  000de	51		 push	 ecx
  000df	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000e2	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 __snprintf
  000eb	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@gz_error:

; 613  : #else
; 614  :     strcpy(state->msg, state->path);
; 615  :     strcat(state->msg, ": ");
; 616  :     strcat(state->msg, msg);
; 617  : #endif
; 618  : }

  000ee	5e		 pop	 esi
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
_gz_error ENDP
_TEXT	ENDS
PUBLIC	_gzclearerr@4
; Function compile flags: /Odtp
;	COMDAT _gzclearerr@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclearerr@4 PROC					; COMDAT

; 555  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 556  :     gz_statep state;
; 557  : 
; 558  :     /* get internal structure and check integrity */
; 559  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 02		 jne	 SHORT $LN3@gzclearerr

; 560  :         return;

  0000a	eb 50		 jmp	 SHORT $LN4@gzclearerr
$LN3@gzclearerr:

; 561  :     state = (gz_statep)file;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 562  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00015	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0001c	74 0e		 je	 SHORT $LN2@gzclearerr
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00021	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00028	74 02		 je	 SHORT $LN2@gzclearerr

; 563  :         return;

  0002a	eb 30		 jmp	 SHORT $LN4@gzclearerr
$LN2@gzclearerr:

; 564  : 
; 565  :     /* clear error and end-of-file */
; 566  :     if (state->mode == GZ_READ) {

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002f	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00036	75 14		 jne	 SHORT $LN1@gzclearerr

; 567  :         state->eof = 0;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003b	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 568  :         state->past = 0;

  00042	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00045	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0
$LN1@gzclearerr:

; 569  :     }
; 570  :     gz_error(state, Z_OK, NULL);

  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _gz_error
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gzclearerr:

; 571  : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
_gzclearerr@4 ENDP
_TEXT	ENDS
PUBLIC	_gzerror@8
; Function compile flags: /Odtp
;	COMDAT _gzerror@8
_TEXT	SEGMENT
tv76 = -12						; size = 4
tv77 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_errnum$ = 12						; size = 4
_gzerror@8 PROC						; COMDAT

; 535  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 536  :     gz_statep state;
; 537  : 
; 538  :     /* get internal structure and check integrity */
; 539  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 04		 jne	 SHORT $LN3@gzerror

; 540  :         return NULL;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 69		 jmp	 SHORT $LN4@gzerror
$LN3@gzerror:

; 541  :     state = (gz_statep)file;

  00010	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00013	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 542  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00019	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00020	74 10		 je	 SHORT $LN2@gzerror
  00022	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00025	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002c	74 04		 je	 SHORT $LN2@gzerror

; 543  :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 47		 jmp	 SHORT $LN4@gzerror
$LN2@gzerror:

; 544  : 
; 545  :     /* return error information */
; 546  :     if (errnum != NULL)

  00032	83 7d 0c 00	 cmp	 DWORD PTR _errnum$[ebp], 0
  00036	74 0b		 je	 SHORT $LN1@gzerror

; 547  :         *errnum = state->err;

  00038	8b 45 0c	 mov	 eax, DWORD PTR _errnum$[ebp]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003e	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00041	89 10		 mov	 DWORD PTR [eax], edx
$LN1@gzerror:

; 548  :     return state->err == Z_MEM_ERROR ? "out of memory" :
; 549  :                                        (state->msg == NULL ? "" : state->msg);

  00043	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00046	83 78 5c fc	 cmp	 DWORD PTR [eax+92], -4	; fffffffcH
  0004a	75 09		 jne	 SHORT $LN8@gzerror
  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00053	eb 21		 jmp	 SHORT $LN9@gzerror
$LN8@gzerror:
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00058	83 79 60 00	 cmp	 DWORD PTR [ecx+96], 0
  0005c	75 09		 jne	 SHORT $LN6@gzerror
  0005e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
  00065	eb 09		 jmp	 SHORT $LN7@gzerror
$LN6@gzerror:
  00067	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0006a	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0006d	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
$LN7@gzerror:
  00070	8b 4d f4	 mov	 ecx, DWORD PTR tv76[ebp]
  00073	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
$LN9@gzerror:
  00076	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
$LN4@gzerror:

; 550  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 08 00	 ret	 8
_gzerror@8 ENDP
_TEXT	ENDS
PUBLIC	_gzeof@4
; Function compile flags: /Odtp
;	COMDAT _gzeof@4
_TEXT	SEGMENT
tv72 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzeof@4 PROC						; COMDAT

; 517  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 518  :     gz_statep state;
; 519  : 
; 520  :     /* get internal structure and check integrity */
; 521  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 04		 jne	 SHORT $LN2@gzeof

; 522  :         return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 43		 jmp	 SHORT $LN3@gzeof
$LN2@gzeof:

; 523  :     state = (gz_statep)file;

  00010	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00013	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 524  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00019	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00020	74 10		 je	 SHORT $LN1@gzeof
  00022	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00025	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002c	74 04		 je	 SHORT $LN1@gzeof

; 525  :         return 0;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 21		 jmp	 SHORT $LN3@gzeof
$LN1@gzeof:

; 526  : 
; 527  :     /* return end-of-file state */
; 528  :     return state->mode == GZ_READ ? state->past : 0;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00035	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  0003c	75 0b		 jne	 SHORT $LN5@gzeof
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00041	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00044	89 55 f8	 mov	 DWORD PTR tv72[ebp], edx
  00047	eb 07		 jmp	 SHORT $LN6@gzeof
$LN5@gzeof:
  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN6@gzeof:
  00050	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
$LN3@gzeof:

; 529  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
_gzeof@4 ENDP
_TEXT	ENDS
PUBLIC	_gzoffset64@4
; Function compile flags: /Odtp
;	COMDAT _gzoffset64@4
_TEXT	SEGMENT
_state$ = -12						; size = 4
_offset$ = -8						; size = 8
_file$ = 8						; size = 4
_gzoffset64@4 PROC					; COMDAT

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 485  :     z_off64_t offset;
; 486  :     gz_statep state;
; 487  : 
; 488  :     /* get internal structure and check integrity */
; 489  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN4@gzoffset64

; 490  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	83 ca ff	 or	 edx, -1
  00012	eb 7e		 jmp	 SHORT $LN5@gzoffset64
$LN4@gzoffset64:

; 491  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 492  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00024	74 14		 je	 SHORT $LN3@gzoffset64
  00026	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00029	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00030	74 08		 je	 SHORT $LN3@gzoffset64

; 493  :         return -1;

  00032	83 c8 ff	 or	 eax, -1
  00035	83 ca ff	 or	 edx, -1
  00038	eb 58		 jmp	 SHORT $LN5@gzoffset64
$LN3@gzoffset64:

; 494  : 
; 495  :     /* compute and return effective offset in file */
; 496  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  0003a	6a 01		 push	 1
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00043	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 __lseeki64
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax
  00052	89 55 fc	 mov	 DWORD PTR _offset$[ebp+4], edx

; 497  :     if (offset == -1)

  00055	8b 55 f8	 mov	 edx, DWORD PTR _offset$[ebp]
  00058	23 55 fc	 and	 edx, DWORD PTR _offset$[ebp+4]
  0005b	83 fa ff	 cmp	 edx, -1
  0005e	75 08		 jne	 SHORT $LN2@gzoffset64

; 498  :         return -1;

  00060	83 c8 ff	 or	 eax, -1
  00063	83 ca ff	 or	 edx, -1
  00066	eb 2a		 jmp	 SHORT $LN5@gzoffset64
$LN2@gzoffset64:

; 499  :     if (state->mode == GZ_READ)             /* reading */

  00068	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0006b	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00072	75 18		 jne	 SHORT $LN1@gzoffset64

; 500  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  00074	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00077	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  0007a	33 c0		 xor	 eax, eax
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _offset$[ebp]
  0007f	2b ca		 sub	 ecx, edx
  00081	8b 55 fc	 mov	 edx, DWORD PTR _offset$[ebp+4]
  00084	1b d0		 sbb	 edx, eax
  00086	89 4d f8	 mov	 DWORD PTR _offset$[ebp], ecx
  00089	89 55 fc	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN1@gzoffset64:

; 501  :     return offset;

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp]
  0008f	8b 55 fc	 mov	 edx, DWORD PTR _offset$[ebp+4]
$LN5@gzoffset64:

; 502  : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
_gzoffset64@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell64@4
; Function compile flags: /Odtp
;	COMDAT _gztell64@4
_TEXT	SEGMENT
tv73 = -12						; size = 8
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gztell64@4 PROC					; COMDAT

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 458  :     gz_statep state;
; 459  : 
; 460  :     /* get internal structure and check integrity */
; 461  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN2@gztell64

; 462  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	83 ca ff	 or	 edx, -1
  00012	eb 5d		 jmp	 SHORT $LN3@gztell64
$LN2@gztell64:

; 463  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 464  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00024	74 14		 je	 SHORT $LN1@gztell64
  00026	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00029	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00030	74 08		 je	 SHORT $LN1@gztell64

; 465  :         return -1;

  00032	83 c8 ff	 or	 eax, -1
  00035	83 ca ff	 or	 edx, -1
  00038	eb 37		 jmp	 SHORT $LN3@gztell64
$LN1@gztell64:

; 466  : 
; 467  :     /* return position */
; 468  :     return state->x.pos + (state->seek ? state->skip : 0);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003d	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00041	74 11		 je	 SHORT $LN5@gztell64
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00046	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00049	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  0004c	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0004f	89 45 f8	 mov	 DWORD PTR tv73[ebp+4], eax
  00052	eb 0e		 jmp	 SHORT $LN6@gztell64
$LN5@gztell64:
  00054	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0005b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp+4], 0
$LN6@gztell64:
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00065	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00068	03 45 f4	 add	 eax, DWORD PTR tv73[ebp]
  0006b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0006e	13 55 f8	 adc	 edx, DWORD PTR tv73[ebp+4]
$LN3@gztell64:

; 469  : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
_gztell64@4 ENDP
_TEXT	ENDS
PUBLIC	_gzbuffer@8
; Function compile flags: /Odtp
;	COMDAT _gzbuffer@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_size$ = 12						; size = 4
_gzbuffer@8 PROC					; COMDAT

; 319  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 320  :     gz_statep state;
; 321  : 
; 322  :     /* get internal structure and check integrity */
; 323  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 05		 jne	 SHORT $LN5@gzbuffer

; 324  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	eb 58		 jmp	 SHORT $LN6@gzbuffer
$LN5@gzbuffer:

; 325  :     state = (gz_statep)file;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 326  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00018	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0001f	74 11		 je	 SHORT $LN4@gzbuffer
  00021	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00024	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002b	74 05		 je	 SHORT $LN4@gzbuffer

; 327  :         return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	eb 35		 jmp	 SHORT $LN6@gzbuffer
$LN4@gzbuffer:

; 328  : 
; 329  :     /* make sure we haven't already allocated memory */
; 330  :     if (state->size != 0)

  00032	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00035	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00039	74 05		 je	 SHORT $LN3@gzbuffer

; 331  :         return -1;

  0003b	83 c8 ff	 or	 eax, -1
  0003e	eb 27		 jmp	 SHORT $LN6@gzbuffer
$LN3@gzbuffer:

; 332  : 
; 333  :     /* check and set requested size */
; 334  :     if ((size << 1) < size)

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  00043	d1 e1		 shl	 ecx, 1
  00045	3b 4d 0c	 cmp	 ecx, DWORD PTR _size$[ebp]
  00048	73 05		 jae	 SHORT $LN2@gzbuffer

; 335  :         return -1;              /* need to be able to double it */

  0004a	83 c8 ff	 or	 eax, -1
  0004d	eb 18		 jmp	 SHORT $LN6@gzbuffer
$LN2@gzbuffer:

; 336  :     if (size < 2)

  0004f	83 7d 0c 02	 cmp	 DWORD PTR _size$[ebp], 2
  00053	73 07		 jae	 SHORT $LN1@gzbuffer

; 337  :         size = 2;               /* need two bytes to check magic header */

  00055	c7 45 0c 02 00
	00 00		 mov	 DWORD PTR _size$[ebp], 2
$LN1@gzbuffer:

; 338  :     state->want = size;

  0005c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005f	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00062	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 339  :     return 0;

  00065	33 c0		 xor	 eax, eax
$LN6@gzbuffer:

; 340  : }

  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
_gzbuffer@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gz_reset PROC						; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   :     state->x.have = 0;              /* no output data available */

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 79   :     if (state->mode == GZ_READ) {   /* for reading ... */

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0000f	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00016	75 1e		 jne	 SHORT $LN1@gz_reset

; 80   :         state->eof = 0;             /* not at end of file */

  00018	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001b	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 81   :         state->past = 0;            /* have not read past end yet */

  00022	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00025	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 82   :         state->how = LOOK;          /* look for gzip header */

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
$LN1@gz_reset:

; 83   :     }
; 84   :     state->seek = 0;                /* no seek request pending */

  00036	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00039	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 85   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _gz_error
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 86   :     state->x.pos = 0;               /* no uncompressed data yet */

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00053	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0005a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 87   :     state->strm.avail_in = 0;       /* no input data yet */

  00061	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00064	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 88   : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_gz_reset ENDP
PUBLIC	_gzoffset@4
; Function compile flags: /Odtp
;	COMDAT _gzoffset@4
_TEXT	SEGMENT
tv70 = -20						; size = 4
tv83 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_gzoffset@4 PROC					; COMDAT

; 507  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 508  :     z_off64_t ret;
; 509  : 
; 510  :     ret = gzoffset64(file);

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _gzoffset64@4
  0000f	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00012	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 511  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00018	99		 cdq
  00019	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  0001c	89 55 f4	 mov	 DWORD PTR tv83[ebp+4], edx
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00022	3b 4d f0	 cmp	 ecx, DWORD PTR tv83[ebp]
  00025	75 10		 jne	 SHORT $LN3@gzoffset
  00027	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp+4]
  0002a	3b 55 f4	 cmp	 edx, DWORD PTR tv83[ebp+4]
  0002d	75 08		 jne	 SHORT $LN3@gzoffset
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00032	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00035	eb 07		 jmp	 SHORT $LN4@gzoffset
$LN3@gzoffset:
  00037	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
$LN4@gzoffset:
  0003e	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]

; 512  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_gzoffset@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell@4
; Function compile flags: /Odtp
;	COMDAT _gztell@4
_TEXT	SEGMENT
tv70 = -20						; size = 4
tv83 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_gztell@4 PROC						; COMDAT

; 474  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 475  :     z_off64_t ret;
; 476  : 
; 477  :     ret = gztell64(file);

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _gztell64@4
  0000f	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00012	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 478  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00018	99		 cdq
  00019	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  0001c	89 55 f4	 mov	 DWORD PTR tv83[ebp+4], edx
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00022	3b 4d f0	 cmp	 ecx, DWORD PTR tv83[ebp]
  00025	75 10		 jne	 SHORT $LN3@gztell
  00027	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp+4]
  0002a	3b 55 f4	 cmp	 edx, DWORD PTR tv83[ebp+4]
  0002d	75 08		 jne	 SHORT $LN3@gztell
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00032	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00035	eb 07		 jmp	 SHORT $LN4@gztell
$LN3@gztell:
  00037	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
$LN4@gztell:
  0003e	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]

; 479  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_gztell@4 ENDP
_TEXT	ENDS
PUBLIC	_gzrewind@4
; Function compile flags: /Odtp
;	COMDAT _gzrewind@4
_TEXT	SEGMENT
tv130 = -12						; size = 8
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzrewind@4 PROC					; COMDAT

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 346  :     gz_statep state;
; 347  : 
; 348  :     /* get internal structure */
; 349  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 05		 jne	 SHORT $LN4@gzrewind

; 350  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	eb 69		 jmp	 SHORT $LN5@gzrewind
$LN4@gzrewind:

; 351  :     state = (gz_statep)file;

  00011	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00014	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 352  : 
; 353  :     /* check that we're reading and that there's no error */
; 354  :     if (state->mode != GZ_READ ||
; 355  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0001a	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00021	75 12		 jne	 SHORT $LN2@gzrewind
  00023	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00026	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0002a	74 0e		 je	 SHORT $LN3@gzrewind
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002f	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00033	74 05		 je	 SHORT $LN3@gzrewind
$LN2@gzrewind:

; 356  :         return -1;

  00035	83 c8 ff	 or	 eax, -1
  00038	eb 40		 jmp	 SHORT $LN5@gzrewind
$LN3@gzrewind:

; 357  : 
; 358  :     /* back up and start over */
; 359  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  0003a	6a 00		 push	 0
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003f	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00042	52		 push	 edx
  00043	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00046	50		 push	 eax
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0004a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 __lseeki64
  00053	83 c4 10	 add	 esp, 16			; 00000010H
  00056	89 45 f4	 mov	 DWORD PTR tv130[ebp], eax
  00059	89 55 f8	 mov	 DWORD PTR tv130[ebp+4], edx
  0005c	8b 45 f4	 mov	 eax, DWORD PTR tv130[ebp]
  0005f	23 45 f8	 and	 eax, DWORD PTR tv130[ebp+4]
  00062	83 f8 ff	 cmp	 eax, -1
  00065	75 05		 jne	 SHORT $LN1@gzrewind

; 360  :         return -1;

  00067	83 c8 ff	 or	 eax, -1
  0006a	eb 0e		 jmp	 SHORT $LN5@gzrewind
$LN1@gzrewind:

; 361  :     gz_reset(state);

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 _gz_reset
  00075	83 c4 04	 add	 esp, 4

; 362  :     return 0;

  00078	33 c0		 xor	 eax, eax
$LN5@gzrewind:

; 363  : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
_gzrewind@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_open
_TEXT	SEGMENT
tv319 = -36						; size = 4
tv191 = -32						; size = 4
tv192 = -28						; size = 4
tv178 = -24						; size = 4
tv85 = -20						; size = 4
_state$ = -16						; size = 4
_oflag$ = -12						; size = 4
_len$ = -8						; size = 4
_exclusive$ = -4					; size = 4
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
_mode$ = 16						; size = 4
_gz_open PROC						; COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 96   :     gz_statep state;
; 97   :     z_size_t len;
; 98   :     int oflag;
; 99   : #ifdef O_CLOEXEC
; 100  :     int cloexec = 0;
; 101  : #endif
; 102  : #ifdef O_EXCL
; 103  :     int exclusive = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _exclusive$[ebp], 0

; 104  : #endif
; 105  : 
; 106  :     /* check input */
; 107  :     if (path == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _path$[ebp], 0
  00011	75 07		 jne	 SHORT $LN35@gz_open

; 108  :         return NULL;

  00013	33 c0		 xor	 eax, eax
  00015	e9 b5 03 00 00	 jmp	 $LN36@gz_open
$LN35@gz_open:

; 109  : 
; 110  :     /* allocate gzFile structure to return */
; 111  :     state = (gz_statep)malloc(sizeof(gz_state));

  0001a	68 a0 00 00 00	 push	 160			; 000000a0H
  0001f	e8 00 00 00 00	 call	 _malloc
  00024	83 c4 04	 add	 esp, 4
  00027	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 112  :     if (state == NULL)

  0002a	83 7d f0 00	 cmp	 DWORD PTR _state$[ebp], 0
  0002e	75 07		 jne	 SHORT $LN34@gz_open

; 113  :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	e9 98 03 00 00	 jmp	 $LN36@gz_open
$LN34@gz_open:

; 114  :     state->size = 0;            /* no buffers allocated yet */

  00037	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0003a	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 115  :     state->want = GZBUFSIZE;    /* requested buffer size */

  00041	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00044	c7 41 20 00 20
	00 00		 mov	 DWORD PTR [ecx+32], 8192 ; 00002000H

; 116  :     state->msg = NULL;          /* no error message yet */

  0004b	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0004e	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0

; 117  : 
; 118  :     /* interpret mode */
; 119  :     state->mode = GZ_NONE;

  00055	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00058	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 120  :     state->level = Z_DEFAULT_COMPRESSION;

  0005f	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00062	c7 41 48 ff ff
	ff ff		 mov	 DWORD PTR [ecx+72], -1

; 121  :     state->strategy = Z_DEFAULT_STRATEGY;

  00069	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0006c	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], 0

; 122  :     state->direct = 0;

  00073	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00076	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
$LN33@gz_open:

; 123  :     while (*mode) {

  0007d	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  00080	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00083	85 d2		 test	 edx, edx
  00085	0f 84 e1 00 00
	00		 je	 $LN32@gz_open

; 124  :         if (*mode >= '0' && *mode <= '9')

  0008b	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  0008e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00091	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00094	7c 1f		 jl	 SHORT $LN31@gz_open
  00096	8b 55 10	 mov	 edx, DWORD PTR _mode$[ebp]
  00099	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0009c	83 f8 39	 cmp	 eax, 57			; 00000039H
  0009f	7f 14		 jg	 SHORT $LN31@gz_open

; 125  :             state->level = *mode - '0';

  000a1	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  000a4	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a7	83 ea 30	 sub	 edx, 48			; 00000030H
  000aa	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000ad	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 126  :         else

  000b0	e9 a9 00 00 00	 jmp	 $LN30@gz_open
$LN31@gz_open:

; 127  :             switch (*mode) {

  000b5	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  000b8	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000bb	89 55 ec	 mov	 DWORD PTR tv85[ebp], edx
  000be	8b 45 ec	 mov	 eax, DWORD PTR tv85[ebp]
  000c1	83 e8 2b	 sub	 eax, 43			; 0000002bH
  000c4	89 45 ec	 mov	 DWORD PTR tv85[ebp], eax
  000c7	83 7d ec 4d	 cmp	 DWORD PTR tv85[ebp], 77	; 0000004dH
  000cb	0f 87 8d 00 00
	00		 ja	 $LN30@gz_open
  000d1	8b 4d ec	 mov	 ecx, DWORD PTR tv85[ebp]
  000d4	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN44@gz_open[ecx]
  000db	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN45@gz_open[edx*4]
$LN27@gz_open:

; 128  :             case 'r':
; 129  :                 state->mode = GZ_READ;

  000e2	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000e5	c7 40 10 4f 1c
	00 00		 mov	 DWORD PTR [eax+16], 7247 ; 00001c4fH

; 130  :                 break;

  000ec	eb 70		 jmp	 SHORT $LN30@gz_open
$LN26@gz_open:

; 131  : #ifndef NO_GZCOMPRESS
; 132  :             case 'w':
; 133  :                 state->mode = GZ_WRITE;

  000ee	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000f1	c7 41 10 b1 79
	00 00		 mov	 DWORD PTR [ecx+16], 31153 ; 000079b1H

; 134  :                 break;

  000f8	eb 64		 jmp	 SHORT $LN30@gz_open
$LN25@gz_open:

; 135  :             case 'a':
; 136  :                 state->mode = GZ_APPEND;

  000fa	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000fd	c7 42 10 01 00
	00 00		 mov	 DWORD PTR [edx+16], 1

; 137  :                 break;

  00104	eb 58		 jmp	 SHORT $LN30@gz_open
$LN24@gz_open:

; 138  : #endif
; 139  :             case '+':       /* can't read and write at the same time */
; 140  :                 free(state);

  00106	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _free
  0010f	83 c4 04	 add	 esp, 4

; 141  :                 return NULL;

  00112	33 c0		 xor	 eax, eax
  00114	e9 b6 02 00 00	 jmp	 $LN36@gz_open

; 142  :             case 'b':       /* ignore -- will request binary anyway */
; 143  :                 break;

  00119	eb 43		 jmp	 SHORT $LN30@gz_open
$LN22@gz_open:

; 144  : #ifdef O_CLOEXEC
; 145  :             case 'e':
; 146  :                 cloexec = 1;
; 147  :                 break;
; 148  : #endif
; 149  : #ifdef O_EXCL
; 150  :             case 'x':
; 151  :                 exclusive = 1;

  0011b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _exclusive$[ebp], 1

; 152  :                 break;

  00122	eb 3a		 jmp	 SHORT $LN30@gz_open
$LN21@gz_open:

; 153  : #endif
; 154  :             case 'f':
; 155  :                 state->strategy = Z_FILTERED;

  00124	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00127	c7 41 4c 01 00
	00 00		 mov	 DWORD PTR [ecx+76], 1

; 156  :                 break;

  0012e	eb 2e		 jmp	 SHORT $LN30@gz_open
$LN20@gz_open:

; 157  :             case 'h':
; 158  :                 state->strategy = Z_HUFFMAN_ONLY;

  00130	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00133	c7 42 4c 02 00
	00 00		 mov	 DWORD PTR [edx+76], 2

; 159  :                 break;

  0013a	eb 22		 jmp	 SHORT $LN30@gz_open
$LN19@gz_open:

; 160  :             case 'R':
; 161  :                 state->strategy = Z_RLE;

  0013c	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0013f	c7 40 4c 03 00
	00 00		 mov	 DWORD PTR [eax+76], 3

; 162  :                 break;

  00146	eb 16		 jmp	 SHORT $LN30@gz_open
$LN18@gz_open:

; 163  :             case 'F':
; 164  :                 state->strategy = Z_FIXED;

  00148	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0014b	c7 41 4c 04 00
	00 00		 mov	 DWORD PTR [ecx+76], 4

; 165  :                 break;

  00152	eb 0a		 jmp	 SHORT $LN30@gz_open
$LN17@gz_open:

; 166  :             case 'T':
; 167  :                 state->direct = 1;

  00154	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00157	c7 42 2c 01 00
	00 00		 mov	 DWORD PTR [edx+44], 1
$LN30@gz_open:

; 168  :                 break;
; 169  :             default:        /* could consider as an error, but just ignore */
; 170  :                 ;
; 171  :             }
; 172  :         mode++;

  0015e	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  00161	83 c0 01	 add	 eax, 1
  00164	89 45 10	 mov	 DWORD PTR _mode$[ebp], eax

; 173  :     }

  00167	e9 11 ff ff ff	 jmp	 $LN33@gz_open
$LN32@gz_open:

; 174  : 
; 175  :     /* must provide an "r", "w", or "a" */
; 176  :     if (state->mode == GZ_NONE) {

  0016c	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0016f	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00173	75 13		 jne	 SHORT $LN15@gz_open

; 177  :         free(state);

  00175	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00178	52		 push	 edx
  00179	e8 00 00 00 00	 call	 _free
  0017e	83 c4 04	 add	 esp, 4

; 178  :         return NULL;

  00181	33 c0		 xor	 eax, eax
  00183	e9 47 02 00 00	 jmp	 $LN36@gz_open
$LN15@gz_open:

; 179  :     }
; 180  : 
; 181  :     /* can't force transparent read */
; 182  :     if (state->mode == GZ_READ) {

  00188	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0018b	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00192	75 26		 jne	 SHORT $LN14@gz_open

; 183  :         if (state->direct) {

  00194	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00197	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  0019b	74 13		 je	 SHORT $LN13@gz_open

; 184  :             free(state);

  0019d	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  001a0	52		 push	 edx
  001a1	e8 00 00 00 00	 call	 _free
  001a6	83 c4 04	 add	 esp, 4

; 185  :             return NULL;

  001a9	33 c0		 xor	 eax, eax
  001ab	e9 1f 02 00 00	 jmp	 $LN36@gz_open
$LN13@gz_open:

; 186  :         }
; 187  :         state->direct = 1;      /* for empty file */

  001b0	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001b3	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1
$LN14@gz_open:

; 188  :     }
; 189  : 
; 190  :     /* save the path name for error messages */
; 191  : #ifdef WIDECHAR
; 192  :     if (fd == -2) {

  001ba	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  001be	75 22		 jne	 SHORT $LN12@gz_open

; 193  :         len = wcstombs(NULL, path, 0);

  001c0	6a 00		 push	 0
  001c2	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  001c5	51		 push	 ecx
  001c6	6a 00		 push	 0
  001c8	e8 00 00 00 00	 call	 _wcstombs
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d0	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 194  :         if (len == (z_size_t)-1)

  001d3	83 7d f8 ff	 cmp	 DWORD PTR _len$[ebp], -1
  001d7	75 07		 jne	 SHORT $LN11@gz_open

; 195  :             len = 0;

  001d9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN11@gz_open:

; 196  :     }
; 197  :     else

  001e0	eb 0f		 jmp	 SHORT $LN10@gz_open
$LN12@gz_open:

; 198  : #endif
; 199  :         len = strlen((const char *)path);

  001e2	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  001e5	52		 push	 edx
  001e6	e8 00 00 00 00	 call	 _strlen
  001eb	83 c4 04	 add	 esp, 4
  001ee	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax
$LN10@gz_open:

; 200  :     state->path = (char *)malloc(len + 1);

  001f1	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  001f4	83 c0 01	 add	 eax, 1
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 _malloc
  001fd	83 c4 04	 add	 esp, 4
  00200	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00203	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 201  :     if (state->path == NULL) {

  00206	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00209	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  0020d	75 13		 jne	 SHORT $LN9@gz_open

; 202  :         free(state);

  0020f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 _free
  00218	83 c4 04	 add	 esp, 4

; 203  :         return NULL;

  0021b	33 c0		 xor	 eax, eax
  0021d	e9 ad 01 00 00	 jmp	 $LN36@gz_open
$LN9@gz_open:

; 204  :     }
; 205  : #ifdef WIDECHAR
; 206  :     if (fd == -2)

  00222	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  00226	75 2d		 jne	 SHORT $LN8@gz_open

; 207  :         if (len)

  00228	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  0022c	74 1c		 je	 SHORT $LN7@gz_open

; 208  :             wcstombs(state->path, path, len + 1);

  0022e	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  00231	83 c1 01	 add	 ecx, 1
  00234	51		 push	 ecx
  00235	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  00238	52		 push	 edx
  00239	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0023c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0023f	51		 push	 ecx
  00240	e8 00 00 00 00	 call	 _wcstombs
  00245	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  :         else

  00248	eb 09		 jmp	 SHORT $LN6@gz_open
$LN7@gz_open:

; 210  :             *(state->path) = 0;

  0024a	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0024d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00250	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN6@gz_open:

; 211  :     else

  00253	eb 1f		 jmp	 SHORT $LN5@gz_open
$LN8@gz_open:

; 212  : #endif
; 213  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 214  :         (void)snprintf(state->path, len + 1, "%s", (const char *)path);

  00255	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00258	51		 push	 ecx
  00259	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0025e	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  00261	83 c2 01	 add	 edx, 1
  00264	52		 push	 edx
  00265	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00268	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0026b	51		 push	 ecx
  0026c	e8 00 00 00 00	 call	 __snprintf
  00271	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@gz_open:

; 215  : #else
; 216  :         strcpy(state->path, path);
; 217  : #endif
; 218  : 
; 219  :     /* compute the flags for open() */
; 220  :     oflag =
; 221  : #ifdef O_LARGEFILE
; 222  :         O_LARGEFILE |
; 223  : #endif
; 224  : #ifdef O_BINARY
; 225  :         O_BINARY |
; 226  : #endif
; 227  : #ifdef O_CLOEXEC
; 228  :         (cloexec ? O_CLOEXEC : 0) |
; 229  : #endif
; 230  :         (state->mode == GZ_READ ?
; 231  :          O_RDONLY :
; 232  :          (O_WRONLY | O_CREAT |
; 233  : #ifdef O_EXCL
; 234  :           (exclusive ? O_EXCL : 0) |
; 235  : #endif
; 236  :           (state->mode == GZ_WRITE ?
; 237  :            O_TRUNC :
; 238  :            O_APPEND)));

  00274	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00277	81 7a 10 4f 1c
	00 00		 cmp	 DWORD PTR [edx+16], 7247 ; 00001c4fH
  0027e	75 09		 jne	 SHORT $LN38@gz_open
  00280	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv178[ebp], 0
  00287	eb 32		 jmp	 SHORT $LN39@gz_open
$LN38@gz_open:
  00289	8b 45 fc	 mov	 eax, DWORD PTR _exclusive$[ebp]
  0028c	f7 d8		 neg	 eax
  0028e	1b c0		 sbb	 eax, eax
  00290	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00295	0d 01 01 00 00	 or	 eax, 257		; 00000101H
  0029a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0029d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  002a0	81 ea b1 79 00
	00		 sub	 edx, 31153		; 000079b1H
  002a6	f7 da		 neg	 edx
  002a8	1b d2		 sbb	 edx, edx
  002aa	81 e2 08 fe ff
	ff		 and	 edx, -504		; fffffe08H
  002b0	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  002b6	0b c2		 or	 eax, edx
  002b8	89 45 e8	 mov	 DWORD PTR tv178[ebp], eax
$LN39@gz_open:
  002bb	8b 45 e8	 mov	 eax, DWORD PTR tv178[ebp]
  002be	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  002c3	89 45 f4	 mov	 DWORD PTR _oflag$[ebp], eax

; 239  : 
; 240  :     /* open the file with the appropriate flags (or just use fd) */
; 241  :     state->fd = fd > -1 ? fd : (
; 242  : #ifdef WIDECHAR
; 243  :         fd == -2 ? _wopen(path, oflag, 0666) :
; 244  : #endif
; 245  :         open((const char *)path, oflag, 0666));

  002c6	83 7d 0c ff	 cmp	 DWORD PTR _fd$[ebp], -1
  002ca	7e 08		 jle	 SHORT $LN42@gz_open
  002cc	8b 4d 0c	 mov	 ecx, DWORD PTR _fd$[ebp]
  002cf	89 4d e4	 mov	 DWORD PTR tv192[ebp], ecx
  002d2	eb 3e		 jmp	 SHORT $LN43@gz_open
$LN42@gz_open:
  002d4	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  002d8	75 1a		 jne	 SHORT $LN40@gz_open
  002da	68 b6 01 00 00	 push	 438			; 000001b6H
  002df	8b 55 f4	 mov	 edx, DWORD PTR _oflag$[ebp]
  002e2	52		 push	 edx
  002e3	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 __wopen
  002ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ef	89 45 e0	 mov	 DWORD PTR tv191[ebp], eax
  002f2	eb 18		 jmp	 SHORT $LN41@gz_open
$LN40@gz_open:
  002f4	68 b6 01 00 00	 push	 438			; 000001b6H
  002f9	8b 4d f4	 mov	 ecx, DWORD PTR _oflag$[ebp]
  002fc	51		 push	 ecx
  002fd	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  00300	52		 push	 edx
  00301	e8 00 00 00 00	 call	 _open
  00306	83 c4 0c	 add	 esp, 12			; 0000000cH
  00309	89 45 e0	 mov	 DWORD PTR tv191[ebp], eax
$LN41@gz_open:
  0030c	8b 45 e0	 mov	 eax, DWORD PTR tv191[ebp]
  0030f	89 45 e4	 mov	 DWORD PTR tv192[ebp], eax
$LN43@gz_open:
  00312	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00315	8b 55 e4	 mov	 edx, DWORD PTR tv192[ebp]
  00318	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 246  :     if (state->fd == -1) {

  0031b	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0031e	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  00322	75 22		 jne	 SHORT $LN4@gz_open

; 247  :         free(state->path);

  00324	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00327	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0032a	52		 push	 edx
  0032b	e8 00 00 00 00	 call	 _free
  00330	83 c4 04	 add	 esp, 4

; 248  :         free(state);

  00333	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 _free
  0033c	83 c4 04	 add	 esp, 4

; 249  :         return NULL;

  0033f	33 c0		 xor	 eax, eax
  00341	e9 89 00 00 00	 jmp	 $LN36@gz_open
$LN4@gz_open:

; 250  :     }
; 251  :     if (state->mode == GZ_APPEND) {

  00346	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00349	83 79 10 01	 cmp	 DWORD PTR [ecx+16], 1
  0034d	75 1f		 jne	 SHORT $LN3@gz_open

; 252  :         LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */

  0034f	6a 02		 push	 2
  00351	6a 00		 push	 0
  00353	6a 00		 push	 0
  00355	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00358	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 __lseeki64
  00361	83 c4 10	 add	 esp, 16			; 00000010H

; 253  :         state->mode = GZ_WRITE;         /* simplify later checks */

  00364	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00367	c7 41 10 b1 79
	00 00		 mov	 DWORD PTR [ecx+16], 31153 ; 000079b1H
$LN3@gz_open:

; 254  :     }
; 255  : 
; 256  :     /* save the current position for rewinding (only if reading) */
; 257  :     if (state->mode == GZ_READ) {

  0036e	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00371	81 7a 10 4f 1c
	00 00		 cmp	 DWORD PTR [edx+16], 7247 ; 00001c4fH
  00378	75 46		 jne	 SHORT $LN2@gz_open

; 258  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  0037a	6a 01		 push	 1
  0037c	6a 00		 push	 0
  0037e	6a 00		 push	 0
  00380	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00383	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00386	51		 push	 ecx
  00387	e8 00 00 00 00	 call	 __lseeki64
  0038c	83 c4 10	 add	 esp, 16			; 00000010H
  0038f	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00392	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00395	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 259  :         if (state->start == -1) state->start = 0;

  00398	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0039b	89 55 dc	 mov	 DWORD PTR tv319[ebp], edx
  0039e	8b 45 dc	 mov	 eax, DWORD PTR tv319[ebp]
  003a1	8b 4d dc	 mov	 ecx, DWORD PTR tv319[ebp]
  003a4	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  003a7	23 51 3c	 and	 edx, DWORD PTR [ecx+60]
  003aa	83 fa ff	 cmp	 edx, -1
  003ad	75 11		 jne	 SHORT $LN2@gz_open
  003af	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  003b2	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
  003b9	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$LN2@gz_open:

; 260  :     }
; 261  : 
; 262  :     /* initialize stream */
; 263  :     gz_reset(state);

  003c0	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  003c3	51		 push	 ecx
  003c4	e8 00 00 00 00	 call	 _gz_reset
  003c9	83 c4 04	 add	 esp, 4

; 264  : 
; 265  :     /* return stream */
; 266  :     return (gzFile)state;

  003cc	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
$LN36@gz_open:

; 267  : }

  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c3		 ret	 0
  003d3	90		 npad	 1
$LN45@gz_open:
  003d4	00 00 00 00	 DD	 $LN24@gz_open
  003d8	00 00 00 00	 DD	 $LN18@gz_open
  003dc	00 00 00 00	 DD	 $LN19@gz_open
  003e0	00 00 00 00	 DD	 $LN17@gz_open
  003e4	00 00 00 00	 DD	 $LN25@gz_open
  003e8	00 00 00 00	 DD	 $LN21@gz_open
  003ec	00 00 00 00	 DD	 $LN20@gz_open
  003f0	00 00 00 00	 DD	 $LN27@gz_open
  003f4	00 00 00 00	 DD	 $LN26@gz_open
  003f8	00 00 00 00	 DD	 $LN22@gz_open
  003fc	00 00 00 00	 DD	 $LN30@gz_open
$LN44@gz_open:
  00400	00		 DB	 0
  00401	0a		 DB	 10			; 0000000aH
  00402	0a		 DB	 10			; 0000000aH
  00403	0a		 DB	 10			; 0000000aH
  00404	0a		 DB	 10			; 0000000aH
  00405	0a		 DB	 10			; 0000000aH
  00406	0a		 DB	 10			; 0000000aH
  00407	0a		 DB	 10			; 0000000aH
  00408	0a		 DB	 10			; 0000000aH
  00409	0a		 DB	 10			; 0000000aH
  0040a	0a		 DB	 10			; 0000000aH
  0040b	0a		 DB	 10			; 0000000aH
  0040c	0a		 DB	 10			; 0000000aH
  0040d	0a		 DB	 10			; 0000000aH
  0040e	0a		 DB	 10			; 0000000aH
  0040f	0a		 DB	 10			; 0000000aH
  00410	0a		 DB	 10			; 0000000aH
  00411	0a		 DB	 10			; 0000000aH
  00412	0a		 DB	 10			; 0000000aH
  00413	0a		 DB	 10			; 0000000aH
  00414	0a		 DB	 10			; 0000000aH
  00415	0a		 DB	 10			; 0000000aH
  00416	0a		 DB	 10			; 0000000aH
  00417	0a		 DB	 10			; 0000000aH
  00418	0a		 DB	 10			; 0000000aH
  00419	0a		 DB	 10			; 0000000aH
  0041a	0a		 DB	 10			; 0000000aH
  0041b	01		 DB	 1
  0041c	0a		 DB	 10			; 0000000aH
  0041d	0a		 DB	 10			; 0000000aH
  0041e	0a		 DB	 10			; 0000000aH
  0041f	0a		 DB	 10			; 0000000aH
  00420	0a		 DB	 10			; 0000000aH
  00421	0a		 DB	 10			; 0000000aH
  00422	0a		 DB	 10			; 0000000aH
  00423	0a		 DB	 10			; 0000000aH
  00424	0a		 DB	 10			; 0000000aH
  00425	0a		 DB	 10			; 0000000aH
  00426	0a		 DB	 10			; 0000000aH
  00427	02		 DB	 2
  00428	0a		 DB	 10			; 0000000aH
  00429	03		 DB	 3
  0042a	0a		 DB	 10			; 0000000aH
  0042b	0a		 DB	 10			; 0000000aH
  0042c	0a		 DB	 10			; 0000000aH
  0042d	0a		 DB	 10			; 0000000aH
  0042e	0a		 DB	 10			; 0000000aH
  0042f	0a		 DB	 10			; 0000000aH
  00430	0a		 DB	 10			; 0000000aH
  00431	0a		 DB	 10			; 0000000aH
  00432	0a		 DB	 10			; 0000000aH
  00433	0a		 DB	 10			; 0000000aH
  00434	0a		 DB	 10			; 0000000aH
  00435	0a		 DB	 10			; 0000000aH
  00436	04		 DB	 4
  00437	0a		 DB	 10			; 0000000aH
  00438	0a		 DB	 10			; 0000000aH
  00439	0a		 DB	 10			; 0000000aH
  0043a	0a		 DB	 10			; 0000000aH
  0043b	05		 DB	 5
  0043c	0a		 DB	 10			; 0000000aH
  0043d	06		 DB	 6
  0043e	0a		 DB	 10			; 0000000aH
  0043f	0a		 DB	 10			; 0000000aH
  00440	0a		 DB	 10			; 0000000aH
  00441	0a		 DB	 10			; 0000000aH
  00442	0a		 DB	 10			; 0000000aH
  00443	0a		 DB	 10			; 0000000aH
  00444	0a		 DB	 10			; 0000000aH
  00445	0a		 DB	 10			; 0000000aH
  00446	0a		 DB	 10			; 0000000aH
  00447	07		 DB	 7
  00448	0a		 DB	 10			; 0000000aH
  00449	0a		 DB	 10			; 0000000aH
  0044a	0a		 DB	 10			; 0000000aH
  0044b	0a		 DB	 10			; 0000000aH
  0044c	08		 DB	 8
  0044d	09		 DB	 9
_gz_open ENDP
PUBLIC	_gzseek64@16
; Function compile flags: /Odtp
;	COMDAT _gzseek64@16
_TEXT	SEGMENT
tv156 = -40						; size = 4
tv282 = -36						; size = 8
tv211 = -28						; size = 8
_state$ = -20						; size = 4
_ret$ = -16						; size = 8
_n$ = -4						; size = 4
_file$ = 8						; size = 4
_offset$ = 12						; size = 8
_whence$ = 20						; size = 4
_gzseek64@16 PROC					; COMDAT

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 371  :     unsigned n;
; 372  :     z_off64_t ret;
; 373  :     gz_statep state;
; 374  : 
; 375  :     /* get internal structure and check integrity */
; 376  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 0b		 jne	 SHORT $LN15@gzseek64

; 377  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	83 ca ff	 or	 edx, -1
  00012	e9 bc 02 00 00	 jmp	 $LN16@gzseek64
$LN15@gzseek64:

; 378  :     state = (gz_statep)file;

  00017	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0001a	89 45 ec	 mov	 DWORD PTR _state$[ebp], eax

; 379  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00020	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00027	74 17		 je	 SHORT $LN14@gzseek64
  00029	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0002c	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00033	74 0b		 je	 SHORT $LN14@gzseek64

; 380  :         return -1;

  00035	83 c8 ff	 or	 eax, -1
  00038	83 ca ff	 or	 edx, -1
  0003b	e9 93 02 00 00	 jmp	 $LN16@gzseek64
$LN14@gzseek64:

; 381  : 
; 382  :     /* check that there's no error */
; 383  :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00040	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00043	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00047	74 14		 je	 SHORT $LN13@gzseek64
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0004c	83 79 5c fb	 cmp	 DWORD PTR [ecx+92], -5	; fffffffbH
  00050	74 0b		 je	 SHORT $LN13@gzseek64

; 384  :         return -1;

  00052	83 c8 ff	 or	 eax, -1
  00055	83 ca ff	 or	 edx, -1
  00058	e9 76 02 00 00	 jmp	 $LN16@gzseek64
$LN13@gzseek64:

; 385  : 
; 386  :     /* can only seek from start or relative to current position */
; 387  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  0005d	83 7d 14 00	 cmp	 DWORD PTR _whence$[ebp], 0
  00061	74 11		 je	 SHORT $LN12@gzseek64
  00063	83 7d 14 01	 cmp	 DWORD PTR _whence$[ebp], 1
  00067	74 0b		 je	 SHORT $LN12@gzseek64

; 388  :         return -1;

  00069	83 c8 ff	 or	 eax, -1
  0006c	83 ca ff	 or	 edx, -1
  0006f	e9 5f 02 00 00	 jmp	 $LN16@gzseek64
$LN12@gzseek64:

; 389  : 
; 390  :     /* normalize offset to a SEEK_CUR specification */
; 391  :     if (whence == SEEK_SET)

  00074	83 7d 14 00	 cmp	 DWORD PTR _whence$[ebp], 0
  00078	75 17		 jne	 SHORT $LN11@gzseek64

; 392  :         offset -= state->x.pos;

  0007a	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00080	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  00083	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  00086	1b 4a 0c	 sbb	 ecx, DWORD PTR [edx+12]
  00089	89 45 0c	 mov	 DWORD PTR _offset$[ebp], eax
  0008c	89 4d 10	 mov	 DWORD PTR _offset$[ebp+4], ecx
  0008f	eb 1e		 jmp	 SHORT $LN10@gzseek64
$LN11@gzseek64:

; 393  :     else if (state->seek)

  00091	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00094	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00098	74 15		 je	 SHORT $LN10@gzseek64

; 394  :         offset += state->skip;

  0009a	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  000a0	03 48 50	 add	 ecx, DWORD PTR [eax+80]
  000a3	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  000a6	13 50 54	 adc	 edx, DWORD PTR [eax+84]
  000a9	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  000ac	89 55 10	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN10@gzseek64:

; 395  :     state->seek = 0;

  000af	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000b2	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 396  : 
; 397  :     /* if within raw area while reading, just go there */
; 398  :     if (state->mode == GZ_READ && state->how == COPY &&
; 399  :             state->x.pos + offset >= 0) {

  000b9	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000bc	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  000c3	0f 85 db 00 00
	00		 jne	 $LN8@gzseek64
  000c9	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000cc	83 7a 30 01	 cmp	 DWORD PTR [edx+48], 1
  000d0	0f 85 ce 00 00
	00		 jne	 $LN8@gzseek64
  000d6	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000d9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000dc	03 4d 0c	 add	 ecx, DWORD PTR _offset$[ebp]
  000df	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000e2	13 55 10	 adc	 edx, DWORD PTR _offset$[ebp+4]
  000e5	89 4d e4	 mov	 DWORD PTR tv211[ebp], ecx
  000e8	89 55 e8	 mov	 DWORD PTR tv211[ebp+4], edx
  000eb	0f 88 b3 00 00
	00		 js	 $LN8@gzseek64
  000f1	7f 0a		 jg	 SHORT $LN20@gzseek64
  000f3	83 7d e4 00	 cmp	 DWORD PTR tv211[ebp], 0
  000f7	0f 82 a7 00 00
	00		 jb	 $LN8@gzseek64
$LN20@gzseek64:

; 400  :         ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);

  000fd	6a 01		 push	 1
  000ff	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00102	8b 08		 mov	 ecx, DWORD PTR [eax]
  00104	33 d2		 xor	 edx, edx
  00106	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00109	2b c1		 sub	 eax, ecx
  0010b	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  0010e	1b ca		 sbb	 ecx, edx
  00110	51		 push	 ecx
  00111	50		 push	 eax
  00112	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00115	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 __lseeki64
  0011e	83 c4 10	 add	 esp, 16			; 00000010H
  00121	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax
  00124	89 55 f4	 mov	 DWORD PTR _ret$[ebp+4], edx

; 401  :         if (ret == -1)

  00127	8b 4d f0	 mov	 ecx, DWORD PTR _ret$[ebp]
  0012a	23 4d f4	 and	 ecx, DWORD PTR _ret$[ebp+4]
  0012d	83 f9 ff	 cmp	 ecx, -1
  00130	75 0b		 jne	 SHORT $LN7@gzseek64

; 402  :             return -1;

  00132	83 c8 ff	 or	 eax, -1
  00135	83 ca ff	 or	 edx, -1
  00138	e9 96 01 00 00	 jmp	 $LN16@gzseek64
$LN7@gzseek64:

; 403  :         state->x.have = 0;

  0013d	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00140	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 404  :         state->eof = 0;

  00146	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00149	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 405  :         state->past = 0;

  00150	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00153	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 406  :         state->seek = 0;

  0015a	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0015d	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 407  :         gz_error(state, Z_OK, NULL);

  00164	6a 00		 push	 0
  00166	6a 00		 push	 0
  00168	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _gz_error
  00171	83 c4 0c	 add	 esp, 12			; 0000000cH

; 408  :         state->strm.avail_in = 0;

  00174	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00177	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 409  :         state->x.pos += offset;

  0017e	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00181	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00184	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  00187	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0018a	13 4d 10	 adc	 ecx, DWORD PTR _offset$[ebp+4]
  0018d	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00190	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00193	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 410  :         return state->x.pos;

  00196	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00199	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0019c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0019f	e9 2f 01 00 00	 jmp	 $LN16@gzseek64
$LN8@gzseek64:

; 411  :     }
; 412  : 
; 413  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 414  :     if (offset < 0) {

  001a4	83 7d 10 00	 cmp	 DWORD PTR _offset$[ebp+4], 0
  001a8	7f 66		 jg	 SHORT $LN6@gzseek64
  001aa	7c 06		 jl	 SHORT $LN21@gzseek64
  001ac	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  001b0	73 5e		 jae	 SHORT $LN6@gzseek64
$LN21@gzseek64:

; 415  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  001b2	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  001b5	81 7a 10 4f 1c
	00 00		 cmp	 DWORD PTR [edx+16], 7247 ; 00001c4fH
  001bc	74 0b		 je	 SHORT $LN5@gzseek64

; 416  :             return -1;

  001be	83 c8 ff	 or	 eax, -1
  001c1	83 ca ff	 or	 edx, -1
  001c4	e9 0a 01 00 00	 jmp	 $LN16@gzseek64
$LN5@gzseek64:

; 417  :         offset += state->x.pos;

  001c9	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  001cc	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  001cf	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  001d2	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  001d5	13 50 0c	 adc	 edx, DWORD PTR [eax+12]
  001d8	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  001db	89 55 10	 mov	 DWORD PTR _offset$[ebp+4], edx

; 418  :         if (offset < 0)                     /* before start of file! */

  001de	83 7d 10 00	 cmp	 DWORD PTR _offset$[ebp+4], 0
  001e2	7f 13		 jg	 SHORT $LN4@gzseek64
  001e4	7c 06		 jl	 SHORT $LN22@gzseek64
  001e6	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  001ea	73 0b		 jae	 SHORT $LN4@gzseek64
$LN22@gzseek64:

; 419  :             return -1;

  001ec	83 c8 ff	 or	 eax, -1
  001ef	83 ca ff	 or	 edx, -1
  001f2	e9 dc 00 00 00	 jmp	 $LN16@gzseek64
$LN4@gzseek64:

; 420  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  001f7	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  001fa	50		 push	 eax
  001fb	e8 00 00 00 00	 call	 _gzrewind@4
  00200	83 f8 ff	 cmp	 eax, -1
  00203	75 0b		 jne	 SHORT $LN6@gzseek64

; 421  :             return -1;

  00205	83 c8 ff	 or	 eax, -1
  00208	83 ca ff	 or	 edx, -1
  0020b	e9 c3 00 00 00	 jmp	 $LN16@gzseek64
$LN6@gzseek64:

; 422  :     }
; 423  : 
; 424  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 425  :     if (state->mode == GZ_READ) {

  00210	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00213	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0021a	0f 85 83 00 00
	00		 jne	 $LN2@gzseek64

; 426  :         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
; 427  :             (unsigned)offset : state->x.have;

  00220	33 d2		 xor	 edx, edx
  00222	75 29		 jne	 SHORT $LN18@gzseek64
  00224	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00227	8b 08		 mov	 ecx, DWORD PTR [eax]
  00229	33 d2		 xor	 edx, edx
  0022b	89 4d dc	 mov	 DWORD PTR tv282[ebp], ecx
  0022e	89 55 e0	 mov	 DWORD PTR tv282[ebp+4], edx
  00231	8b 45 e0	 mov	 eax, DWORD PTR tv282[ebp+4]
  00234	3b 45 10	 cmp	 eax, DWORD PTR _offset$[ebp+4]
  00237	7f 14		 jg	 SHORT $LN18@gzseek64
  00239	7c 08		 jl	 SHORT $LN23@gzseek64
  0023b	8b 4d dc	 mov	 ecx, DWORD PTR tv282[ebp]
  0023e	3b 4d 0c	 cmp	 ecx, DWORD PTR _offset$[ebp]
  00241	77 0a		 ja	 SHORT $LN18@gzseek64
$LN23@gzseek64:
  00243	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00246	8b 02		 mov	 eax, DWORD PTR [edx]
  00248	89 45 d8	 mov	 DWORD PTR tv156[ebp], eax
  0024b	eb 06		 jmp	 SHORT $LN19@gzseek64
$LN18@gzseek64:
  0024d	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00250	89 4d d8	 mov	 DWORD PTR tv156[ebp], ecx
$LN19@gzseek64:
  00253	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  00256	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 428  :         state->x.have -= n;

  00259	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0025c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025e	2b 4d fc	 sub	 ecx, DWORD PTR _n$[ebp]
  00261	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00264	89 0a		 mov	 DWORD PTR [edx], ecx

; 429  :         state->x.next += n;

  00266	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00269	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026c	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  0026f	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00272	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 430  :         state->x.pos += n;

  00275	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00278	33 c9		 xor	 ecx, ecx
  0027a	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0027d	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00280	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00283	13 d1		 adc	 edx, ecx
  00285	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00288	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0028b	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 431  :         offset -= n;

  0028e	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  00291	33 c0		 xor	 eax, eax
  00293	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00296	2b ca		 sub	 ecx, edx
  00298	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  0029b	1b d0		 sbb	 edx, eax
  0029d	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  002a0	89 55 10	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN2@gzseek64:

; 432  :     }
; 433  : 
; 434  :     /* request skip (if not zero) */
; 435  :     if (offset) {

  002a3	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  002a6	0b 45 10	 or	 eax, DWORD PTR _offset$[ebp+4]
  002a9	74 19		 je	 SHORT $LN1@gzseek64

; 436  :         state->seek = 1;

  002ab	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  002ae	c7 41 58 01 00
	00 00		 mov	 DWORD PTR [ecx+88], 1

; 437  :         state->skip = offset;

  002b5	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  002b8	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  002bb	89 42 50	 mov	 DWORD PTR [edx+80], eax
  002be	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  002c1	89 4a 54	 mov	 DWORD PTR [edx+84], ecx
$LN1@gzseek64:

; 438  :     }
; 439  :     return state->x.pos + offset;

  002c4	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  002c7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002ca	03 45 0c	 add	 eax, DWORD PTR _offset$[ebp]
  002cd	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  002d0	13 55 10	 adc	 edx, DWORD PTR _offset$[ebp+4]
$LN16@gzseek64:

; 440  : }

  002d3	8b e5		 mov	 esp, ebp
  002d5	5d		 pop	 ebp
  002d6	c2 10 00	 ret	 16			; 00000010H
_gzseek64@16 ENDP
_TEXT	ENDS
PUBLIC	_gzopen_w@8
; Function compile flags: /Odtp
;	COMDAT _gzopen_w@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen_w@8 PROC					; COMDAT

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  :     return gz_open(path, -2, mode);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00006	50		 push	 eax
  00007	6a fe		 push	 -2			; fffffffeH
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _gz_open
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 312  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_gzopen_w@8 ENDP
_TEXT	ENDS
PUBLIC	_gzdopen@8
; Function compile flags: /Odtp
;	COMDAT _gzdopen@8
_TEXT	SEGMENT
_path$ = -8						; size = 4
_gz$ = -4						; size = 4
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzdopen@8 PROC						; COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 290  :     char *path;         /* identifier for error messages */
; 291  :     gzFile gz;
; 292  : 
; 293  :     if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)

  00006	83 7d 08 ff	 cmp	 DWORD PTR _fd$[ebp], -1
  0000a	74 13		 je	 SHORT $LN1@gzdopen
  0000c	6a 13		 push	 19			; 00000013H
  0000e	e8 00 00 00 00	 call	 _malloc
  00013	83 c4 04	 add	 esp, 4
  00016	89 45 f8	 mov	 DWORD PTR _path$[ebp], eax
  00019	83 7d f8 00	 cmp	 DWORD PTR _path$[ebp], 0
  0001d	75 04		 jne	 SHORT $LN2@gzdopen
$LN1@gzdopen:

; 294  :         return NULL;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 3d		 jmp	 SHORT $LN3@gzdopen
$LN2@gzdopen:

; 295  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 296  :     (void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);

  00023	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00026	50		 push	 eax
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  0002c	6a 13		 push	 19			; 00000013H
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _path$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 __snprintf
  00037	83 c4 10	 add	 esp, 16			; 00000010H

; 297  : #else
; 298  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */
; 299  : #endif
; 300  :     gz = gz_open(path, fd, mode);

  0003a	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  0003d	52		 push	 edx
  0003e	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00041	50		 push	 eax
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _path$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 _gz_open
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	89 45 fc	 mov	 DWORD PTR _gz$[ebp], eax

; 301  :     free(path);

  00051	8b 55 f8	 mov	 edx, DWORD PTR _path$[ebp]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 _free
  0005a	83 c4 04	 add	 esp, 4

; 302  :     return gz;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _gz$[ebp]
$LN3@gzdopen:

; 303  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
_gzdopen@8 ENDP
_TEXT	ENDS
PUBLIC	_gzopen@8
; Function compile flags: /Odtp
;	COMDAT _gzopen@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen@8 PROC						; COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 274  :     return gz_open(path, -1, mode);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00006	50		 push	 eax
  00007	6a ff		 push	 -1
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _gz_open
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_gzopen@8 ENDP
PUBLIC	_gzseek@12
; Function compile flags: /Odtp
;	COMDAT _gzseek@12
_TEXT	SEGMENT
tv73 = -20						; size = 4
tv95 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek@12 PROC						; COMDAT

; 447  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 448  :     z_off64_t ret;
; 449  : 
; 450  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00006	8b 45 10	 mov	 eax, DWORD PTR _whence$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0000d	99		 cdq
  0000e	52		 push	 edx
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _gzseek64@16
  00019	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  0001c	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 451  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00022	99		 cdq
  00023	89 45 f0	 mov	 DWORD PTR tv95[ebp], eax
  00026	89 55 f4	 mov	 DWORD PTR tv95[ebp+4], edx
  00029	8b 55 f8	 mov	 edx, DWORD PTR _ret$[ebp]
  0002c	3b 55 f0	 cmp	 edx, DWORD PTR tv95[ebp]
  0002f	75 10		 jne	 SHORT $LN3@gzseek
  00031	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp+4]
  00034	3b 45 f4	 cmp	 eax, DWORD PTR tv95[ebp+4]
  00037	75 08		 jne	 SHORT $LN3@gzseek
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  0003c	89 4d ec	 mov	 DWORD PTR tv73[ebp], ecx
  0003f	eb 07		 jmp	 SHORT $LN4@gzseek
$LN3@gzseek:
  00041	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
$LN4@gzseek:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv73[ebp]

; 452  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
_gzseek@12 ENDP
END
