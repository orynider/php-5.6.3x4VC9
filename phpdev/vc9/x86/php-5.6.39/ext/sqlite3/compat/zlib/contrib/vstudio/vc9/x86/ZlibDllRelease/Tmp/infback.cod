; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\infback.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
EXTRN	_inflate_fast:PROC
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateBackEnd@4
; Function compile flags: /Odtp
; File c:\public\php\phpdev\vc9\php-5.6.33-src\ext\sqlite3\compat\zlib\infback.c
;	COMDAT _inflateBackEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateBackEnd@4 PROC					; COMDAT

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00003	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00007	74 12		 je	 SHORT $LN1@inflateBac
  00009	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000c	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00010	74 09		 je	 SHORT $LN1@inflateBac
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00015	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00019	75 07		 jne	 SHORT $LN2@inflateBac
$LN1@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  0001b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00020	eb 25		 jmp	 SHORT $LN3@inflateBac
$LN2@inflateBac:

; 636  :     ZFREE(strm, strm->state);

  00022	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00025	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00033	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00036	ff d1		 call	 ecx
  00038	83 c4 08	 add	 esp, 8

; 637  :     strm->state = Z_NULL;

  0003b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0003e	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  00045	33 c0		 xor	 eax, eax
$LN3@inflateBac:

; 640  : }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
_inflateBackEnd@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 121  :     state->distcode = distfix;

  00017	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001a	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 122  :     state->distbits = 5;

  00021	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00024	c7 40 5c 05 00
	00 00		 mov	 DWORD PTR [eax+92], 5

; 123  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
PUBLIC	_inflateBackInit_@20
; Function compile flags: /Odtp
;	COMDAT _inflateBackInit_@20
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_window$ = 16						; size = 4
_version$ = 20						; size = 4
_stream_size$ = 24					; size = 4
_inflateBackInit_@20 PROC				; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00004	83 7d 14 00	 cmp	 DWORD PTR _version$[ebp], 0
  00008	74 17		 je	 SHORT $LN6@inflateBac@2
  0000a	8b 45 14	 mov	 eax, DWORD PTR _version$[ebp]
  0000d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00010	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR ??_C@_06CJNJFBNP@1?42?411?$AA@
  00017	3b ca		 cmp	 ecx, edx
  00019	75 06		 jne	 SHORT $LN6@inflateBac@2
  0001b	83 7d 18 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	74 0a		 je	 SHORT $LN7@inflateBac@2
$LN6@inflateBac@2:

; 39   :         return Z_VERSION_ERROR;

  00021	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00026	e9 d0 00 00 00	 jmp	 $LN8@inflateBac@2
$LN7@inflateBac@2:

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  0002b	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0002f	74 12		 je	 SHORT $LN4@inflateBac@2
  00031	83 7d 10 00	 cmp	 DWORD PTR _window$[ebp], 0
  00035	74 0c		 je	 SHORT $LN4@inflateBac@2
  00037	83 7d 0c 08	 cmp	 DWORD PTR _windowBits$[ebp], 8
  0003b	7c 06		 jl	 SHORT $LN4@inflateBac@2
  0003d	83 7d 0c 0f	 cmp	 DWORD PTR _windowBits$[ebp], 15 ; 0000000fH
  00041	7e 0a		 jle	 SHORT $LN5@inflateBac@2
$LN4@inflateBac@2:

; 42   :         return Z_STREAM_ERROR;

  00043	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00048	e9 ae 00 00 00	 jmp	 $LN8@inflateBac@2
$LN5@inflateBac@2:

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  0004d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00050	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00057	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0005e	75 14		 jne	 SHORT $LN3@inflateBac@2

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  00060	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00063	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _zcalloc

; 49   :         strm->opaque = (voidpf)0;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0006d	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$LN3@inflateBac@2:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  00074	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00077	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0007b	75 0a		 jne	 SHORT $LN2@inflateBac@2

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  0007d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00080	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _zcfree
$LN2@inflateBac@2:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 59   :                                                sizeof(struct inflate_state));

  00087	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0008c	6a 01		 push	 1
  0008e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00091	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00094	51		 push	 ecx
  00095	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00098	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0009b	ff d0		 call	 eax
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000a3	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  000a7	75 07		 jne	 SHORT $LN1@inflateBac@2
  000a9	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000ae	eb 4b		 jmp	 SHORT $LN8@inflateBac@2
$LN1@inflateBac@2:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000b6	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 63   :     state->dmax = 32768U;

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000bc	c7 40 18 00 80
	00 00		 mov	 DWORD PTR [eax+24], 32768 ; 00008000H

; 64   :     state->wbits = (uInt)windowBits;

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000c6	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  000c9	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 65   :     state->wsize = 1U << windowBits;

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000d4	d3 e0		 shl	 eax, cl
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000d9	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 66   :     state->window = window;

  000dc	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000df	8b 45 10	 mov	 eax, DWORD PTR _window$[ebp]
  000e2	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 67   :     state->wnext = 0;

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000e8	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 68   :     state->whave = 0;

  000ef	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000f2	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 69   :     return Z_OK;

  000f9	33 c0		 xor	 eax, eax
$LN8@inflateBac@2:

; 70   : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 14 00	 ret	 20			; 00000014H
_inflateBackInit_@20 ENDP
PUBLIC	_inflateBack@20
; Function compile flags: /Odtp
;	COMDAT _inflateBack@20
_TEXT	SEGMENT
tv140 = -64						; size = 4
tv78 = -60						; size = 4
tv74 = -56						; size = 4
_state$ = -52						; size = 4
_from$ = -48						; size = 4
_copy$ = -44						; size = 4
_hold$ = -40						; size = 4
_ret$ = -36						; size = 4
_next$ = -32						; size = 4
_left$ = -28						; size = 4
_bits$ = -24						; size = 4
_len$ = -20						; size = 4
_have$ = -16						; size = 4
_here$ = -12						; size = 4
_last$ = -8						; size = 4
_put$ = -4						; size = 4
_strm$ = 8						; size = 4
_in$ = 12						; size = 4
_in_desc$ = 16						; size = 4
_out$ = 20						; size = 4
_out_desc$ = 24						; size = 4
_inflateBack@20 PROC					; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN333@inflateBac@3
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN334@inflateBac@3
$LN333@inflateBac@3:

; 274  :         return Z_STREAM_ERROR;

  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 4c 13 00 00	 jmp	 $LN335@inflateBac@3
$LN334@inflateBac@3:

; 275  :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 cc	 mov	 DWORD PTR _state$[ebp], edx

; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 279  :     state->mode = TYPE;

  00032	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 280  :     state->last = 0;

  0003c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0003f	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 281  :     state->whave = 0;

  00046	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 282  :     next = strm->next_in;

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	89 55 e0	 mov	 DWORD PTR _next$[ebp], edx

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  00058	83 7d e0 00	 cmp	 DWORD PTR _next$[ebp], 0
  0005c	74 0b		 je	 SHORT $LN337@inflateBac@3
  0005e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00061	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00064	89 4d c8	 mov	 DWORD PTR tv74[ebp], ecx
  00067	eb 07		 jmp	 SHORT $LN338@inflateBac@3
$LN337@inflateBac@3:
  00069	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN338@inflateBac@3:
  00070	8b 55 c8	 mov	 edx, DWORD PTR tv74[ebp]
  00073	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 284  :     hold = 0;

  00076	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0

; 285  :     bits = 0;

  0007d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0

; 286  :     put = state->window;

  00084	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00087	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0008a	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx

; 287  :     left = state->wsize;

  0008d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00090	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00093	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
$LN332@inflateBac@3:

; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00096	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00099	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0009c	89 55 c4	 mov	 DWORD PTR tv78[ebp], edx
  0009f	8b 45 c4	 mov	 eax, DWORD PTR tv78[ebp]
  000a2	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  000a7	89 45 c4	 mov	 DWORD PTR tv78[ebp], eax
  000aa	83 7d c4 12	 cmp	 DWORD PTR tv78[ebp], 18	; 00000012H
  000ae	0f 87 95 12 00
	00		 ja	 $LN1@inflateBac@3
  000b4	8b 4d c4	 mov	 ecx, DWORD PTR tv78[ebp]
  000b7	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN339@inflateBac@3[ecx]
  000be	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN340@inflateBac@3[edx*4]
$LN328@inflateBac@3:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  000c5	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  000c8	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000cc	74 2f		 je	 SHORT $LN320@inflateBac@3
$LN326@inflateBac@3:

; 295  :                 BYTEBITS();

  000ce	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  000d1	83 e1 07	 and	 ecx, 7
  000d4	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  000d7	d3 ea		 shr	 edx, cl
  000d9	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  000dc	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  000df	83 e0 07	 and	 eax, 7
  000e2	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  000e5	2b c8		 sub	 ecx, eax
  000e7	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  000ea	33 d2		 xor	 edx, edx
  000ec	75 e0		 jne	 SHORT $LN326@inflateBac@3

; 296  :                 state->mode = DONE;

  000ee	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  000f1	c7 40 04 50 3f
	00 00		 mov	 DWORD PTR [eax+4], 16208 ; 00003f50H

; 297  :                 break;

  000f8	e9 55 12 00 00	 jmp	 $LN329@inflateBac@3
$LN320@inflateBac@3:

; 298  :             }
; 299  :             NEEDBITS(3);

  000fd	83 7d e8 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00101	73 66		 jae	 SHORT $LN322@inflateBac@3
$LN315@inflateBac@3:
  00103	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00107	75 2a		 jne	 SHORT $LN314@inflateBac@3
  00109	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  0010c	51		 push	 ecx
  0010d	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00110	52		 push	 edx
  00111	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00114	83 c4 08	 add	 esp, 8
  00117	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0011a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0011e	75 13		 jne	 SHORT $LN314@inflateBac@3
  00120	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00127	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0012e	e9 24 12 00 00	 jmp	 $inf_leave$77704
$LN314@inflateBac@3:
  00133	33 c0		 xor	 eax, eax
  00135	75 cc		 jne	 SHORT $LN315@inflateBac@3
  00137	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0013a	83 e9 01	 sub	 ecx, 1
  0013d	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00140	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00143	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00146	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00149	d3 e0		 shl	 eax, cl
  0014b	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  0014e	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00151	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00154	83 c1 01	 add	 ecx, 1
  00157	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  0015a	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0015d	83 c2 08	 add	 edx, 8
  00160	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00163	33 c0		 xor	 eax, eax
  00165	75 9c		 jne	 SHORT $LN315@inflateBac@3
  00167	eb 94		 jmp	 SHORT $LN320@inflateBac@3
$LN322@inflateBac@3:
  00169	33 c9		 xor	 ecx, ecx
  0016b	75 90		 jne	 SHORT $LN320@inflateBac@3

; 300  :             state->last = BITS(1);

  0016d	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00170	83 e2 01	 and	 edx, 1
  00173	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00176	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN310@inflateBac@3:

; 301  :             DROPBITS(1);

  00179	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0017c	d1 e9		 shr	 ecx, 1
  0017e	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  00181	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00184	83 ea 01	 sub	 edx, 1
  00187	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0018a	33 c0		 xor	 eax, eax
  0018c	75 eb		 jne	 SHORT $LN310@inflateBac@3

; 302  :             switch (BITS(2)) {

  0018e	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00191	83 e1 03	 and	 ecx, 3
  00194	89 4d c0	 mov	 DWORD PTR tv140[ebp], ecx
  00197	83 7d c0 03	 cmp	 DWORD PTR tv140[ebp], 3
  0019b	77 4e		 ja	 SHORT $LN301@inflateBac@3
  0019d	8b 55 c0	 mov	 edx, DWORD PTR tv140[ebp]
  001a0	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN341@inflateBac@3[edx*4]
$LN305@inflateBac@3:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  001a7	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  001aa	c7 40 04 41 3f
	00 00		 mov	 DWORD PTR [eax+4], 16193 ; 00003f41H

; 307  :                 break;

  001b1	eb 38		 jmp	 SHORT $LN301@inflateBac@3
$LN304@inflateBac@3:

; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  001b3	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  001b6	51		 push	 ecx
  001b7	e8 00 00 00 00	 call	 _fixedtables
  001bc	83 c4 04	 add	 esp, 4

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */

  001bf	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  001c2	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H

; 313  :                 break;

  001c9	eb 20		 jmp	 SHORT $LN301@inflateBac@3
$LN303@inflateBac@3:

; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;

  001cb	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  001ce	c7 40 04 44 3f
	00 00		 mov	 DWORD PTR [eax+4], 16196 ; 00003f44H

; 318  :                 break;

  001d5	eb 14		 jmp	 SHORT $LN301@inflateBac@3
$LN302@inflateBac@3:

; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  001d7	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  001da	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 321  :                 state->mode = BAD;

  001e1	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  001e4	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H
$LN301@inflateBac@3:

; 322  :             }
; 323  :             DROPBITS(2);

  001eb	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  001ee	c1 e8 02	 shr	 eax, 2
  001f1	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  001f4	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  001f7	83 e9 02	 sub	 ecx, 2
  001fa	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  001fd	33 d2		 xor	 edx, edx
  001ff	75 ea		 jne	 SHORT $LN301@inflateBac@3

; 324  :             break;

  00201	e9 4c 11 00 00	 jmp	 $LN329@inflateBac@3
$LN297@inflateBac@3:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  00206	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00209	83 e1 07	 and	 ecx, 7
  0020c	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  0020f	d3 e8		 shr	 eax, cl
  00211	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00214	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00217	83 e1 07	 and	 ecx, 7
  0021a	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0021d	2b d1		 sub	 edx, ecx
  0021f	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00222	33 c0		 xor	 eax, eax
  00224	75 e0		 jne	 SHORT $LN297@inflateBac@3
$LN291@inflateBac@3:

; 329  :             NEEDBITS(32);

  00226	83 7d e8 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  0022a	73 66		 jae	 SHORT $LN293@inflateBac@3
$LN286@inflateBac@3:
  0022c	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00230	75 2a		 jne	 SHORT $LN285@inflateBac@3
  00232	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00235	51		 push	 ecx
  00236	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00239	52		 push	 edx
  0023a	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0023d	83 c4 08	 add	 esp, 8
  00240	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00243	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00247	75 13		 jne	 SHORT $LN285@inflateBac@3
  00249	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00250	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00257	e9 fb 10 00 00	 jmp	 $inf_leave$77704
$LN285@inflateBac@3:
  0025c	33 c0		 xor	 eax, eax
  0025e	75 cc		 jne	 SHORT $LN286@inflateBac@3
  00260	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00263	83 e9 01	 sub	 ecx, 1
  00266	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00269	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  0026c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0026f	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00272	d3 e0		 shl	 eax, cl
  00274	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00277	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0027a	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0027d	83 c1 01	 add	 ecx, 1
  00280	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00283	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00286	83 c2 08	 add	 edx, 8
  00289	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0028c	33 c0		 xor	 eax, eax
  0028e	75 9c		 jne	 SHORT $LN286@inflateBac@3
  00290	eb 94		 jmp	 SHORT $LN291@inflateBac@3
$LN293@inflateBac@3:
  00292	33 c9		 xor	 ecx, ecx
  00294	75 90		 jne	 SHORT $LN291@inflateBac@3

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00296	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00299	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0029f	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  002a2	c1 e8 10	 shr	 eax, 16			; 00000010H
  002a5	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  002aa	3b d0		 cmp	 edx, eax
  002ac	74 19		 je	 SHORT $LN281@inflateBac@3

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  002ae	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  002b1	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 332  :                 state->mode = BAD;

  002b8	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  002bb	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 333  :                 break;

  002c2	e9 8b 10 00 00	 jmp	 $LN329@inflateBac@3
$LN281@inflateBac@3:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;

  002c7	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  002ca	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  002cf	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  002d2	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN280@inflateBac@3:

; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  002d5	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  002dc	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  002e3	33 d2		 xor	 edx, edx
  002e5	75 ee		 jne	 SHORT $LN280@inflateBac@3
$LN277@inflateBac@3:

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  002e7	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  002ea	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  002ee	0f 84 ec 00 00
	00		 je	 $LN276@inflateBac@3

; 342  :                 copy = state->length;

  002f4	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  002f7	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  002fa	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
$LN275@inflateBac@3:

; 343  :                 PULL();

  002fd	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00301	75 2a		 jne	 SHORT $LN274@inflateBac@3
  00303	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  00306	50		 push	 eax
  00307	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0030a	51		 push	 ecx
  0030b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0030e	83 c4 08	 add	 esp, 8
  00311	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00314	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00318	75 13		 jne	 SHORT $LN274@inflateBac@3
  0031a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00321	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00328	e9 2a 10 00 00	 jmp	 $inf_leave$77704
$LN274@inflateBac@3:
  0032d	33 d2		 xor	 edx, edx
  0032f	75 cc		 jne	 SHORT $LN275@inflateBac@3
$LN270@inflateBac@3:

; 344  :                 ROOM();

  00331	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  00335	75 3d		 jne	 SHORT $LN269@inflateBac@3
  00337	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0033a	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0033d	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  00340	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00343	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00346	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  00349	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0034c	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  0034f	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00352	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00355	50		 push	 eax
  00356	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  00359	51		 push	 ecx
  0035a	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  0035d	52		 push	 edx
  0035e	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00361	83 c4 0c	 add	 esp, 12			; 0000000cH
  00364	85 c0		 test	 eax, eax
  00366	74 0c		 je	 SHORT $LN269@inflateBac@3
  00368	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0036f	e9 e3 0f 00 00	 jmp	 $inf_leave$77704
$LN269@inflateBac@3:
  00374	33 c0		 xor	 eax, eax
  00376	75 b9		 jne	 SHORT $LN270@inflateBac@3

; 345  :                 if (copy > have) copy = have;

  00378	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  0037b	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  0037e	76 06		 jbe	 SHORT $LN265@inflateBac@3
  00380	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00383	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
$LN265@inflateBac@3:

; 346  :                 if (copy > left) copy = left;

  00386	8b 45 d4	 mov	 eax, DWORD PTR _copy$[ebp]
  00389	3b 45 e4	 cmp	 eax, DWORD PTR _left$[ebp]
  0038c	76 06		 jbe	 SHORT $LN264@inflateBac@3
  0038e	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  00391	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN264@inflateBac@3:

; 347  :                 zmemcpy(put, next, copy);

  00394	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  00397	52		 push	 edx
  00398	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0039b	50		 push	 eax
  0039c	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  0039f	51		 push	 ecx
  003a0	e8 00 00 00 00	 call	 _memcpy
  003a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  :                 have -= copy;

  003a8	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  003ab	2b 55 d4	 sub	 edx, DWORD PTR _copy$[ebp]
  003ae	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 349  :                 next += copy;

  003b1	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  003b4	03 45 d4	 add	 eax, DWORD PTR _copy$[ebp]
  003b7	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax

; 350  :                 left -= copy;

  003ba	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  003bd	2b 4d d4	 sub	 ecx, DWORD PTR _copy$[ebp]
  003c0	89 4d e4	 mov	 DWORD PTR _left$[ebp], ecx

; 351  :                 put += copy;

  003c3	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  003c6	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  003c9	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 352  :                 state->length -= copy;

  003cc	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  003cf	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  003d2	2b 4d d4	 sub	 ecx, DWORD PTR _copy$[ebp]
  003d5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  003d8	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 353  :             }

  003db	e9 07 ff ff ff	 jmp	 $LN277@inflateBac@3
$LN276@inflateBac@3:

; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  003e0	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  003e3	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 356  :             break;

  003ea	e9 63 0f 00 00	 jmp	 $LN329@inflateBac@3
$LN259@inflateBac@3:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  003ef	83 7d e8 0e	 cmp	 DWORD PTR _bits$[ebp], 14 ; 0000000eH
  003f3	73 66		 jae	 SHORT $LN261@inflateBac@3
$LN254@inflateBac@3:
  003f5	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  003f9	75 2a		 jne	 SHORT $LN253@inflateBac@3
  003fb	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  003fe	51		 push	 ecx
  003ff	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00402	52		 push	 edx
  00403	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00406	83 c4 08	 add	 esp, 8
  00409	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0040c	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00410	75 13		 jne	 SHORT $LN253@inflateBac@3
  00412	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00419	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00420	e9 32 0f 00 00	 jmp	 $inf_leave$77704
$LN253@inflateBac@3:
  00425	33 c0		 xor	 eax, eax
  00427	75 cc		 jne	 SHORT $LN254@inflateBac@3
  00429	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0042c	83 e9 01	 sub	 ecx, 1
  0042f	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00432	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00435	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00438	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0043b	d3 e0		 shl	 eax, cl
  0043d	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00440	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00443	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00446	83 c1 01	 add	 ecx, 1
  00449	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  0044c	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0044f	83 c2 08	 add	 edx, 8
  00452	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00455	33 c0		 xor	 eax, eax
  00457	75 9c		 jne	 SHORT $LN254@inflateBac@3
  00459	eb 94		 jmp	 SHORT $LN259@inflateBac@3
$LN261@inflateBac@3:
  0045b	33 c9		 xor	 ecx, ecx
  0045d	75 90		 jne	 SHORT $LN259@inflateBac@3

; 361  :             state->nlen = BITS(5) + 257;

  0045f	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00462	83 e2 1f	 and	 edx, 31			; 0000001fH
  00465	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  0046b	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0046e	89 50 64	 mov	 DWORD PTR [eax+100], edx
$LN249@inflateBac@3:

; 362  :             DROPBITS(5);

  00471	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00474	c1 e9 05	 shr	 ecx, 5
  00477	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  0047a	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0047d	83 ea 05	 sub	 edx, 5
  00480	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00483	33 c0		 xor	 eax, eax
  00485	75 ea		 jne	 SHORT $LN249@inflateBac@3

; 363  :             state->ndist = BITS(5) + 1;

  00487	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0048a	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0048d	83 c1 01	 add	 ecx, 1
  00490	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00493	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
$LN246@inflateBac@3:

; 364  :             DROPBITS(5);

  00496	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00499	c1 e8 05	 shr	 eax, 5
  0049c	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0049f	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  004a2	83 e9 05	 sub	 ecx, 5
  004a5	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  004a8	33 d2		 xor	 edx, edx
  004aa	75 ea		 jne	 SHORT $LN246@inflateBac@3

; 365  :             state->ncode = BITS(4) + 4;

  004ac	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  004af	83 e0 0f	 and	 eax, 15			; 0000000fH
  004b2	83 c0 04	 add	 eax, 4
  004b5	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  004b8	89 41 60	 mov	 DWORD PTR [ecx+96], eax
$LN243@inflateBac@3:

; 366  :             DROPBITS(4);

  004bb	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  004be	c1 ea 04	 shr	 edx, 4
  004c1	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  004c4	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  004c7	83 e8 04	 sub	 eax, 4
  004ca	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  004cd	33 c9		 xor	 ecx, ecx
  004cf	75 ea		 jne	 SHORT $LN243@inflateBac@3

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  004d1	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  004d4	81 7a 64 1e 01
	00 00		 cmp	 DWORD PTR [edx+100], 286 ; 0000011eH
  004db	77 09		 ja	 SHORT $LN239@inflateBac@3
  004dd	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  004e0	83 78 68 1e	 cmp	 DWORD PTR [eax+104], 30	; 0000001eH
  004e4	76 19		 jbe	 SHORT $LN240@inflateBac@3
$LN239@inflateBac@3:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  004e6	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  004e9	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 370  :                 state->mode = BAD;

  004f0	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  004f3	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 371  :                 break;

  004fa	e9 53 0e 00 00	 jmp	 $LN329@inflateBac@3
$LN240@inflateBac@3:

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  004ff	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00502	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0
$LN238@inflateBac@3:

; 378  :             while (state->have < state->ncode) {

  00509	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0050c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0050f	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00512	3b 42 60	 cmp	 eax, DWORD PTR [edx+96]
  00515	0f 83 b6 00 00
	00		 jae	 $LN220@inflateBac@3
$LN233@inflateBac@3:

; 379  :                 NEEDBITS(3);

  0051b	83 7d e8 03	 cmp	 DWORD PTR _bits$[ebp], 3
  0051f	73 66		 jae	 SHORT $LN235@inflateBac@3
$LN228@inflateBac@3:
  00521	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00525	75 2a		 jne	 SHORT $LN227@inflateBac@3
  00527	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  0052a	51		 push	 ecx
  0052b	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  0052e	52		 push	 edx
  0052f	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00532	83 c4 08	 add	 esp, 8
  00535	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00538	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0053c	75 13		 jne	 SHORT $LN227@inflateBac@3
  0053e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00545	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0054c	e9 06 0e 00 00	 jmp	 $inf_leave$77704
$LN227@inflateBac@3:
  00551	33 c0		 xor	 eax, eax
  00553	75 cc		 jne	 SHORT $LN228@inflateBac@3
  00555	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00558	83 e9 01	 sub	 ecx, 1
  0055b	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  0055e	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00561	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00564	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00567	d3 e0		 shl	 eax, cl
  00569	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  0056c	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0056f	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00572	83 c1 01	 add	 ecx, 1
  00575	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00578	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0057b	83 c2 08	 add	 edx, 8
  0057e	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00581	33 c0		 xor	 eax, eax
  00583	75 9c		 jne	 SHORT $LN228@inflateBac@3
  00585	eb 94		 jmp	 SHORT $LN233@inflateBac@3
$LN235@inflateBac@3:
  00587	33 c9		 xor	 ecx, ecx
  00589	75 90		 jne	 SHORT $LN233@inflateBac@3

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  0058b	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  0058e	83 e2 07	 and	 edx, 7
  00591	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00594	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00597	0f b7 04 4d 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  0059f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005a2	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  005a7	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005aa	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  005ad	83 c0 01	 add	 eax, 1
  005b0	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005b3	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
$LN223@inflateBac@3:

; 381  :                 DROPBITS(3);

  005b6	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  005b9	c1 ea 03	 shr	 edx, 3
  005bc	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  005bf	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  005c2	83 e8 03	 sub	 eax, 3
  005c5	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  005c8	33 c9		 xor	 ecx, ecx
  005ca	75 ea		 jne	 SHORT $LN223@inflateBac@3

; 382  :             }

  005cc	e9 38 ff ff ff	 jmp	 $LN238@inflateBac@3
$LN220@inflateBac@3:

; 383  :             while (state->have < 19)

  005d1	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005d4	83 7a 6c 13	 cmp	 DWORD PTR [edx+108], 19	; 00000013H
  005d8	73 29		 jae	 SHORT $LN219@inflateBac@3

; 384  :                 state->lens[order[state->have++]] = 0;

  005da	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  005dd	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  005e0	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  005e8	33 c0		 xor	 eax, eax
  005ea	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005ed	66 89 44 51 74	 mov	 WORD PTR [ecx+edx*2+116], ax
  005f2	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005f5	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  005f8	83 c0 01	 add	 eax, 1
  005fb	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005fe	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00601	eb ce		 jmp	 SHORT $LN220@inflateBac@3
$LN219@inflateBac@3:

; 385  :             state->next = state->codes;

  00603	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00606	81 c2 34 05 00
	00		 add	 edx, 1332		; 00000534H
  0060c	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0060f	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 386  :             state->lencode = (code const FAR *)(state->next);

  00612	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00615	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00618	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0061b	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 387  :             state->lenbits = 7;

  0061e	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00621	c7 41 58 07 00
	00 00		 mov	 DWORD PTR [ecx+88], 7

; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 389  :                                 &(state->lenbits), state->work);

  00628	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0062b	81 c2 f4 02 00
	00		 add	 edx, 756		; 000002f4H
  00631	52		 push	 edx
  00632	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00635	83 c0 58	 add	 eax, 88			; 00000058H
  00638	50		 push	 eax
  00639	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0063c	83 c1 70	 add	 ecx, 112		; 00000070H
  0063f	51		 push	 ecx
  00640	6a 13		 push	 19			; 00000013H
  00642	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00645	83 c2 74	 add	 edx, 116		; 00000074H
  00648	52		 push	 edx
  00649	6a 00		 push	 0
  0064b	e8 00 00 00 00	 call	 _inflate_table
  00650	83 c4 18	 add	 esp, 24			; 00000018H
  00653	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 390  :             if (ret) {

  00656	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0065a	74 19		 je	 SHORT $LN218@inflateBac@3

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  0065c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0065f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 392  :                 state->mode = BAD;

  00666	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00669	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 393  :                 break;

  00670	e9 dd 0c 00 00	 jmp	 $LN329@inflateBac@3
$LN218@inflateBac@3:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;

  00675	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00678	c7 42 6c 00 00
	00 00		 mov	 DWORD PTR [edx+108], 0
$LN217@inflateBac@3:

; 399  :             while (state->have < state->nlen + state->ndist) {

  0067f	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00682	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00685	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00688	03 4a 68	 add	 ecx, DWORD PTR [edx+104]
  0068b	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0068e	39 48 6c	 cmp	 DWORD PTR [eax+108], ecx
  00691	0f 83 c6 03 00
	00		 jae	 $LN216@inflateBac@3
$LN215@inflateBac@3:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  00697	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0069a	ba 01 00 00 00	 mov	 edx, 1
  0069f	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  006a2	d3 e2		 shl	 edx, cl
  006a4	83 ea 01	 sub	 edx, 1
  006a7	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  006aa	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  006ad	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  006b0	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  006b3	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  006b6	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  006ba	3b 45 e8	 cmp	 eax, DWORD PTR _bits$[ebp]
  006bd	77 02		 ja	 SHORT $LN209@inflateBac@3
  006bf	eb 69		 jmp	 SHORT $LN214@inflateBac@3
$LN209@inflateBac@3:

; 403  :                     PULLBYTE();

  006c1	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  006c5	75 2a		 jne	 SHORT $LN208@inflateBac@3
  006c7	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  006ca	51		 push	 ecx
  006cb	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  006ce	52		 push	 edx
  006cf	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  006d2	83 c4 08	 add	 esp, 8
  006d5	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  006d8	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  006dc	75 13		 jne	 SHORT $LN208@inflateBac@3
  006de	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  006e5	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  006ec	e9 66 0c 00 00	 jmp	 $inf_leave$77704
$LN208@inflateBac@3:
  006f1	33 c0		 xor	 eax, eax
  006f3	75 cc		 jne	 SHORT $LN209@inflateBac@3
  006f5	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  006f8	83 e9 01	 sub	 ecx, 1
  006fb	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  006fe	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00701	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00704	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00707	d3 e0		 shl	 eax, cl
  00709	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  0070c	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0070f	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00712	83 c1 01	 add	 ecx, 1
  00715	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00718	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0071b	83 c2 08	 add	 edx, 8
  0071e	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00721	33 c0		 xor	 eax, eax
  00723	75 9c		 jne	 SHORT $LN209@inflateBac@3

; 404  :                 }

  00725	e9 6d ff ff ff	 jmp	 $LN215@inflateBac@3
$LN214@inflateBac@3:

; 405  :                 if (here.val < 16) {

  0072a	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  0072e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00731	7d 42		 jge	 SHORT $LN204@inflateBac@3
$LN203@inflateBac@3:

; 406  :                     DROPBITS(here.bits);

  00733	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00737	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  0073a	d3 ea		 shr	 edx, cl
  0073c	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0073f	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00743	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00746	2b c8		 sub	 ecx, eax
  00748	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0074b	33 d2		 xor	 edx, edx
  0074d	75 e4		 jne	 SHORT $LN203@inflateBac@3

; 407  :                     state->lens[state->have++] = here.val;

  0074f	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00752	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00755	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00758	66 8b 45 f6	 mov	 ax, WORD PTR _here$[ebp+2]
  0075c	66 89 44 4a 74	 mov	 WORD PTR [edx+ecx*2+116], ax
  00761	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00764	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00767	83 c2 01	 add	 edx, 1
  0076a	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0076d	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 408  :                 }
; 409  :                 else {

  00770	e9 e3 02 00 00	 jmp	 $LN200@inflateBac@3
$LN204@inflateBac@3:

; 410  :                     if (here.val == 16) {

  00775	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  00779	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0077c	0f 85 ec 00 00
	00		 jne	 $LN199@inflateBac@3
$LN195@inflateBac@3:

; 411  :                         NEEDBITS(here.bits + 2);

  00782	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  00786	83 c2 02	 add	 edx, 2
  00789	39 55 e8	 cmp	 DWORD PTR _bits$[ebp], edx
  0078c	73 66		 jae	 SHORT $LN197@inflateBac@3
$LN190@inflateBac@3:
  0078e	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00792	75 2a		 jne	 SHORT $LN189@inflateBac@3
  00794	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  00797	50		 push	 eax
  00798	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0079b	51		 push	 ecx
  0079c	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0079f	83 c4 08	 add	 esp, 8
  007a2	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  007a5	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  007a9	75 13		 jne	 SHORT $LN189@inflateBac@3
  007ab	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  007b2	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  007b9	e9 99 0b 00 00	 jmp	 $inf_leave$77704
$LN189@inflateBac@3:
  007be	33 d2		 xor	 edx, edx
  007c0	75 cc		 jne	 SHORT $LN190@inflateBac@3
  007c2	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  007c5	83 e8 01	 sub	 eax, 1
  007c8	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  007cb	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  007ce	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  007d1	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  007d4	d3 e2		 shl	 edx, cl
  007d6	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  007d9	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  007dc	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  007df	83 c0 01	 add	 eax, 1
  007e2	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  007e5	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  007e8	83 c1 08	 add	 ecx, 8
  007eb	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  007ee	33 d2		 xor	 edx, edx
  007f0	75 9c		 jne	 SHORT $LN190@inflateBac@3
  007f2	eb 8e		 jmp	 SHORT $LN195@inflateBac@3
$LN197@inflateBac@3:
  007f4	33 c0		 xor	 eax, eax
  007f6	75 8a		 jne	 SHORT $LN195@inflateBac@3
$LN185@inflateBac@3:

; 412  :                         DROPBITS(here.bits);

  007f8	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  007fc	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  007ff	d3 ea		 shr	 edx, cl
  00801	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00804	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00808	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0080b	2b c8		 sub	 ecx, eax
  0080d	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00810	33 d2		 xor	 edx, edx
  00812	75 e4		 jne	 SHORT $LN185@inflateBac@3

; 413  :                         if (state->have == 0) {

  00814	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00817	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  0081b	75 19		 jne	 SHORT $LN182@inflateBac@3

; 414  :                             strm->msg = (char *)"invalid bit length repeat";

  0081d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00820	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 415  :                             state->mode = BAD;

  00827	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0082a	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 416  :                             break;

  00831	e9 27 02 00 00	 jmp	 $LN216@inflateBac@3
$LN182@inflateBac@3:

; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);

  00836	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00839	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0083c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0083f	0f b7 44 4a 72	 movzx	 eax, WORD PTR [edx+ecx*2+114]
  00844	89 45 ec	 mov	 DWORD PTR _len$[ebp], eax

; 419  :                         copy = 3 + BITS(2);

  00847	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0084a	83 e1 03	 and	 ecx, 3
  0084d	83 c1 03	 add	 ecx, 3
  00850	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN181@inflateBac@3:

; 420  :                         DROPBITS(2);

  00853	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00856	c1 ea 02	 shr	 edx, 2
  00859	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0085c	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  0085f	83 e8 02	 sub	 eax, 2
  00862	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  00865	33 c9		 xor	 ecx, ecx
  00867	75 ea		 jne	 SHORT $LN181@inflateBac@3

; 421  :                     }
; 422  :                     else if (here.val == 17) {

  00869	e9 88 01 00 00	 jmp	 $LN178@inflateBac@3
$LN199@inflateBac@3:
  0086e	0f b7 55 f6	 movzx	 edx, WORD PTR _here$[ebp+2]
  00872	83 fa 11	 cmp	 edx, 17			; 00000011H
  00875	0f 85 c0 00 00
	00		 jne	 $LN153@inflateBac@3
$LN173@inflateBac@3:

; 423  :                         NEEDBITS(here.bits + 3);

  0087b	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0087f	83 c0 03	 add	 eax, 3
  00882	39 45 e8	 cmp	 DWORD PTR _bits$[ebp], eax
  00885	73 66		 jae	 SHORT $LN175@inflateBac@3
$LN168@inflateBac@3:
  00887	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0088b	75 2a		 jne	 SHORT $LN167@inflateBac@3
  0088d	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00890	51		 push	 ecx
  00891	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00894	52		 push	 edx
  00895	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00898	83 c4 08	 add	 esp, 8
  0089b	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0089e	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  008a2	75 13		 jne	 SHORT $LN167@inflateBac@3
  008a4	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  008ab	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  008b2	e9 a0 0a 00 00	 jmp	 $inf_leave$77704
$LN167@inflateBac@3:
  008b7	33 c0		 xor	 eax, eax
  008b9	75 cc		 jne	 SHORT $LN168@inflateBac@3
  008bb	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  008be	83 e9 01	 sub	 ecx, 1
  008c1	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  008c4	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  008c7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  008ca	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  008cd	d3 e0		 shl	 eax, cl
  008cf	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  008d2	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  008d5	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  008d8	83 c1 01	 add	 ecx, 1
  008db	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  008de	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  008e1	83 c2 08	 add	 edx, 8
  008e4	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  008e7	33 c0		 xor	 eax, eax
  008e9	75 9c		 jne	 SHORT $LN168@inflateBac@3
  008eb	eb 8e		 jmp	 SHORT $LN173@inflateBac@3
$LN175@inflateBac@3:
  008ed	33 c9		 xor	 ecx, ecx
  008ef	75 8a		 jne	 SHORT $LN173@inflateBac@3
$LN163@inflateBac@3:

; 424  :                         DROPBITS(here.bits);

  008f1	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  008f5	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  008f8	d3 ea		 shr	 edx, cl
  008fa	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  008fd	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00901	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00904	2b c8		 sub	 ecx, eax
  00906	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00909	33 d2		 xor	 edx, edx
  0090b	75 e4		 jne	 SHORT $LN163@inflateBac@3

; 425  :                         len = 0;

  0090d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 426  :                         copy = 3 + BITS(3);

  00914	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00917	83 e0 07	 and	 eax, 7
  0091a	83 c0 03	 add	 eax, 3
  0091d	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN160@inflateBac@3:

; 427  :                         DROPBITS(3);

  00920	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00923	c1 e9 03	 shr	 ecx, 3
  00926	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  00929	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0092c	83 ea 03	 sub	 edx, 3
  0092f	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00932	33 c0		 xor	 eax, eax
  00934	75 ea		 jne	 SHORT $LN160@inflateBac@3

; 428  :                     }
; 429  :                     else {

  00936	e9 bb 00 00 00	 jmp	 $LN178@inflateBac@3
$LN153@inflateBac@3:

; 430  :                         NEEDBITS(here.bits + 7);

  0093b	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  0093f	83 c1 07	 add	 ecx, 7
  00942	39 4d e8	 cmp	 DWORD PTR _bits$[ebp], ecx
  00945	73 66		 jae	 SHORT $LN155@inflateBac@3
$LN148@inflateBac@3:
  00947	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0094b	75 2a		 jne	 SHORT $LN147@inflateBac@3
  0094d	8d 55 e0	 lea	 edx, DWORD PTR _next$[ebp]
  00950	52		 push	 edx
  00951	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00954	50		 push	 eax
  00955	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00958	83 c4 08	 add	 esp, 8
  0095b	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0095e	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00962	75 13		 jne	 SHORT $LN147@inflateBac@3
  00964	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0096b	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00972	e9 e0 09 00 00	 jmp	 $inf_leave$77704
$LN147@inflateBac@3:
  00977	33 c9		 xor	 ecx, ecx
  00979	75 cc		 jne	 SHORT $LN148@inflateBac@3
  0097b	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  0097e	83 ea 01	 sub	 edx, 1
  00981	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00984	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00987	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0098a	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0098d	d3 e2		 shl	 edx, cl
  0098f	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  00992	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00995	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00998	83 c0 01	 add	 eax, 1
  0099b	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  0099e	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  009a1	83 c1 08	 add	 ecx, 8
  009a4	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  009a7	33 d2		 xor	 edx, edx
  009a9	75 9c		 jne	 SHORT $LN148@inflateBac@3
  009ab	eb 8e		 jmp	 SHORT $LN153@inflateBac@3
$LN155@inflateBac@3:
  009ad	33 c0		 xor	 eax, eax
  009af	75 8a		 jne	 SHORT $LN153@inflateBac@3
$LN143@inflateBac@3:

; 431  :                         DROPBITS(here.bits);

  009b1	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  009b5	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  009b8	d3 ea		 shr	 edx, cl
  009ba	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  009bd	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  009c1	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  009c4	2b c8		 sub	 ecx, eax
  009c6	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  009c9	33 d2		 xor	 edx, edx
  009cb	75 e4		 jne	 SHORT $LN143@inflateBac@3

; 432  :                         len = 0;

  009cd	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 433  :                         copy = 11 + BITS(7);

  009d4	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  009d7	83 e0 7f	 and	 eax, 127		; 0000007fH
  009da	83 c0 0b	 add	 eax, 11			; 0000000bH
  009dd	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN140@inflateBac@3:

; 434  :                         DROPBITS(7);

  009e0	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  009e3	c1 e9 07	 shr	 ecx, 7
  009e6	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  009e9	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  009ec	83 ea 07	 sub	 edx, 7
  009ef	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  009f2	33 c0		 xor	 eax, eax
  009f4	75 ea		 jne	 SHORT $LN140@inflateBac@3
$LN178@inflateBac@3:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  009f6	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  009f9	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  009fc	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  009ff	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a02	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00a05	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a08	03 48 68	 add	 ecx, DWORD PTR [eax+104]
  00a0b	3b d1		 cmp	 edx, ecx
  00a0d	76 16		 jbe	 SHORT $LN136@inflateBac@3

; 437  :                         strm->msg = (char *)"invalid bit length repeat";

  00a0f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00a12	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 438  :                         state->mode = BAD;

  00a19	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a1c	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 439  :                         break;

  00a23	eb 38		 jmp	 SHORT $LN216@inflateBac@3
$LN136@inflateBac@3:

; 440  :                     }
; 441  :                     while (copy--)

  00a25	8b 45 d4	 mov	 eax, DWORD PTR _copy$[ebp]
  00a28	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00a2b	83 e9 01	 sub	 ecx, 1
  00a2e	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
  00a31	85 c0		 test	 eax, eax
  00a33	74 23		 je	 SHORT $LN200@inflateBac@3

; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00a35	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a38	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00a3b	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a3e	66 8b 55 ec	 mov	 dx, WORD PTR _len$[ebp]
  00a42	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00a47	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a4a	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00a4d	83 c1 01	 add	 ecx, 1
  00a50	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a53	89 4a 6c	 mov	 DWORD PTR [edx+108], ecx
  00a56	eb cd		 jmp	 SHORT $LN136@inflateBac@3
$LN200@inflateBac@3:

; 443  :                 }
; 444  :             }

  00a58	e9 22 fc ff ff	 jmp	 $LN217@inflateBac@3
$LN216@inflateBac@3:

; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  00a5d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a60	81 78 04 51 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16209 ; 00003f51H
  00a67	75 05		 jne	 SHORT $LN134@inflateBac@3
  00a69	e9 e4 08 00 00	 jmp	 $LN329@inflateBac@3
$LN134@inflateBac@3:

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  00a6e	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a71	0f b7 91 74 02
	00 00		 movzx	 edx, WORD PTR [ecx+628]
  00a78	85 d2		 test	 edx, edx
  00a7a	75 19		 jne	 SHORT $LN133@inflateBac@3

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00a7c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00a7f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 452  :                 state->mode = BAD;

  00a86	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a89	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 453  :                 break;

  00a90	e9 bd 08 00 00	 jmp	 $LN329@inflateBac@3
$LN133@inflateBac@3:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  00a95	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a98	81 c2 34 05 00
	00		 add	 edx, 1332		; 00000534H
  00a9e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00aa1	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 460  :             state->lencode = (code const FAR *)(state->next);

  00aa4	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00aa7	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00aaa	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00aad	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 461  :             state->lenbits = 9;

  00ab0	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ab3	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 463  :                                 &(state->lenbits), state->work);

  00aba	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00abd	81 c2 f4 02 00
	00		 add	 edx, 756		; 000002f4H
  00ac3	52		 push	 edx
  00ac4	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ac7	83 c0 58	 add	 eax, 88			; 00000058H
  00aca	50		 push	 eax
  00acb	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ace	83 c1 70	 add	 ecx, 112		; 00000070H
  00ad1	51		 push	 ecx
  00ad2	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00ad5	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00ad8	50		 push	 eax
  00ad9	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00adc	83 c1 74	 add	 ecx, 116		; 00000074H
  00adf	51		 push	 ecx
  00ae0	6a 01		 push	 1
  00ae2	e8 00 00 00 00	 call	 _inflate_table
  00ae7	83 c4 18	 add	 esp, 24			; 00000018H
  00aea	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 464  :             if (ret) {

  00aed	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00af1	74 19		 je	 SHORT $LN132@inflateBac@3

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  00af3	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00af6	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 466  :                 state->mode = BAD;

  00afd	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b00	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 467  :                 break;

  00b07	e9 46 08 00 00	 jmp	 $LN329@inflateBac@3
$LN132@inflateBac@3:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);

  00b0c	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b0f	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b12	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00b15	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 470  :             state->distbits = 6;

  00b18	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b1b	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6

; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 472  :                             &(state->next), &(state->distbits), state->work);

  00b22	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b25	81 c2 f4 02 00
	00		 add	 edx, 756		; 000002f4H
  00b2b	52		 push	 edx
  00b2c	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b2f	83 c0 5c	 add	 eax, 92			; 0000005cH
  00b32	50		 push	 eax
  00b33	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b36	83 c1 70	 add	 ecx, 112		; 00000070H
  00b39	51		 push	 ecx
  00b3a	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b3d	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00b40	50		 push	 eax
  00b41	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b44	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00b47	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b4a	8d 4c 50 74	 lea	 ecx, DWORD PTR [eax+edx*2+116]
  00b4e	51		 push	 ecx
  00b4f	6a 02		 push	 2
  00b51	e8 00 00 00 00	 call	 _inflate_table
  00b56	83 c4 18	 add	 esp, 24			; 00000018H
  00b59	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 473  :             if (ret) {

  00b5c	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00b60	74 19		 je	 SHORT $LN131@inflateBac@3

; 474  :                 strm->msg = (char *)"invalid distances set";

  00b62	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00b65	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 475  :                 state->mode = BAD;

  00b6c	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b6f	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 476  :                 break;

  00b76	e9 d7 07 00 00	 jmp	 $LN329@inflateBac@3
$LN131@inflateBac@3:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  00b7b	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b7e	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
$LN130@inflateBac@3:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  00b85	83 7d f0 06	 cmp	 DWORD PTR _have$[ebp], 6
  00b89	0f 82 b4 00 00
	00		 jb	 $LN121@inflateBac@3
  00b8f	81 7d e4 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  00b96	0f 82 a7 00 00
	00		 jb	 $LN121@inflateBac@3
$LN128@inflateBac@3:

; 484  :                 RESTORE();

  00b9c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00b9f	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  00ba2	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00ba5	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00ba8	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  00bab	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00bae	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00bb1	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00bb4	89 08		 mov	 DWORD PTR [eax], ecx
  00bb6	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00bb9	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00bbc	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00bbf	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00bc2	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00bc5	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  00bc8	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bcb	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00bce	89 48 40	 mov	 DWORD PTR [eax+64], ecx
  00bd1	33 d2		 xor	 edx, edx
  00bd3	75 c7		 jne	 SHORT $LN128@inflateBac@3

; 485  :                 if (state->whave < state->wsize)

  00bd5	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bd8	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00bdb	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00bde	3b 51 2c	 cmp	 edx, DWORD PTR [ecx+44]
  00be1	73 0f		 jae	 SHORT $LN125@inflateBac@3

; 486  :                     state->whave = state->wsize - left;

  00be3	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00be6	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00be9	2b 4d e4	 sub	 ecx, DWORD PTR _left$[ebp]
  00bec	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00bef	89 4a 30	 mov	 DWORD PTR [edx+48], ecx
$LN125@inflateBac@3:

; 487  :                 inflate_fast(strm, state->wsize);

  00bf2	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bf5	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00bf8	51		 push	 ecx
  00bf9	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00bfc	52		 push	 edx
  00bfd	e8 00 00 00 00	 call	 _inflate_fast
  00c02	83 c4 08	 add	 esp, 8
$LN124@inflateBac@3:

; 488  :                 LOAD();

  00c05	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c08	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00c0b	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  00c0e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00c11	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00c14	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  00c17	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c1a	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c1c	89 55 e0	 mov	 DWORD PTR _next$[ebp], edx
  00c1f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c22	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c25	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00c28	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00c2b	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00c2e	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00c31	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c34	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00c37	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00c3a	33 c0		 xor	 eax, eax
  00c3c	75 c7		 jne	 SHORT $LN124@inflateBac@3

; 489  :                 break;

  00c3e	e9 0f 07 00 00	 jmp	 $LN329@inflateBac@3
$LN121@inflateBac@3:

; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  00c43	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c46	ba 01 00 00 00	 mov	 edx, 1
  00c4b	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00c4e	d3 e2		 shl	 edx, cl
  00c50	83 ea 01	 sub	 edx, 1
  00c53	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  00c56	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00c59	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00c5c	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00c5f	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  00c62	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00c66	3b 45 e8	 cmp	 eax, DWORD PTR _bits$[ebp]
  00c69	77 02		 ja	 SHORT $LN115@inflateBac@3
  00c6b	eb 69		 jmp	 SHORT $LN120@inflateBac@3
$LN115@inflateBac@3:

; 496  :                 PULLBYTE();

  00c6d	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00c71	75 2a		 jne	 SHORT $LN114@inflateBac@3
  00c73	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00c76	51		 push	 ecx
  00c77	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00c7a	52		 push	 edx
  00c7b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00c7e	83 c4 08	 add	 esp, 8
  00c81	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00c84	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00c88	75 13		 jne	 SHORT $LN114@inflateBac@3
  00c8a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00c91	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00c98	e9 ba 06 00 00	 jmp	 $inf_leave$77704
$LN114@inflateBac@3:
  00c9d	33 c0		 xor	 eax, eax
  00c9f	75 cc		 jne	 SHORT $LN115@inflateBac@3
  00ca1	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00ca4	83 e9 01	 sub	 ecx, 1
  00ca7	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00caa	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00cad	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00cb0	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00cb3	d3 e0		 shl	 eax, cl
  00cb5	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00cb8	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00cbb	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00cbe	83 c1 01	 add	 ecx, 1
  00cc1	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00cc4	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00cc7	83 c2 08	 add	 edx, 8
  00cca	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00ccd	33 c0		 xor	 eax, eax
  00ccf	75 9c		 jne	 SHORT $LN115@inflateBac@3

; 497  :             }

  00cd1	e9 6d ff ff ff	 jmp	 $LN121@inflateBac@3
$LN120@inflateBac@3:

; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  00cd6	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00cda	85 c9		 test	 ecx, ecx
  00cdc	0f 84 db 00 00
	00		 je	 $LN95@inflateBac@3
  00ce2	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  00ce6	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  00cec	0f 85 cb 00 00
	00		 jne	 $LN95@inflateBac@3

; 499  :                 last = here;

  00cf2	8b 45 f4	 mov	 eax, DWORD PTR _here$[ebp]
  00cf5	89 45 f8	 mov	 DWORD PTR _last$[ebp], eax
$LN109@inflateBac@3:

; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +
; 502  :                             (BITS(last.bits + last.op) >> last.bits)];

  00cf8	0f b7 55 fa	 movzx	 edx, WORD PTR _last$[ebp+2]
  00cfc	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00d00	0f b6 45 f8	 movzx	 eax, BYTE PTR _last$[ebp]
  00d04	03 c8		 add	 ecx, eax
  00d06	b8 01 00 00 00	 mov	 eax, 1
  00d0b	d3 e0		 shl	 eax, cl
  00d0d	83 e8 01	 sub	 eax, 1
  00d10	23 45 d8	 and	 eax, DWORD PTR _hold$[ebp]
  00d13	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00d17	d3 e8		 shr	 eax, cl
  00d19	03 d0		 add	 edx, eax
  00d1b	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00d1e	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00d21	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00d24	89 4d f4	 mov	 DWORD PTR _here$[ebp], ecx

; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00d27	0f b6 55 f9	 movzx	 edx, BYTE PTR _last$[ebp+1]
  00d2b	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00d2f	03 d0		 add	 edx, eax
  00d31	3b 55 e8	 cmp	 edx, DWORD PTR _bits$[ebp]
  00d34	77 02		 ja	 SHORT $LN103@inflateBac@3
  00d36	eb 69		 jmp	 SHORT $LN98@inflateBac@3
$LN103@inflateBac@3:

; 504  :                     PULLBYTE();

  00d38	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d3c	75 2a		 jne	 SHORT $LN102@inflateBac@3
  00d3e	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00d41	51		 push	 ecx
  00d42	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00d45	52		 push	 edx
  00d46	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00d49	83 c4 08	 add	 esp, 8
  00d4c	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00d4f	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d53	75 13		 jne	 SHORT $LN102@inflateBac@3
  00d55	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00d5c	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00d63	e9 ef 05 00 00	 jmp	 $inf_leave$77704
$LN102@inflateBac@3:
  00d68	33 c0		 xor	 eax, eax
  00d6a	75 cc		 jne	 SHORT $LN103@inflateBac@3
  00d6c	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00d6f	83 e9 01	 sub	 ecx, 1
  00d72	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00d75	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00d78	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00d7b	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d7e	d3 e0		 shl	 eax, cl
  00d80	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00d83	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00d86	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00d89	83 c1 01	 add	 ecx, 1
  00d8c	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00d8f	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00d92	83 c2 08	 add	 edx, 8
  00d95	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00d98	33 c0		 xor	 eax, eax
  00d9a	75 9c		 jne	 SHORT $LN103@inflateBac@3

; 505  :                 }

  00d9c	e9 57 ff ff ff	 jmp	 $LN109@inflateBac@3
$LN98@inflateBac@3:

; 506  :                 DROPBITS(last.bits);

  00da1	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00da5	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00da8	d3 ea		 shr	 edx, cl
  00daa	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00dad	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  00db1	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00db4	2b c8		 sub	 ecx, eax
  00db6	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00db9	33 d2		 xor	 edx, edx
  00dbb	75 e4		 jne	 SHORT $LN98@inflateBac@3
$LN95@inflateBac@3:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  00dbd	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00dc1	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00dc4	d3 e8		 shr	 eax, cl
  00dc6	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00dc9	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00dcd	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00dd0	2b d1		 sub	 edx, ecx
  00dd2	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00dd5	33 c0		 xor	 eax, eax
  00dd7	75 e4		 jne	 SHORT $LN95@inflateBac@3

; 509  :             state->length = (unsigned)here.val;

  00dd9	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  00ddd	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00de0	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  00de3	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  00de7	85 c0		 test	 eax, eax
  00de9	75 73		 jne	 SHORT $LN92@inflateBac@3
$LN91@inflateBac@3:

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00deb	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  00def	75 3d		 jne	 SHORT $LN90@inflateBac@3
  00df1	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00df4	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00df7	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx
  00dfa	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00dfd	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00e00	89 4d e4	 mov	 DWORD PTR _left$[ebp], ecx
  00e03	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00e06	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00e09	89 42 30	 mov	 DWORD PTR [edx+48], eax
  00e0c	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  00e0f	51		 push	 ecx
  00e10	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e13	52		 push	 edx
  00e14	8b 45 18	 mov	 eax, DWORD PTR _out_desc$[ebp]
  00e17	50		 push	 eax
  00e18	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00e1b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e1e	85 c0		 test	 eax, eax
  00e20	74 0c		 je	 SHORT $LN90@inflateBac@3
  00e22	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00e29	e9 29 05 00 00	 jmp	 $inf_leave$77704
$LN90@inflateBac@3:
  00e2e	33 c9		 xor	 ecx, ecx
  00e30	75 b9		 jne	 SHORT $LN91@inflateBac@3

; 517  :                 *put++ = (unsigned char)(state->length);

  00e32	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e35	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e38	8a 48 44	 mov	 cl, BYTE PTR [eax+68]
  00e3b	88 0a		 mov	 BYTE PTR [edx], cl
  00e3d	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e40	83 c2 01	 add	 edx, 1
  00e43	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 518  :                 left--;

  00e46	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00e49	83 e8 01	 sub	 eax, 1
  00e4c	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax

; 519  :                 state->mode = LEN;

  00e4f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00e52	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 520  :                 break;

  00e59	e9 f4 04 00 00	 jmp	 $LN329@inflateBac@3
$LN92@inflateBac@3:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  00e5e	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  00e62	83 e2 20	 and	 edx, 32			; 00000020H
  00e65	74 0f		 je	 SHORT $LN86@inflateBac@3

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;

  00e67	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e6a	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 527  :                 break;

  00e71	e9 dc 04 00 00	 jmp	 $LN329@inflateBac@3
$LN86@inflateBac@3:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00e76	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00e7a	83 e1 40	 and	 ecx, 64			; 00000040H
  00e7d	74 19		 je	 SHORT $LN85@inflateBac@3

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  00e7f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00e82	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 533  :                 state->mode = BAD;

  00e89	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e8c	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 534  :                 break;

  00e93	e9 ba 04 00 00	 jmp	 $LN329@inflateBac@3
$LN85@inflateBac@3:

; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  00e98	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00e9c	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00e9f	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00ea2	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 539  :             if (state->extra != 0) {

  00ea5	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ea8	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00eac	0f 84 b2 00 00
	00		 je	 $LN67@inflateBac@3
$LN80@inflateBac@3:

; 540  :                 NEEDBITS(state->extra);

  00eb2	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00eb5	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00eb8	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  00ebb	73 66		 jae	 SHORT $LN82@inflateBac@3
$LN75@inflateBac@3:
  00ebd	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ec1	75 2a		 jne	 SHORT $LN74@inflateBac@3
  00ec3	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  00ec6	50		 push	 eax
  00ec7	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00eca	51		 push	 ecx
  00ecb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00ece	83 c4 08	 add	 esp, 8
  00ed1	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00ed4	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ed8	75 13		 jne	 SHORT $LN74@inflateBac@3
  00eda	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00ee1	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00ee8	e9 6a 04 00 00	 jmp	 $inf_leave$77704
$LN74@inflateBac@3:
  00eed	33 d2		 xor	 edx, edx
  00eef	75 cc		 jne	 SHORT $LN75@inflateBac@3
  00ef1	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00ef4	83 e8 01	 sub	 eax, 1
  00ef7	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00efa	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00efd	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00f00	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f03	d3 e2		 shl	 edx, cl
  00f05	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  00f08	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00f0b	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00f0e	83 c0 01	 add	 eax, 1
  00f11	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  00f14	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f17	83 c1 08	 add	 ecx, 8
  00f1a	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00f1d	33 d2		 xor	 edx, edx
  00f1f	75 9c		 jne	 SHORT $LN75@inflateBac@3
  00f21	eb 8f		 jmp	 SHORT $LN80@inflateBac@3
$LN82@inflateBac@3:
  00f23	33 c0		 xor	 eax, eax
  00f25	75 8b		 jne	 SHORT $LN80@inflateBac@3

; 541  :                 state->length += BITS(state->extra);

  00f27	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f2a	ba 01 00 00 00	 mov	 edx, 1
  00f2f	8b 49 4c	 mov	 ecx, DWORD PTR [ecx+76]
  00f32	d3 e2		 shl	 edx, cl
  00f34	83 ea 01	 sub	 edx, 1
  00f37	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  00f3a	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00f3d	03 50 44	 add	 edx, DWORD PTR [eax+68]
  00f40	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f43	89 51 44	 mov	 DWORD PTR [ecx+68], edx
$LN70@inflateBac@3:

; 542  :                 DROPBITS(state->extra);

  00f46	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00f49	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00f4c	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  00f4f	d3 e8		 shr	 eax, cl
  00f51	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00f54	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f57	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00f5a	2b 51 4c	 sub	 edx, DWORD PTR [ecx+76]
  00f5d	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00f60	33 c0		 xor	 eax, eax
  00f62	75 e2		 jne	 SHORT $LN70@inflateBac@3
$LN67@inflateBac@3:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  00f64	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f67	ba 01 00 00 00	 mov	 edx, 1
  00f6c	8b 49 5c	 mov	 ecx, DWORD PTR [ecx+92]
  00f6f	d3 e2		 shl	 edx, cl
  00f71	83 ea 01	 sub	 edx, 1
  00f74	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  00f77	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00f7a	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00f7d	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00f80	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  00f83	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00f87	3b 45 e8	 cmp	 eax, DWORD PTR _bits$[ebp]
  00f8a	77 02		 ja	 SHORT $LN61@inflateBac@3
  00f8c	eb 69		 jmp	 SHORT $LN66@inflateBac@3
$LN61@inflateBac@3:

; 550  :                 PULLBYTE();

  00f8e	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f92	75 2a		 jne	 SHORT $LN60@inflateBac@3
  00f94	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00f97	51		 push	 ecx
  00f98	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00f9b	52		 push	 edx
  00f9c	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00f9f	83 c4 08	 add	 esp, 8
  00fa2	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00fa5	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00fa9	75 13		 jne	 SHORT $LN60@inflateBac@3
  00fab	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00fb2	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00fb9	e9 99 03 00 00	 jmp	 $inf_leave$77704
$LN60@inflateBac@3:
  00fbe	33 c0		 xor	 eax, eax
  00fc0	75 cc		 jne	 SHORT $LN61@inflateBac@3
  00fc2	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00fc5	83 e9 01	 sub	 ecx, 1
  00fc8	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00fcb	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00fce	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00fd1	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00fd4	d3 e0		 shl	 eax, cl
  00fd6	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00fd9	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00fdc	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00fdf	83 c1 01	 add	 ecx, 1
  00fe2	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00fe5	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00fe8	83 c2 08	 add	 edx, 8
  00feb	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00fee	33 c0		 xor	 eax, eax
  00ff0	75 9c		 jne	 SHORT $LN61@inflateBac@3

; 551  :             }

  00ff2	e9 6d ff ff ff	 jmp	 $LN67@inflateBac@3
$LN66@inflateBac@3:

; 552  :             if ((here.op & 0xf0) == 0) {

  00ff7	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00ffb	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  01001	0f 85 cb 00 00
	00		 jne	 $LN41@inflateBac@3

; 553  :                 last = here;

  01007	8b 55 f4	 mov	 edx, DWORD PTR _here$[ebp]
  0100a	89 55 f8	 mov	 DWORD PTR _last$[ebp], edx
$LN55@inflateBac@3:

; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +
; 556  :                             (BITS(last.bits + last.op) >> last.bits)];

  0100d	0f b7 45 fa	 movzx	 eax, WORD PTR _last$[ebp+2]
  01011	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01015	0f b6 55 f8	 movzx	 edx, BYTE PTR _last$[ebp]
  01019	03 ca		 add	 ecx, edx
  0101b	ba 01 00 00 00	 mov	 edx, 1
  01020	d3 e2		 shl	 edx, cl
  01022	83 ea 01	 sub	 edx, 1
  01025	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  01028	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0102c	d3 ea		 shr	 edx, cl
  0102e	03 c2		 add	 eax, edx
  01030	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01033	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  01036	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  01039	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax

; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0103c	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01040	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  01044	03 ca		 add	 ecx, edx
  01046	3b 4d e8	 cmp	 ecx, DWORD PTR _bits$[ebp]
  01049	77 02		 ja	 SHORT $LN49@inflateBac@3
  0104b	eb 69		 jmp	 SHORT $LN44@inflateBac@3
$LN49@inflateBac@3:

; 558  :                     PULLBYTE();

  0104d	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01051	75 2a		 jne	 SHORT $LN48@inflateBac@3
  01053	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  01056	50		 push	 eax
  01057	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0105a	51		 push	 ecx
  0105b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0105e	83 c4 08	 add	 esp, 8
  01061	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01064	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01068	75 13		 jne	 SHORT $LN48@inflateBac@3
  0106a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  01071	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  01078	e9 da 02 00 00	 jmp	 $inf_leave$77704
$LN48@inflateBac@3:
  0107d	33 d2		 xor	 edx, edx
  0107f	75 cc		 jne	 SHORT $LN49@inflateBac@3
  01081	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  01084	83 e8 01	 sub	 eax, 1
  01087	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0108a	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0108d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  01090	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01093	d3 e2		 shl	 edx, cl
  01095	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  01098	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0109b	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0109e	83 c0 01	 add	 eax, 1
  010a1	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  010a4	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  010a7	83 c1 08	 add	 ecx, 8
  010aa	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  010ad	33 d2		 xor	 edx, edx
  010af	75 9c		 jne	 SHORT $LN49@inflateBac@3

; 559  :                 }

  010b1	e9 57 ff ff ff	 jmp	 $LN55@inflateBac@3
$LN44@inflateBac@3:

; 560  :                 DROPBITS(last.bits);

  010b6	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  010ba	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  010bd	d3 e8		 shr	 eax, cl
  010bf	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  010c2	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  010c6	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  010c9	2b d1		 sub	 edx, ecx
  010cb	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  010ce	33 c0		 xor	 eax, eax
  010d0	75 e4		 jne	 SHORT $LN44@inflateBac@3
$LN41@inflateBac@3:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  010d2	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  010d6	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  010d9	d3 ea		 shr	 edx, cl
  010db	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  010de	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  010e2	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  010e5	2b c8		 sub	 ecx, eax
  010e7	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  010ea	33 d2		 xor	 edx, edx
  010ec	75 e4		 jne	 SHORT $LN41@inflateBac@3

; 563  :             if (here.op & 64) {

  010ee	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  010f2	83 e0 40	 and	 eax, 64			; 00000040H
  010f5	74 19		 je	 SHORT $LN38@inflateBac@3

; 564  :                 strm->msg = (char *)"invalid distance code";

  010f7	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  010fa	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 565  :                 state->mode = BAD;

  01101	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01104	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 566  :                 break;

  0110b	e9 42 02 00 00	 jmp	 $LN329@inflateBac@3
$LN38@inflateBac@3:

; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  01110	0f b7 45 f6	 movzx	 eax, WORD PTR _here$[ebp+2]
  01114	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01117	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  0111a	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  0111e	83 e2 0f	 and	 edx, 15			; 0000000fH
  01121	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01124	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 572  :             if (state->extra != 0) {

  01127	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0112a	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  0112e	0f 84 b2 00 00
	00		 je	 $LN37@inflateBac@3
$LN33@inflateBac@3:

; 573  :                 NEEDBITS(state->extra);

  01134	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01137	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  0113a	3b 42 4c	 cmp	 eax, DWORD PTR [edx+76]
  0113d	73 66		 jae	 SHORT $LN35@inflateBac@3
$LN28@inflateBac@3:
  0113f	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01143	75 2a		 jne	 SHORT $LN27@inflateBac@3
  01145	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  01148	51		 push	 ecx
  01149	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  0114c	52		 push	 edx
  0114d	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  01150	83 c4 08	 add	 esp, 8
  01153	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01156	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0115a	75 13		 jne	 SHORT $LN27@inflateBac@3
  0115c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  01163	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0116a	e9 e8 01 00 00	 jmp	 $inf_leave$77704
$LN27@inflateBac@3:
  0116f	33 c0		 xor	 eax, eax
  01171	75 cc		 jne	 SHORT $LN28@inflateBac@3
  01173	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01176	83 e9 01	 sub	 ecx, 1
  01179	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  0117c	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  0117f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01182	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01185	d3 e0		 shl	 eax, cl
  01187	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  0118a	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0118d	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  01190	83 c1 01	 add	 ecx, 1
  01193	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  01196	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  01199	83 c2 08	 add	 edx, 8
  0119c	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0119f	33 c0		 xor	 eax, eax
  011a1	75 9c		 jne	 SHORT $LN28@inflateBac@3
  011a3	eb 8f		 jmp	 SHORT $LN33@inflateBac@3
$LN35@inflateBac@3:
  011a5	33 c9		 xor	 ecx, ecx
  011a7	75 8b		 jne	 SHORT $LN33@inflateBac@3

; 574  :                 state->offset += BITS(state->extra);

  011a9	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  011ac	b8 01 00 00 00	 mov	 eax, 1
  011b1	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  011b4	d3 e0		 shl	 eax, cl
  011b6	83 e8 01	 sub	 eax, 1
  011b9	23 45 d8	 and	 eax, DWORD PTR _hold$[ebp]
  011bc	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  011bf	03 41 48	 add	 eax, DWORD PTR [ecx+72]
  011c2	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  011c5	89 42 48	 mov	 DWORD PTR [edx+72], eax
$LN23@inflateBac@3:

; 575  :                 DROPBITS(state->extra);

  011c8	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  011cb	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  011ce	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  011d1	d3 ea		 shr	 edx, cl
  011d3	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  011d6	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  011d9	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  011dc	2b 48 4c	 sub	 ecx, DWORD PTR [eax+76]
  011df	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  011e2	33 d2		 xor	 edx, edx
  011e4	75 e2		 jne	 SHORT $LN23@inflateBac@3
$LN37@inflateBac@3:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 578  :                                                 left : 0)) {

  011e6	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  011e9	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  011ec	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  011ef	3b 51 2c	 cmp	 edx, DWORD PTR [ecx+44]
  011f2	1b c0		 sbb	 eax, eax
  011f4	23 45 e4	 and	 eax, DWORD PTR _left$[ebp]
  011f7	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  011fa	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  011fd	2b d0		 sub	 edx, eax
  011ff	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01202	39 50 48	 cmp	 DWORD PTR [eax+72], edx
  01205	76 19		 jbe	 SHORT $LN16@inflateBac@3

; 579  :                 strm->msg = (char *)"invalid distance too far back";

  01207	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0120a	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 580  :                 state->mode = BAD;

  01211	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01214	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 581  :                 break;

  0121b	e9 32 01 00 00	 jmp	 $LN329@inflateBac@3
$LN16@inflateBac@3:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  01220	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  01224	75 3d		 jne	 SHORT $LN15@inflateBac@3
  01226	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01229	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0122c	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  0122f	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01232	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01235	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  01238	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0123b	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  0123e	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  01241	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  01244	50		 push	 eax
  01245	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01248	51		 push	 ecx
  01249	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  0124c	52		 push	 edx
  0124d	ff 55 14	 call	 DWORD PTR _out$[ebp]
  01250	83 c4 0c	 add	 esp, 12			; 0000000cH
  01253	85 c0		 test	 eax, eax
  01255	74 0c		 je	 SHORT $LN15@inflateBac@3
  01257	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0125e	e9 f4 00 00 00	 jmp	 $inf_leave$77704
$LN15@inflateBac@3:
  01263	33 c0		 xor	 eax, eax
  01265	75 b9		 jne	 SHORT $LN16@inflateBac@3

; 588  :                 copy = state->wsize - state->offset;

  01267	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0126a	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0126d	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  01270	2b 42 48	 sub	 eax, DWORD PTR [edx+72]
  01273	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax

; 589  :                 if (copy < left) {

  01276	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  01279	3b 4d e4	 cmp	 ecx, DWORD PTR _left$[ebp]
  0127c	73 14		 jae	 SHORT $LN11@inflateBac@3

; 590  :                     from = put + copy;

  0127e	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01281	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  01284	89 55 d0	 mov	 DWORD PTR _from$[ebp], edx

; 591  :                     copy = left - copy;

  01287	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  0128a	2b 45 d4	 sub	 eax, DWORD PTR _copy$[ebp]
  0128d	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax

; 592  :                 }
; 593  :                 else {

  01290	eb 12		 jmp	 SHORT $LN10@inflateBac@3
$LN11@inflateBac@3:

; 594  :                     from = put - state->offset;

  01292	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01295	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01298	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  0129b	89 55 d0	 mov	 DWORD PTR _from$[ebp], edx

; 595  :                     copy = left;

  0129e	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  012a1	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN10@inflateBac@3:

; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  012a4	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  012a7	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  012aa	3b 51 44	 cmp	 edx, DWORD PTR [ecx+68]
  012ad	76 09		 jbe	 SHORT $LN9@inflateBac@3
  012af	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  012b2	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  012b5	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN9@inflateBac@3:

; 598  :                 state->length -= copy;

  012b8	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  012bb	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  012be	2b 45 d4	 sub	 eax, DWORD PTR _copy$[ebp]
  012c1	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  012c4	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 599  :                 left -= copy;

  012c7	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  012ca	2b 55 d4	 sub	 edx, DWORD PTR _copy$[ebp]
  012cd	89 55 e4	 mov	 DWORD PTR _left$[ebp], edx
$LN8@inflateBac@3:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  012d0	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  012d3	8b 4d d0	 mov	 ecx, DWORD PTR _from$[ebp]
  012d6	8a 11		 mov	 dl, BYTE PTR [ecx]
  012d8	88 10		 mov	 BYTE PTR [eax], dl
  012da	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  012dd	83 c0 01	 add	 eax, 1
  012e0	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax
  012e3	8b 4d d0	 mov	 ecx, DWORD PTR _from$[ebp]
  012e6	83 c1 01	 add	 ecx, 1
  012e9	89 4d d0	 mov	 DWORD PTR _from$[ebp], ecx

; 602  :                 } while (--copy);

  012ec	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  012ef	83 ea 01	 sub	 edx, 1
  012f2	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
  012f5	75 d9		 jne	 SHORT $LN8@inflateBac@3

; 603  :             } while (state->length != 0);

  012f7	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  012fa	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  012fe	0f 85 1c ff ff
	ff		 jne	 $LN16@inflateBac@3

; 604  :             break;

  01304	eb 4c		 jmp	 SHORT $LN329@inflateBac@3
$LN5@inflateBac@3:

; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;

  01306	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 609  :             if (left < state->wsize) {

  0130d	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01310	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  01313	3b 51 2c	 cmp	 edx, DWORD PTR [ecx+44]
  01316	73 26		 jae	 SHORT $LN4@inflateBac@3

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  01318	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0131b	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0131e	2b 4d e4	 sub	 ecx, DWORD PTR _left$[ebp]
  01321	51		 push	 ecx
  01322	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01325	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  01328	50		 push	 eax
  01329	8b 4d 18	 mov	 ecx, DWORD PTR _out_desc$[ebp]
  0132c	51		 push	 ecx
  0132d	ff 55 14	 call	 DWORD PTR _out$[ebp]
  01330	83 c4 0c	 add	 esp, 12			; 0000000cH
  01333	85 c0		 test	 eax, eax
  01335	74 07		 je	 SHORT $LN4@inflateBac@3

; 611  :                     ret = Z_BUF_ERROR;

  01337	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
$LN4@inflateBac@3:

; 612  :             }
; 613  :             goto inf_leave;

  0133e	eb 17		 jmp	 SHORT $inf_leave$77704
$LN2@inflateBac@3:

; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  01340	c7 45 dc fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH

; 617  :             goto inf_leave;

  01347	eb 0e		 jmp	 SHORT $inf_leave$77704
$LN1@inflateBac@3:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  01349	c7 45 dc fe ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  01350	eb 05		 jmp	 SHORT $inf_leave$77704
$LN329@inflateBac@3:

; 621  :             goto inf_leave;
; 622  :         }

  01352	e9 3f ed ff ff	 jmp	 $LN332@inflateBac@3
$inf_leave$77704:

; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  01357	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0135a	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0135d	89 02		 mov	 DWORD PTR [edx], eax

; 627  :     strm->avail_in = have;

  0135f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01362	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01365	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 628  :     return ret;

  01368	8b 45 dc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN335@inflateBac@3:

; 629  : }

  0136b	8b e5		 mov	 esp, ebp
  0136d	5d		 pop	 ebp
  0136e	c2 14 00	 ret	 20			; 00000014H
  01371	8d 49 00	 npad	 3
$LN340@inflateBac@3:
  01374	00 00 00 00	 DD	 $LN328@inflateBac@3
  01378	00 00 00 00	 DD	 $LN297@inflateBac@3
  0137c	00 00 00 00	 DD	 $LN259@inflateBac@3
  01380	00 00 00 00	 DD	 $LN130@inflateBac@3
  01384	00 00 00 00	 DD	 $LN5@inflateBac@3
  01388	00 00 00 00	 DD	 $LN2@inflateBac@3
  0138c	00 00 00 00	 DD	 $LN1@inflateBac@3
$LN339@inflateBac@3:
  01390	00		 DB	 0
  01391	06		 DB	 6
  01392	01		 DB	 1
  01393	06		 DB	 6
  01394	06		 DB	 6
  01395	02		 DB	 2
  01396	06		 DB	 6
  01397	06		 DB	 6
  01398	06		 DB	 6
  01399	03		 DB	 3
  0139a	06		 DB	 6
  0139b	06		 DB	 6
  0139c	06		 DB	 6
  0139d	06		 DB	 6
  0139e	06		 DB	 6
  0139f	06		 DB	 6
  013a0	06		 DB	 6
  013a1	04		 DB	 4
  013a2	05		 DB	 5
  013a3	90		 npad	 1
$LN341@inflateBac@3:
  013a4	00 00 00 00	 DD	 $LN305@inflateBac@3
  013a8	00 00 00 00	 DD	 $LN304@inflateBac@3
  013ac	00 00 00 00	 DD	 $LN303@inflateBac@3
  013b0	00 00 00 00	 DD	 $LN302@inflateBac@3
_inflateBack@20 ENDP
END
